[["index.html", "Building models using the Gadget framework 1 About this course 1.1 Course objectives 1.2 Your a priori homework 1.3 Reading material", " Building models using the Gadget framework 1 About this course 1.1 Course objectives This course is an introduction to using Gadget as an ecosystem simulator and stock assessment tool. It is introduced using Rgadget, an R library that simplifies and standardizes the procedure for creating the input model files needed for creating a Gadget model, as well as gather and visualize ouput files created by Gadget. Although input files can be created manually, Rgadget facilitates reproducability and aids internal consistency of Gadget model creation by allowing Gadget models to be created, run, analyzed, and shared using a single set of R scripts. Please note, however, that both Gadget and Rgadget are continuously being developed, so please remember to update your installations frequently (1x / month). In addition, Rgadget is programmed using ‘tidyverse’, so a good understanding of how to program using tidyverse is a necessity. By the end of this course you should: correctly structure and format input files for building a simple Gadget model and running a simulation via R using Rgadget become familiar enough with the various options in Gadget and how to implement them using the Gadget User Guide that comes with the Gadget installation, so that a more complex ecosystem can be simulated input data, generate likelihood components, and modify optimisation settings understand the iterative reweighting procedure implemented in Rgadget become familiar with predefined figures and data frames generated by gadget.fit 1.2 Your a priori homework Prior to the course make sure your operating system is a unix derivative, such as linux or macosx, as the code and examples in this course is only tested against these operating systems. Windows should in theory work, but issues related to Windows line endings are known to cause random issues in Gadget. For those who do not want dual boot their computers they can install VirtualBox and install linux on a virtual machine (you can find a selection of pre-install images here where it is recommended that you choose Ubuntu). However if you insist on using Windows you should install the icesTAF R-package to handle all the file conversion issues. To install Gadget follow the installation guide. Please also have the most recent version of R and Rstudio installed. In addition, if you plan to run a simple model using your own data, please: familiarize yourself with tidyverse programming think about your model structure/ aggregation level and have R scripts ready that aggregate your data into an appropriately formatted data frame (i.e., columns of : year, time step, area, age bins, length bins, or age- and length-bins - have a sneak peak at our example model data here) 1.3 Reading material A model of cod in Icelandic waters Two area cod - shrimp model Uncertainty estimates with Gadget MSE using ling in Icelandic waters Cod - herring - sprat in the Baltic CAPAM talk on the Rgadget environment Length-based assessments Talk on ling MSE Assessments that use Gadget: Ling in 5a Tusk in 5a and 14 Golden redfish in 5, 6, 12 and 14 Deep pelagic beaked redfish Atlantic wolffish in Icelandic waters Greenland halibut in the Northeast Artic Southern hake "],["general-context-of-gadget.html", "2 General context of Gadget 2.1 Gadget – a toolbox for fisheries stock assessments 2.2 Description of Gadget 2.3 This course", " 2 General context of Gadget Ecosystem considerations appear to be an obvious, and necessary part, of the management of marine resources. Several international organizations have stressed the importance of studying ecosystems interactions in terms of management [eg. @sinclair2002responsible, @nammco1997]. Optimum fisheries management based on ecosystem consideration is however an elusive target. Even if the model sufficiently describes the target ecosystem, @voss2014regional illustrated that the definition of the this optimum is dependent on the manager’s view of the resource. Although the rationale for ecosystem based approach to fisheries management is strong its adoption has been slow, which @mollmann2013implementing suggests is due to lack of strategy. However the effects of species interactions on the management of a commercially exploited stock is a fairly complicated and data intensive excercise, as it requires data not directly observed by fisheries. @dickey2013ecosystem note therefore that the state of knowledge is not sufficient to embark on ecosystem engineering, although in theory this would have desirable effects on the status of key resources, as such an undertaking may have undesirable and unforseen consequences. The choice of a modelling approach used to assimilate biological information such as those obtained from scientific surveys also needs some consideration. There are a number of approaches to ecosystems models. According to @plaganyi2007models they broadly fall broadly into four categories: Whole ecosystem approaches, where all trophic levels of the ecosystem are modelled [e.g. @christensen2004ecopath]. Dynamic systems models, where where the whole ecosystem and possibly its effects to coastal communities is modelled [e.g. @link2010northeast]. Extensions of single–species assesment models [e.g. @livingston1998incorporation]. Minimum realistic models, where only a few but significant interactions are included. Examples of cases are models built using the Gadget framework [@begley2004overview]. Obviously these approaches differ substantiantly both in scope and objectives. Minimimum realistic models and singles species extensions are, as the names suggest, more focussed on answering key questions and their parameters are estimated statistically. Modelling approaches, like those using Atlantis [@fulton2005ecological] or Ecopath with Ecosim [@christensen2004ecopath], often try to include a larger part of the ecosystem where it becomes harder to estimate the model parameters through comparisons with real data. These grand models tend to be more useful when answering strategic questions, such as discussed by @fulton2011lessons, rather than more tactical issues such as direct advice on next years quota. 2.1 Gadget – a toolbox for fisheries stock assessments Modelling approaches such as those allowed by Atlantis have, although interesting, tended to have quite obvious drawbacks in terms of comparisons to real data. Estimates of process parameters are far from trivial in this setting, both in terms of available data and more importantly computation time. A fullblown Atlantis model will generally take a substantial time for a single simulation and as such not obvious how one would obtain an ``optimal’’ fit in a statistical sense. That said, these types of model can provide valuable insight into how an ecosystems would behave. In particular one could study certain performance metrics, such as ecosystem indicators [as described in @fulton2005ecological], and various stock assessment models. It has been observed that in various settings single species models of a marine resource fail to explain model deviations. To answer these questions extensions to the normal single species have been developed [as discussed in @magnusson1995msvpa and references therein ]. These extensions attempt to ecompass significant processes that affect the species of interest. A special type of these approaches are the mimimally realistic models mentioned above [also referred to as MICE models as discussed in @plaganyi2014multispecies]. A special modelling framework, Gadget [**G**lobally **a**pplicable, area--**d**isaggregated **e**cosystem **t**oolbox, described in @begley2005gadget], was developed to aid in the study of various statistical processes involved in multi–species assessments. The development of Gadget conceptually dates back to MULTSPEC [@bogstad1997multspec], which described a multi–species model for fish and marine mammals in the Barents sea. Many of the underlying concepts and most of the codebase that forms the Gadget framework was date back to Bormicon [@stefansson1997bormicon, @stefansson1998framework], which was developed as a continuation of a multi-species sampling program [described in @mrifjolst], which has been under constant developement and iterations. Notable iterations include the Fleksibest framework [@guldbrandsen2002fleksibest], a fork of Bormicon which was merged back with Bormicon to form Gadget as part of the dst\\(^2\\) project [@dst2]. The dst\\(^2\\) project was multi-objective project funded by the European Union and began in 1999. The bas idea was to develop fisheries science as far as information will support'' the development of statistically sound models of marine ecological processes,but strictly no further’’. Four main objectives were the following: Collect relevant data and provide objective means to analyse them. This included the development of Gadget and a specialised data warehouse. Validate present stock assessment. Evaluate the appropriateness of complicated models when providing management advice. Evaluate and validate reference points used in management. A substantial amount of analysis has subsequently been made on Cod in Icelandic waters using the Gadget modeling framework. Notably @taylor2007simple which describes a thorough analysis of the available data and potential weaknesses. In it a single species single area model is considered. A continuation of this work in a multi-stock multi-species multi-area setting are described in @taylor2011gadget. There it is seen that substantial improvements in the model fit are possible by considering a north – south division in the cod stock. These developments have not been restricted to single–species models. A number of species have been analysed in a multi–species setting using Gadget. Notable implementaions include a model of the Barents sea of cod, capelin, herring and minke whales @lindstrom2009modelling and subsquently @howell2010combined where FLR @kell2007flr is used in connection with Gadget in a harvest control simulation. An illustration of a typical stock assessment process and the types of uncertainty associated with each step within Gadget. 2.2 Description of Gadget Gadget is essentially three things, an ecosystem simulator, a likelihood function that takes the output from the ecosystem simulator and compares to data, and a function mininimizer. Gadget’s simulation module allows for a fairly configurable ecosystem simulation. Its fundamental unit, a stock (or more accurately substock), represents a group of individuals that is homogenous with respect to various processes. These processes include growth, predation (including commercial fisheries) and migration. In this setup different stages of the life history of a particular species would be represented as separate stocks and individuals ``moved’’ between stocks when required. The simulation takes place in a set number of years or observations and time-steps within an observation. Years can be broken down into a maximum of 12 time-steps. The time-steps within the observations allow for the emulation of the annual cycles of the ecosystem, such as recruitment and stock migrations. The stock unit within Gadget is simply a representation of the total number of individuals within a certain age and length group from one or more certain area. When stocks live in multiple areas, they optionally migrate among areas during definable time-steps. In this setup, processes such as fleet harvest or recruitment can be restricted to take place only in certain areas. Harvesting of the substocks is defined through fleets that fish according to effort and (length–based) selection functions. Gadget’s likelihood module processes the output from the ecosystem simulation after aggregating across certain dimensions. Within the likelihood module, a number of datasets can be compared to the model output. In addition to a suite of functions designed to work with different types of survey indices, various other types of data , can be contrasted to the model output including compositional data (such as length distributions, age distributions, age- and length-distribution, or proportions mature) or tagging data to name a few. Each dataset is compared to model output at its own aggregation level, with missing data handled in a robust manner. In contrast with Gadget, age-based or stock production type stock assessments require data in a fairly processed form. For instance when using VPA one requires the total catch in numbers of individuals by age. However, apart from catches of fin whales in the North Atlantic @iwcistfin, one rarely has all catches by numbers at age. Therefore the age distribution of catches needs to be approximated using some combination of age readings, length distributions, total catches in tonnes and weight at age [as noted in @hirst2005estimating]. Essentially using VPA requires a two-step modelling process. Gadget’s function minimizer, based on the negative log–likelihood (but implemented as a simple sum of squares), varies the model parameters, runs a full simulation, and calculates a new output. This process is repeated until a minimum is obtained. The model has three alternative optimising algorithms linked to it, a wide area search simulated annealing [@corana1987minimizing], a local search Hooke and Jeeves algorithm [@HookeJeeves1961] and finally one based on the Broyden-Fletcher-Goldfarb-Shanno algorithm (BFGS). The simulated annealing and Hooke-Jeeves algorithms are not gradient based, and there is therefore no requirement for the likelihood surface to be smooth. Consequently neither of the two algorithms returns estimates of the Hessian matrix. Simulated annealing is more robust than Hooke and Jeeves and can find a global optima where there are multiple optima but needs about 2-3 times the order of magnitude in iterations than the Hooke and Jeeves algorithm to converge. BFGS is a quasi-Newton optimisation method that uses information about the gradient of the function at the current point to calculate the best direction to look for a better point. Using this information the BFGS algorithm can iteratively calculate a better approximation to the inverse Hessian matrix. When compared to the two other algorithms implemented in Gadget, BFGS is a very local search compared to simulated annealing and is more computationally intensive than the Hooke and Jeeves. However the gradient search in BFGS is more accurate than the step-wise search of Hooke and Jeeves and may therefore give a more accurate estimation of the optimum. The BFGS algorithm used in Gadget is derived from that presented by @bertsekas1999nonlinear. The total objective function to be minimised is a weighted sum of the different components. The estimation could be difficult due to groups of correlated parameters or multiple local optima. Therefore the optimisation procedure often involves a combination of the more robust simulated annealing, to make the results less sensitive to the initial (starting) values, and the local search algorithms (Hooke and Jeeves and BFGS), to obtain more accurate final values in the neighborhood of the global optimum. 2.3 This course During this course we will attempt to introduce how the key topic listed here above are implemented in Gadget. You will learn how to set up a simulation model using Gadget using the Rgadget functions. We will briefly discuss the how you can add data to your model and subsequently fit the model, but fuller analysis of how to include data into the model is very case specific and requires an analysis of a developed model. "],["introduction-to-tidyverse.html", "3 Introduction to Tidyverse 3.1 Idealogy behind R for Data Science 3.2 The foundation: tibbles, tidy data, and piping 3.3 Tidy data 3.4 The power of tidyverse: all you need in a handful of functions 3.5 Plotting in tidyverse 3.6 Statistical summary graphs 3.7 Other statistical summaries 3.8 Some controls 3.9 Further readings", " 3 Introduction to Tidyverse 3.1 Idealogy behind R for Data Science Tidyverse is a collection of R packages that enables tools for data science, and is especially useful for data wrangling, manipulation, visualization, and communication of large data sets. Extensions of tidyverse also enable direct connections and manipulation with SQL databases (e.g, dbplyr). Here we briefly introduce some main concepts when this programming, all derived directly from the open access book R for Data Science by Garrett Grolemund and Hadley Wickham (which can be found here). As you can read here, the main idea behind using tidyverse is that exploratory data analysis in R is composed of a few main steps: first is importing and tidying data, then iteratively transforming, visualising, and modeling data to understand patterns held by them, and finally communicating results effectively. Tidyverse was designed as a programming method and collection of functions that are focused on easing these tasks into a simple uniform routine that can be applied to any dataset. Standardizing the approach taken toward any data science project then aids reproducability of any project as well as the ability to collaborate on a project. 3.2 The foundation: tibbles, tidy data, and piping 3.2.1 Tibbles First we need to install and load Tidyverse. After that we can have a look at what at the main form of data storage, called a tibble: install.packages(&#39;tidyverse&#39;) install.packages(&#39;nycflights13&#39;) # this is an example data package ## ── [1mAttaching packages[22m ─────────────────────────────────────── tidyverse 1.3.0 ── ## [32m✔[39m [34mggplot2[39m 3.3.2 [32m✔[39m [34mpurrr [39m 0.3.4 ## [32m✔[39m [34mtibble [39m 3.0.4 [32m✔[39m [34mdplyr [39m 1.0.2 ## [32m✔[39m [34mtidyr [39m 1.1.2 [32m✔[39m [34mstringr[39m 1.4.0 ## [32m✔[39m [34mreadr [39m 1.4.0 [32m✔[39m [34mforcats[39m 0.5.0 ## ── [1mConflicts[22m ────────────────────────────────────────── tidyverse_conflicts() ── ## [31m✖[39m [34mdplyr[39m::[32mfilter()[39m masks [34mstats[39m::filter() ## [31m✖[39m [34mdplyr[39m::[32mlag()[39m masks [34mstats[39m::lag() library(nycflights13) Note that a tibble is essentially the same as a data frame (for example made with data.frame) but with some useful information printed (e.g., dimensions and data types), as well as some restrictions placed on how it an be manipulated. These help prevent common errors. For example, recycling is possible as it is in data frames but less flexible: flights$year &lt;- c(2013, 2014) try(flights$year &lt;- rep(2014, 7)) 3.3 Tidy data In addition, the above data may look like a standard data set obtained from anywhere, but it is not. It has already been formatted as ‘tidy data’. Although data can be represented a variety of ways in tables for visualization, but for data manipulation and analysis, there is only one format that is much easier to use than others. Therefore, all data should be transformed into this format before analyzing. This format is called the ‘tidy’ dataset in tidyverse, and following three rules make a dataset ‘tidy’: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. If, for example, the flights dataset were organized such that each carrier, origin, or dest had their own sets of columns, the data would no longer be tidy. 3.3.1 Piping In base R programming, functions wrap around the objects that they are applied to, which are often indexed, and this manipulated object is saved as a new one. What is written is arranged like an onion: in the following example, the first step of the command is in the center of code (calling the object flights), followed by indexing the 15th and 16th columns. As we move away from the center, a function is applied, and finally the output of that function is assigned to a new object. sub &lt;- apply(flights[,c(15:16)], 2, mean, na.rm = T) Piping, or using ‘%&gt;%’ to pass objects from one function to the next, introduces a programming method that makes the process more intuitive by alligning the code with the order of operation: flights %&gt;% select(15, 16) %&gt;% # or use select(air_time, distance) apply(., 2, mean, na.rm = T) -&gt; sub In the above code, the flight tibble was piped into the ‘select’ function, which indexed its 15th and 16th rows only. ‘Select’ does not require an argument where flights is referenced because it was built to accept a piped argument implicitly. Note that selecting by column name (no quotations needed) is also possible and more useful in most cases. After being piped to ‘select’, the result was then piped to the function ‘apply’. ‘Apply’ is an older function that is not built to implicitly accept piped objects; therefore, it requires the placeholder ‘.’ to be placed where the input data frame is expected. Finally, this modified data frame is assigned to ‘sub’ at the end, but alternatively it could have been assigned at the beginning as in the non-piped version. 3.4 The power of tidyverse: all you need in a handful of functions As in the ‘select’ function, there are a variety of functions that come with the tidyverse package, but only a small set are needed to do almost any kind of data wrangling that you ever wanted to do. These are the only functions we touch on in this brief introduction. However, beyond tidyverse, there are also a variety of packages that implement more advanced piping-compatible functions that speed the manipulation of large data sets in particular (e.g., dbplyr, purrrlyr). The most commonly used tidyverse commands, with a brief description, include: * select() - select columns * filter() - retain rows according to boolean criteria * arrange() - sorts data * rename() - renames existing columns * mutate() - writes new columns * group_by() / ungroup() - groups data according to column values (such as factors) * summarise() - reduces dataset to an aggregated leve. Used after grouping (which defines the aggregation level) and along with functions that define how to aggregate (e.g., count(), n(), sum(), mean()). * gather() / spread() - converts data between the tidy format and ‘long’ formats * full_join(), left_join(), etc. - joins data contained in two data frames according to certain criteria that define how rows are compatible (i.e., joining in relational databases) Below is an example of how the function ‘apply’ in the previous example can be replaced using tidyverse commands, as well as functions such as ‘aggregate’ using ‘group_by’ and ‘summarise’ flights %&gt;% select(air_time, distance) %&gt;% summarise(mn_airtime = mean(air_time, na.rm = T), mn_distance = mean(distance)) ## [90m# A tibble: 1 x 2[39m ## mn_airtime mn_distance ## [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m 151. [4m1[24m040. # or if the operation should occur by groupings: flights %&gt;% select(dest, air_time, distance) %&gt;% group_by(dest) %&gt;% summarise(mn_airtime = mean(air_time, na.rm = T), mn_distance = mean(distance)) ## `summarise()` ungrouping output (override with `.groups` argument) ## [90m# A tibble: 105 x 3[39m ## dest mn_airtime mn_distance ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ABQ 249. [4m1[24m826 ## [90m 2[39m ACK 42.1 199 ## [90m 3[39m ALB 31.8 143 ## [90m 4[39m ANC 413. [4m3[24m370 ## [90m 5[39m ATL 113. 757. ## [90m 6[39m AUS 213. [4m1[24m514. ## [90m 7[39m AVL 89.9 584. ## [90m 8[39m BDL 25.5 116 ## [90m 9[39m BGR 54.1 378 ## [90m10[39m BHM 123. 866. ## [90m# … with 95 more rows[39m Here is a smattering of demonstrations on how to use the other important functions and their equivalents in base R: 3.4.0.1 filter() #filter() flights[flights$month==3 &amp; flights$dest==&quot;DEN&quot;,] ## [90m# A tibble: 643 x 19[39m ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m 1[39m [4m2[24m013 3 1 630 630 0 831 910 ## [90m 2[39m [4m2[24m013 3 1 648 649 -[31m1[39m 830 912 ## [90m 3[39m [4m2[24m013 3 1 649 649 0 839 920 ## [90m 4[39m [4m2[24m013 3 1 814 815 -[31m1[39m [4m1[24m012 [4m1[24m056 ## [90m 5[39m [4m2[24m013 3 1 827 830 -[31m3[39m [4m1[24m045 [4m1[24m106 ## [90m 6[39m [4m2[24m013 3 1 843 800 43 [4m1[24m042 [4m1[24m031 ## [90m 7[39m [4m2[24m013 3 1 857 900 -[31m3[39m [4m1[24m057 [4m1[24m135 ## [90m 8[39m [4m2[24m013 3 1 922 925 -[31m3[39m [4m1[24m115 [4m1[24m205 ## [90m 9[39m [4m2[24m013 3 1 [4m1[24m056 [4m1[24m100 -[31m4[39m [4m1[24m258 [4m1[24m326 ## [90m10[39m [4m2[24m013 3 1 [4m1[24m144 [4m1[24m137 7 [4m1[24m327 [4m1[24m403 ## [90m# … with 633 more rows, and 11 more variables: arr_delay [3m[90m&lt;dbl&gt;[90m[23m, carrier [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# flight [3m[90m&lt;int&gt;[90m[23m, tailnum [3m[90m&lt;chr&gt;[90m[23m, origin [3m[90m&lt;chr&gt;[90m[23m, dest [3m[90m&lt;chr&gt;[90m[23m, air_time [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# distance [3m[90m&lt;dbl&gt;[90m[23m, hour [3m[90m&lt;dbl&gt;[90m[23m, minute [3m[90m&lt;dbl&gt;[90m[23m, time_hour [3m[90m&lt;dttm&gt;[90m[23m[39m flights %&gt;% filter(month == 3, dest == &quot;DEN&quot;) ## [90m# A tibble: 643 x 19[39m ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m 1[39m [4m2[24m013 3 1 630 630 0 831 910 ## [90m 2[39m [4m2[24m013 3 1 648 649 -[31m1[39m 830 912 ## [90m 3[39m [4m2[24m013 3 1 649 649 0 839 920 ## [90m 4[39m [4m2[24m013 3 1 814 815 -[31m1[39m [4m1[24m012 [4m1[24m056 ## [90m 5[39m [4m2[24m013 3 1 827 830 -[31m3[39m [4m1[24m045 [4m1[24m106 ## [90m 6[39m [4m2[24m013 3 1 843 800 43 [4m1[24m042 [4m1[24m031 ## [90m 7[39m [4m2[24m013 3 1 857 900 -[31m3[39m [4m1[24m057 [4m1[24m135 ## [90m 8[39m [4m2[24m013 3 1 922 925 -[31m3[39m [4m1[24m115 [4m1[24m205 ## [90m 9[39m [4m2[24m013 3 1 [4m1[24m056 [4m1[24m100 -[31m4[39m [4m1[24m258 [4m1[24m326 ## [90m10[39m [4m2[24m013 3 1 [4m1[24m144 [4m1[24m137 7 [4m1[24m327 [4m1[24m403 ## [90m# … with 633 more rows, and 11 more variables: arr_delay [3m[90m&lt;dbl&gt;[90m[23m, carrier [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# flight [3m[90m&lt;int&gt;[90m[23m, tailnum [3m[90m&lt;chr&gt;[90m[23m, origin [3m[90m&lt;chr&gt;[90m[23m, dest [3m[90m&lt;chr&gt;[90m[23m, air_time [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# distance [3m[90m&lt;dbl&gt;[90m[23m, hour [3m[90m&lt;dbl&gt;[90m[23m, minute [3m[90m&lt;dbl&gt;[90m[23m, time_hour [3m[90m&lt;dttm&gt;[90m[23m[39m 3.4.0.2 arrange() o &lt;- order(flights$distance) flights[o,c(&#39;year&#39;,&#39;month&#39;,&#39;day&#39;,&#39;distance&#39;)] ## [90m# A tibble: 336,776 x 4[39m ## year month day distance ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m2[24m013 7 27 17 ## [90m 2[39m [4m2[24m013 1 3 80 ## [90m 3[39m [4m2[24m013 1 4 80 ## [90m 4[39m [4m2[24m013 1 4 80 ## [90m 5[39m [4m2[24m013 1 4 80 ## [90m 6[39m [4m2[24m013 1 5 80 ## [90m 7[39m [4m2[24m013 1 6 80 ## [90m 8[39m [4m2[24m013 1 7 80 ## [90m 9[39m [4m2[24m013 1 8 80 ## [90m10[39m [4m2[24m013 1 9 80 ## [90m# … with 336,766 more rows[39m flights[rev(o),c(&#39;year&#39;,&#39;month&#39;,&#39;day&#39;,&#39;distance&#39;)] ## [90m# A tibble: 336,776 x 4[39m ## year month day distance ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m2[24m013 9 30 [4m4[24m983 ## [90m 2[39m [4m2[24m013 9 29 [4m4[24m983 ## [90m 3[39m [4m2[24m013 9 28 [4m4[24m983 ## [90m 4[39m [4m2[24m013 9 27 [4m4[24m983 ## [90m 5[39m [4m2[24m013 9 25 [4m4[24m983 ## [90m 6[39m [4m2[24m013 9 23 [4m4[24m983 ## [90m 7[39m [4m2[24m013 9 22 [4m4[24m983 ## [90m 8[39m [4m2[24m013 9 21 [4m4[24m983 ## [90m 9[39m [4m2[24m013 9 20 [4m4[24m983 ## [90m10[39m [4m2[24m013 9 18 [4m4[24m983 ## [90m# … with 336,766 more rows[39m flights %&gt;% select(year, month, day, distance) %&gt;% arrange(distance) ## [90m# A tibble: 336,776 x 4[39m ## year month day distance ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m2[24m013 7 27 17 ## [90m 2[39m [4m2[24m013 1 3 80 ## [90m 3[39m [4m2[24m013 1 4 80 ## [90m 4[39m [4m2[24m013 1 4 80 ## [90m 5[39m [4m2[24m013 1 4 80 ## [90m 6[39m [4m2[24m013 1 5 80 ## [90m 7[39m [4m2[24m013 1 6 80 ## [90m 8[39m [4m2[24m013 1 7 80 ## [90m 9[39m [4m2[24m013 1 8 80 ## [90m10[39m [4m2[24m013 1 9 80 ## [90m# … with 336,766 more rows[39m flights %&gt;% select(year, month, day, distance) %&gt;% arrange(desc(distance)) ## [90m# A tibble: 336,776 x 4[39m ## year month day distance ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m2[24m013 1 1 [4m4[24m983 ## [90m 2[39m [4m2[24m013 1 2 [4m4[24m983 ## [90m 3[39m [4m2[24m013 1 3 [4m4[24m983 ## [90m 4[39m [4m2[24m013 1 4 [4m4[24m983 ## [90m 5[39m [4m2[24m013 1 5 [4m4[24m983 ## [90m 6[39m [4m2[24m013 1 6 [4m4[24m983 ## [90m 7[39m [4m2[24m013 1 7 [4m4[24m983 ## [90m 8[39m [4m2[24m013 1 8 [4m4[24m983 ## [90m 9[39m [4m2[24m013 1 9 [4m4[24m983 ## [90m10[39m [4m2[24m013 1 10 [4m4[24m983 ## [90m# … with 336,766 more rows[39m 3.4.0.3 rename() flights2 &lt;- data.frame(flights, year2 = flights$year) flights2 &lt;- as_tibble(flights2[c(dim(flights2)[2],2:(dim(flights2)[2]-1))]) flights2 ## [90m# A tibble: 336,776 x 19[39m ## year2 month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m 1[39m [4m2[24m013 1 1 517 515 2 830 819 ## [90m 2[39m [4m2[24m013 1 1 533 529 4 850 830 ## [90m 3[39m [4m2[24m013 1 1 542 540 2 923 850 ## [90m 4[39m [4m2[24m013 1 1 544 545 -[31m1[39m [4m1[24m004 [4m1[24m022 ## [90m 5[39m [4m2[24m013 1 1 554 600 -[31m6[39m 812 837 ## [90m 6[39m [4m2[24m013 1 1 554 558 -[31m4[39m 740 728 ## [90m 7[39m [4m2[24m013 1 1 555 600 -[31m5[39m 913 854 ## [90m 8[39m [4m2[24m013 1 1 557 600 -[31m3[39m 709 723 ## [90m 9[39m [4m2[24m013 1 1 557 600 -[31m3[39m 838 846 ## [90m10[39m [4m2[24m013 1 1 558 600 -[31m2[39m 753 745 ## [90m# … with 336,766 more rows, and 11 more variables: arr_delay [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# carrier [3m[90m&lt;chr&gt;[90m[23m, flight [3m[90m&lt;int&gt;[90m[23m, tailnum [3m[90m&lt;chr&gt;[90m[23m, origin [3m[90m&lt;chr&gt;[90m[23m, dest [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# air_time [3m[90m&lt;dbl&gt;[90m[23m, distance [3m[90m&lt;dbl&gt;[90m[23m, hour [3m[90m&lt;dbl&gt;[90m[23m, minute [3m[90m&lt;dbl&gt;[90m[23m, time_hour [3m[90m&lt;dttm&gt;[90m[23m[39m flights2 &lt;- flights %&gt;% rename(year2 = year) flights2 ## [90m# A tibble: 336,776 x 19[39m ## year2 month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m 1[39m [4m2[24m013 1 1 517 515 2 830 819 ## [90m 2[39m [4m2[24m013 1 1 533 529 4 850 830 ## [90m 3[39m [4m2[24m013 1 1 542 540 2 923 850 ## [90m 4[39m [4m2[24m013 1 1 544 545 -[31m1[39m [4m1[24m004 [4m1[24m022 ## [90m 5[39m [4m2[24m013 1 1 554 600 -[31m6[39m 812 837 ## [90m 6[39m [4m2[24m013 1 1 554 558 -[31m4[39m 740 728 ## [90m 7[39m [4m2[24m013 1 1 555 600 -[31m5[39m 913 854 ## [90m 8[39m [4m2[24m013 1 1 557 600 -[31m3[39m 709 723 ## [90m 9[39m [4m2[24m013 1 1 557 600 -[31m3[39m 838 846 ## [90m10[39m [4m2[24m013 1 1 558 600 -[31m2[39m 753 745 ## [90m# … with 336,766 more rows, and 11 more variables: arr_delay [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# carrier [3m[90m&lt;chr&gt;[90m[23m, flight [3m[90m&lt;int&gt;[90m[23m, tailnum [3m[90m&lt;chr&gt;[90m[23m, origin [3m[90m&lt;chr&gt;[90m[23m, dest [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# air_time [3m[90m&lt;dbl&gt;[90m[23m, distance [3m[90m&lt;dbl&gt;[90m[23m, hour [3m[90m&lt;dbl&gt;[90m[23m, minute [3m[90m&lt;dbl&gt;[90m[23m, time_hour [3m[90m&lt;dttm&gt;[90m[23m[39m 3.4.0.4 mutate() flights2 &lt;- as_tibble(data.frame(flights, air_time_hr = flights$air_time/60, distance_1000m = flights$distance/1000)) flights2 &lt;- flights %&gt;% mutate(air_time_hr = air_time/60, distance_1000m = distance/1000) flights2 ## [90m# A tibble: 336,776 x 21[39m ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m 1[39m [4m2[24m013 1 1 517 515 2 830 819 ## [90m 2[39m [4m2[24m013 1 1 533 529 4 850 830 ## [90m 3[39m [4m2[24m013 1 1 542 540 2 923 850 ## [90m 4[39m [4m2[24m013 1 1 544 545 -[31m1[39m [4m1[24m004 [4m1[24m022 ## [90m 5[39m [4m2[24m013 1 1 554 600 -[31m6[39m 812 837 ## [90m 6[39m [4m2[24m013 1 1 554 558 -[31m4[39m 740 728 ## [90m 7[39m [4m2[24m013 1 1 555 600 -[31m5[39m 913 854 ## [90m 8[39m [4m2[24m013 1 1 557 600 -[31m3[39m 709 723 ## [90m 9[39m [4m2[24m013 1 1 557 600 -[31m3[39m 838 846 ## [90m10[39m [4m2[24m013 1 1 558 600 -[31m2[39m 753 745 ## [90m# … with 336,766 more rows, and 13 more variables: arr_delay [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# carrier [3m[90m&lt;chr&gt;[90m[23m, flight [3m[90m&lt;int&gt;[90m[23m, tailnum [3m[90m&lt;chr&gt;[90m[23m, origin [3m[90m&lt;chr&gt;[90m[23m, dest [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# air_time [3m[90m&lt;dbl&gt;[90m[23m, distance [3m[90m&lt;dbl&gt;[90m[23m, hour [3m[90m&lt;dbl&gt;[90m[23m, minute [3m[90m&lt;dbl&gt;[90m[23m, time_hour [3m[90m&lt;dttm&gt;[90m[23m,[39m ## [90m# air_time_hr [3m[90m&lt;dbl&gt;[90m[23m, distance_1000m [3m[90m&lt;dbl&gt;[90m[23m[39m 3.4.0.5 group_by() with count() #count() with group_by() #this yields data in a &#39;long&#39; format flights2a &lt;- t(table(flights[,c(&#39;origin&#39;, &#39;dest&#39;)])) head(flights2a) ## origin ## dest EWR JFK LGA ## ABQ 0 254 0 ## ACK 0 265 0 ## ALB 439 0 0 ## ANC 8 0 0 ## ATL 5022 1930 10263 ## AUS 968 1471 0 #this yields &#39;tidy&#39; data flights2 &lt;- flights %&gt;% group_by(origin, dest) %&gt;% count() flights2 ## [90m# A tibble: 224 x 3[39m ## [90m# Groups: origin, dest [224][39m ## origin dest n ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m 1[39m EWR ALB 439 ## [90m 2[39m EWR ANC 8 ## [90m 3[39m EWR ATL [4m5[24m022 ## [90m 4[39m EWR AUS 968 ## [90m 5[39m EWR AVL 265 ## [90m 6[39m EWR BDL 443 ## [90m 7[39m EWR BNA [4m2[24m336 ## [90m 8[39m EWR BOS [4m5[24m327 ## [90m 9[39m EWR BQN 297 ## [90m10[39m EWR BTV 931 ## [90m# … with 214 more rows[39m 3.4.0.6 spread() / gather() to convert between long and tidy formats: flights2b &lt;- flights2 %&gt;% as_tibble() %&gt;% spread(key = origin, value = n, fill = 0) #result in the same formats flights2b ## [90m# A tibble: 105 x 4[39m ## dest EWR JFK LGA ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ABQ 0 254 0 ## [90m 2[39m ACK 0 265 0 ## [90m 3[39m ALB 439 0 0 ## [90m 4[39m ANC 8 0 0 ## [90m 5[39m ATL [4m5[24m022 [4m1[24m930 [4m1[24m[4m0[24m263 ## [90m 6[39m AUS 968 [4m1[24m471 0 ## [90m 7[39m AVL 265 0 10 ## [90m 8[39m BDL 443 0 0 ## [90m 9[39m BGR 0 0 375 ## [90m10[39m BHM 0 1 296 ## [90m# … with 95 more rows[39m head(flights2a) ## origin ## dest EWR JFK LGA ## ABQ 0 254 0 ## ACK 0 265 0 ## ALB 439 0 0 ## ANC 8 0 0 ## ATL 5022 1930 10263 ## AUS 968 1471 0 flights2b %&gt;% gather(key = origin, value = n, -dest) %&gt;% filter(n!=0) ## [90m# A tibble: 224 x 3[39m ## dest origin n ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ALB EWR 439 ## [90m 2[39m ANC EWR 8 ## [90m 3[39m ATL EWR [4m5[24m022 ## [90m 4[39m AUS EWR 968 ## [90m 5[39m AVL EWR 265 ## [90m 6[39m BDL EWR 443 ## [90m 7[39m BNA EWR [4m2[24m336 ## [90m 8[39m BOS EWR [4m5[24m327 ## [90m 9[39m BQN EWR 297 ## [90m10[39m BTV EWR 931 ## [90m# … with 214 more rows[39m head(flights2) ## [90m# A tibble: 6 x 3[39m ## [90m# Groups: origin, dest [6][39m ## origin dest n ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m ## [90m1[39m EWR ALB 439 ## [90m2[39m EWR ANC 8 ## [90m3[39m EWR ATL [4m5[24m022 ## [90m4[39m EWR AUS 968 ## [90m5[39m EWR AVL 265 ## [90m6[39m EWR BDL 443 3.5 Plotting in tidyverse Tidyverse also uses ggplot2, which is intended to simplify the process of creating plots so that data can be quickly and easily visualized as an iterative component of the exploratory analysis process. Some advantages include an clear method for translating data to visuals, having many preconfigured attributes available, and being able to build and modify previously stored plot objects without needing to recreate them. A downside is that to take advantage of the full power and flexibility of ggplot2 requires a wide knowledge of what is available as options to include in graphics, and therefore involve a long learning curve. However, the ultimate results are well worth the learning investment. For a basic explanation and cheat sheet see here 3.5.1 ggplot: Key components ggplot has three key components: data, this must be a data.frame A set of aesthetic mappings (aes) between variables in the data and visual properties, and At least one layer which describes how to render each observation. sub &lt;- flights %&gt;% sample_n(100, replace = F) %&gt;% filter(!is.na(distance), !is.na(air_time), !is.na(origin), !is.na(month), !is.na(dest)) ggplot(data = sub, aes(x = distance, y = air_time)) + geom_point() Different syntax, equivalent outcome: ggplot(sub, aes(distance, air_time)) + geom_point() ggplot() + geom_point(data = sub, aes(distance, air_time)) ggplot(data = sub) + geom_point(aes(x = distance, y = air_time)) ggplot(sub) + geom_point(aes(distance, air_time)) Can be stored as an object for later use. This is a useful feature of Rgadget: because default plots are created in ggplot, they can be stored and modified by the user at a later point. p &lt;- ggplot(sub, aes(distance, air_time)) + geom_point() The class: class(p) ## [1] &quot;gg&quot; &quot;ggplot&quot; The structure (a bit of Latin - not run here): str(p) 3.5.2 aesthetic Adding more variables to a two dimensional scatterplot can be done by mapping the variables to an aesthetic (colour, fill, size, shape, alpha) 3.5.2.1 colour p &lt;- ggplot(sub, aes(distance, air_time)) p + geom_point(aes(colour = origin)) p + geom_point(aes(colour = dest)) Manual control of colours or other palette schemes (here brewer): p + geom_point(aes(colour = origin)) + scale_colour_manual(values = c(&quot;orange&quot;,&quot;brown&quot;,&quot;green&quot;)) p + geom_point(aes(colour = dest)) + scale_colour_brewer(palette = &quot;Set1&quot;) ## Warning in RColorBrewer::brewer.pal(n, pal): n too large, allowed maximum for palette Set1 is 9 ## Returning the palette you asked for with that many colors ## Warning: Removed 73 rows containing missing values (geom_point). Note, to view all the brewer palettes do: RColorBrewer::display.brewer.all() 3.5.2.2 shape p + geom_point(aes(distance, air_time, shape = origin)) 3.5.2.3 size p + geom_point(aes(distance, air_time, size = month)) One can also “fix” the aesthetic manually, e.g.: ggplot(sub, aes(distance, air_time)) + geom_point(colour = &quot;blue&quot;, shape = 8, size = 10) Note here that the call to colour, shape, etc. is done outside the aes-call. One can also combine calls inside and outside the aes-function (here we showing overlay of adjacent datapoints): p + geom_point(aes(distance, air_time, size = month), alpha = 0.3, col = &quot;red&quot;) 3.5.3 Facetting Splitting a graph into subsets based on a categorical variable. ggplot(sub) + geom_point(aes(distance, air_time, colour = as.factor(year))) + facet_wrap(~ origin) One can also split the plot using two variables using the function facet_grid: ggplot(sub) + geom_point(aes(distance, air_time)) + facet_grid(as.factor(year) ~ origin) 3.5.4 Adding layers The power of ggplot comes into place when one adds layers on top of other layers. Let’s for now look at only at two examples. 3.5.5 Add a line to a scatterplot ggplot(sub, aes(distance, air_time)) + geom_point() + geom_line() 3.5.5.1 Add a smoother to a scatterplot p &lt;- ggplot(sub, aes(distance, air_time)) p + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; p + geom_point() + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 3.6 Statistical summary graphs There are some useful inbuilt routines within the ggplot2-packages which allows one to create some simple summary plots of the raw data. 3.6.0.1 bar plot One can create bar graph for discrete data using the geom_bar ggplot(sub, aes(dest)) + geom_bar() The graph shows the number of observations we have of each destination. The original data is first transformed behind the scene into a table of counts, before being rendered. 3.6.0.2 histograms For continuous data one uses the geom_histogram-function (left default bin-number, right bindwith specified as 50 mins): p &lt;- ggplot(sub, aes(air_time)) p + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p + geom_histogram(binwidth = 50) One can add another variable (left) or better use facet (right): p + geom_histogram(aes(fill = origin)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p + geom_histogram() + facet_wrap(~ origin, ncol = 1) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.6.0.3 Frequency polygons Alternatives to histograms for continuous data are frequency polygons: p + geom_freqpoly(lwd = 1) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p + geom_freqpoly(aes(colour = origin), lwd = 1) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.6.0.4 Box-plots Boxplots, which are more condensed summaries of the data than histograms, are called using geom_boxplot. Here two versions of the same graph are used, the one on the left is the default, but on the right we have reordered the maturity variable on the x-axis such that the median value of length increases from left to right: ggplot(sub, aes(dest, air_time)) + geom_boxplot() p &lt;- ggplot(sub, aes(reorder(dest, air_time), air_time)) + geom_boxplot() p It is sometimes useful to plot the “raw” data over summary plots. Using geom_point as an overlay is sometimes not very useful when points overlap too much; geom_jitter can sometimes be more useful: p + geom_point(colour = &quot;red&quot;, alpha = 0.5, size = 1) p + geom_jitter(colour = &quot;red&quot;, alpha = 0.5, size = 1) Read the help on geom_violin and create a code that results in this plot: 3.7 Other statistical summaries Using stat_summary one can call specific summary statistics. Here are examples of 4 plots, going from top-left to bottom right we have: Raw data with median length at age (red) superimposed A pointrange plot showing the mean and the range A pointrange plot showing the mean and the standard error A pointrange plot showing the bootstrap mean and standard error sub$distance &lt;- round(sub$distance) p &lt;- ggplot(sub, aes(distance, air_time)) p + geom_point(alpha = 0.25) + stat_summary(fun.y = &quot;median&quot;, geom = &quot;point&quot;, colour = &quot;red&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. p + stat_summary(fun.y = &quot;mean&quot;, fun.ymin = &quot;min&quot;, fun.ymax = &quot;max&quot;, geom = &quot;pointrange&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. ## Warning: `fun.ymin` is deprecated. Use `fun.min` instead. ## Warning: `fun.ymax` is deprecated. Use `fun.max` instead. p + stat_summary(fun.data = &quot;mean_se&quot;) ## Warning: Removed 26 rows containing missing values (geom_segment). p + stat_summary(fun.data = &quot;mean_cl_boot&quot;) ## Warning: Computation failed in `stat_summary()`: ## Hmisc package required for this function 3.8 Some controls 3.8.1 labels p &lt;- ggplot(sub, aes(distance, air_time, colour = origin)) + geom_point() p + labs(x = &quot;Distance (miles)&quot;, y = &quot;Air time (minutes)&quot;, colour = &quot;Origin&quot;, title = &quot;My flight plot&quot;, subtitle = &quot;My nice subtitle&quot;, caption = &quot;My caption&quot;) 3.8.2 Legend position p + theme(legend.position = &quot;none&quot;) p &lt;- p + theme(legend.position = c(0.8, 0.3)) p 3.8.3 breaks Controls which values appear as tick marks p + scale_x_continuous(breaks = seq(5, 45, by = 10)*100) + scale_y_continuous(breaks = seq(50, 400, by = 50)) 3.8.4 limits p + ylim(100, 500) ## Warning: Removed 32 rows containing missing values (geom_point). p + ylim(NA, 500) # setting only upper limit 3.9 Further readings The ggplot2 site: http://ggplot2.tidyverse.org The ggplot2 book in the making: https://github.com/hadley/ggplot2-book A rendered version of the book: http://www.hafro.is/~einarhj/education/ggplot2 needs to be updates R4DS - Data visualisation R graphics cookbook: http://www.cookbook-r.com/Graphs Data Visualization Cheat Sheet "],["getting-started-with-the-gadget-framework.html", "4 Getting started with the Gadget framework 4.1 What is Rgadget? 4.2 Using Rgadget 4.3 Creating model input files 4.4 Starting a simulation 4.5 Gadget variables 4.6 Predation 4.7 Fleet operations 4.8 Recruitment", " 4 Getting started with the Gadget framework Install devtools, Rgadget and mfdb. Rgadget is under constant construction so please remember to update it regularly (e.g., monthly). install.packages(c(&#39;devtools&#39;,&#39;mfdb&#39;)) devtools::install_github(&#39;hafro/rgadget&#39;) Note that you can update all packages, both from github and CRAN using the update_packages command from devtools 4.1 What is Rgadget? Because it was originally designed as an ecosystem simulator, Gadget already has a number of optional features structurally integrated with basic population dynamics, making it extremely flexible for representing a wide variety of real-life biological scenarios (e.g., substock structure, length-based processes, predator-prey dynamics, temperature-dependent growth). However, Gadget was created when Unix workstations were the most powerful and popular operating systems available, and therefore lacks by itself a user-friendly GUI. It is a collection of C++ scripts that comprise its own program, similar to models created using ADMB. Running Gadget requires providing a rather large set of individual text files that specify model settings and data. As a result, creating more complex models involving a large set of similar input text files can become tedious and error-prone, and can impair reproducability. Rgadget was intended to be a solution to this problem, by linking the power behind Gadget with the familiar R interface. Therefore, 90% of Rgadget’s functionality is file and data handling: it creates files that are in a correct format so that Gadget understands them, creates organized directories for storing those files, takes care of main file dependencies and compatibility issues, and creates a direct pipeline for inserting data into such files. It additionally runs Gadget, implements an iterative reweighting algorithm to aid with data weighting issues when there are multiple sources of data, reads file output, and merges input and output data so that meaningful illustrative and diagnostic figures can be made (a variety of which come predefined). Rgadget is your best friend if you want to quickly make reproducable, trackable, interpretable, and sharable models using Gadget. Gadget has a variety of convenience functions included that will become more visible as examples are walked through, but the main types of functions to recognize include: file creation functions (e.g, gadgetfile, gadgetstock, gadgettime, gadgetfleet, gadgetlikelihood, gadgetdata, etc.), file I/O functions (e.g.,write.gadget.file, read.gadget.file, etc.), file modification functions (e.g., init_guess, gadget_update), functions that run Gadget (e.g., callGadget, gadget.iterative, gadget.forward), functions that compile input and output and create plots to analyze model fits (e.g., gadget.fit, bind.gadget.fit). Using this set of functions, the general work flow for using Gadget to fit a statistical model via Rgadget is demonstrated in our examples and follows the pattern: Create new Gadget input file objects within R and write them to disk to comprise an initial Gadget model structure. Run an initial Gadget simulation to test files and conveniently create input paramater files. Read certain Gadget model files back into R, so that they can be modified and then overwritten. Run an initial Gadget fitting procedure to conveniently create more input files (i.e., decent starting values). Set optimisation function parameters and run a statistical Gadget model run using reiterative weighting to determine relative contribution of each data source to the objective function. Visualize the model fit. As most programming errors and debugging occur in steps 1 - 4, most of this course will focus on these steps. Statistical model fitting and visualization will be demonstrated, but details regarding the statistical theory behind fitting procedures, analysis of model fit, and diagnostics are beyond the scope of this course. 4.2 Using Rgadget To use the Rgadget functions you will need to load it into your R workspace in the usual manner: library(tidyverse) library(Rgadget) For convenience Rgadget will also load the tidyverse package as it is used extensively when interacting with Gadget and viewing the output. As noted above Rgadget has a number of functions and we will introduce the main functions in Rgadget as we go through the tutorial. Here we will focus on setting up a simple dummy model using the gadgetfile function and functions that are its derivatives. The gadgetfile function is low level function that creates an R object that can be exported to files that coheres to the Gadget file format, described in the Gadget userguide. Essentially a Gadget file is structured by a list of named components and within those components there are named settings. As an example of this you can create your own custom Gadget file by specifying the components as named lists embedded within a named list: dummy &lt;- gadgetfile(&#39;test&#39;,file_type = &#39;generic&#39;, components = list(fruit=list(apple=1,orange=5), vegetable=list(cucumber=1))) dummy ## ; Generated by Rgadget 0.5 ## [fruit] ## apple 1 ## orange 5 ## [vegetable] ## cucumber 1 You will note that when calling the gadgetfile object the printed output will be in the same format as the resulting Gadget file. This for our mainly convenience as you will be able to directly see if the format is incorrect, by comparing it to the format described in the userguide, before writing it to file. If you need however to access individual components of you can of course do so by calling the name of the component directly: dummy$fruit ## $apple ## [1] 1 ## ## $orange ## [1] 5 and if you want to investigate the structure further you can call str on the object: str(dummy) ## List of 2 ## $ fruit :List of 2 ## ..$ apple : num 1 ## ..$ orange: num 5 ## $ vegetable:List of 1 ## ..$ cucumber: num 1 ## - attr(*, &quot;file_name&quot;)= chr &quot;test&quot; ## - attr(*, &quot;file_config&quot;)=List of 6 ## ..$ file_type : chr &quot;generic&quot; ## ..$ mainfile_section : chr NA ## ..$ bare_component : chr &quot;FALSE&quot; ## ..$ sub_component : chr &quot;&quot; ## ..$ implicit_component: chr &quot;&quot; ## ..$ df_component : chr &quot;&quot; ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;gadgetfile&quot; &quot;list&quot; The file type argument in gadgetfile allows the function to customize the output depending to the various quirks of the file. You can see the different file types currently allowed for by gadgetfile by calling gadget_filetypes: file_type mainfile_section bare_component sub_component implicit_component df_component main NA FALSE time timefile FALSE area areafile FALSE ^(temperature)$ ^(temperature)$ stock stockfiles ^(initialconditions)$ ^(suitability)$ ^(doesgrow|naturalmortality|iseaten|doeseat|doesmigrate|doesmature|doesmove|doesrenew|doesspawn|doesstray)$ tag tagfiles FALSE otherfood otherfoodfiles FALSE fleet fleetfiles FALSE ^(suitability|amount)$ likelihood likelihoodfiles FALSE print printfiles FALSE timevariable NA FALSE ^(data)$ ^(data)$ stockvariable NA FALSE generic NA FALSE data NA FALSE The output can then subsequently be written to a file using write.gadget.file: write.gadget.file(obj=dummy,path=&#39;somewhere_over_the_rainbow&#39;) 4.3 Creating model input files Having described how gadgetfile works we can now start to define our first model, which we will refer to as the “Simple model”. This is done by first deciding where to put the model and the associated files. Rgadget helps you by creating a convenience function gadget.variant.dir whichs set up a working directory for the Gadget model: gd &lt;- gadget.variant.dir(&#39;simple_model&#39;) gd ## [1] &quot;simple_model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; You will notice that gd is just a simple string with the location of the model, which in this case is a folder named simple_model within the current working directory, and an attribute to that string called mainfile. The main file is, as illustrated below, the root of the Gadget input file structure, specifiying all the paths to the definition of the ecosystem that is being simulated, such as the stocks and time period. By invoking the gadget.variant.dir command a new folder for the model is created and subsequent edits to the gd object will update the main file as necessary. We will now go through each of these different file types and show you how to generate them. Note that the grayed files in the illustration above will be covered at a later stage. 4.3.1 Time file Gadget is structured as a forward simulator, so in order for it to run we will first need to define the time period (‘year’), and number of subannual time steps (‘step’), for the projection. We do so by creating a data frame setting up the schedule for the simulation: schedule &lt;- expand.grid(year = 1:10, step = 1:4) %&gt;% arrange(year) and create a new time file using gadgetfile by explicitly setting the file type as ‘time’: ## think about writing a special function for this using the schedule data.frame gadgetfile(&#39;Modelfiles/time&#39;, file_type = &#39;time&#39;, components = list(list(firstyear = min(schedule$year), firststep=1, lastyear=max(schedule$year), laststep=4, notimesteps=c(4,3,3,3,3)))) %&gt;% ## number of time steps and step length in months write.gadget.file(gd) Note that arbitrary years and timesteps can be defined for the model, as appropriate for the data and the species simulated. One can for instance start the simulation in 1981 to 2019, with four timesteps with a timestep length of 1,2,4 and 5 months. Typically, though, Gadget models tend to be set up in a set number of year with quarterly timesteps. 4.3.2 Area file Since Gadget allows for simulations in multiple areas these need to be explicitly defined. Various processes, such as fleet operations and migrations, in the model can then be explicitly defined by area. As for the time file the areas are defined in the area file which you can create using gadgetfile: gadgetfile(&#39;Modelfiles/area&#39;, file_type = &#39;area&#39;, components = list(list(areas = 1, size = 1, temperature = schedule %&gt;% mutate(area = 1, temperature = 5)))) %&gt;% write.gadget.file(gd) which will generate a file starting with: ## ; Generated by Rgadget 0.5 ## areas 1 ## size 1 ## temperature ## ; year step area temperature ## 1 1 1 5 ## 1 2 1 5 ## 1 3 1 5 ## 1 4 1 5 ## 2 1 1 5 The areas are defined with attributes, size of the area and average temperature for each time step. Note although these attributes are rarely used in practice they will need to be defined for all areas and, in the case of temperatrue, time steps in order for the simulation to run. 4.3.3 Stockfiles Rgadget has a number of convenience functions when dealing with more complicated files. These functions are all derivatives of gadgetfile and thus can be written to file using write.gadget.file. Here we will start off by creating a skeleton stock file using the gadgetstock function: stock &lt;- gadgetstock(&#39;simple_stock&#39;,gd,missingOkay = TRUE) stock ## ; Generated by Rgadget 0.5 ## stockname simple_stock ## livesonareas ## minage ## maxage ## minlength ## maxlength ## dl ## refweightfile ## growthandeatlengths ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #simple_stock.Linf (* 0.001 #simple_stock.k) #simple_stock.walpha #simple_stock.wbeta ## beta (* 10 #simple_stock.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 This will define a stock named “simple_stock” within the “simple_model” ecosystem. This stock file is however not a complete file so we will need to edit the stock object by adding the necessary attributes. This is done using gadget_update which, as the name suggests, allows to you to update individual components of the file. The first argument to gadget_update after the stock file is the name of the component you want update followed by the variables within the component you want to update. So let’s start by setting mininum and maximum age and other similar attributes in the stock component: stock %&gt;% gadget_update(&#39;stock&#39;, livesonareas = 1, maxage = 1, minage = 1, minlength = 0, maxlength = 2, dl = 1) ## ; Generated by Rgadget 0.5 ## stockname simple_stock ## livesonareas 1 ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## refweightfile ## growthandeatlengths Aggfiles/simple_stock.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #simple_stock.Linf (* 0.001 #simple_stock.k) #simple_stock.walpha #simple_stock.wbeta ## beta (* 10 #simple_stock.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #simple_stock.M ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 As gadget_update was designed to allow the user to edit the Gadget file using a piping mechanism, a la tidyverse, we can of course do multiple edits using gadget_update in one go: stock &lt;- stock %&gt;% gadget_update(&#39;stock&#39;, livesonareas = 1, maxage = 1, minage = 1, minlength = 0, maxlength = 2, dl = 1) %&gt;% gadget_update(&#39;doesgrow&#39;,0) %&gt;% gadget_update(&#39;naturalmortality&#39;,0) %&gt;% gadget_update(&#39;refweight&#39;,data=tibble(length=0:2,mean=0:2)) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 1, area = 1, age.factor = 1, area.factor =1, mean = 1, stddev = .1, alpha = 1, beta = 1)) stock %&gt;% write.gadget.file(gd) stock ## ; Generated by Rgadget 0.5 ## stockname simple_stock ## livesonareas 1 ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## refweightfile Modelfiles/simple_stock.refwgt ## growthandeatlengths Aggfiles/simple_stock.stock.len.agg ## doesgrow 0 ## naturalmortality 0 ## iseaten 0 ## doeseat 0 ## initialconditions ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## normalparamfile Modelfiles/simple_stock.init.normalparam ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 There is a lot to digest from the code above so it is worth stopping and taking a look at each element: The first call to gadget_update edited the attributes of the “stock” part of the file as discussed above. The second call to “doesgrow” turned off all growth processes in the model for this stock by setting doesgrow to 0. (Note that we will discuss growth models in later chapters). Natural mortality was set 0, meaning that fish in the model will not die of natural causes. The weight of the fish was defined. The initial number of fish and their size range at age was defined via “initalconditions”. The initial number of fish is determined in multiples of 10 000 fish, so to derive the number of fish at a certain age and in a specific area you need to multiply the area.factor with the age.factor. With in the same cell you can r ead the mean length and standard deviation from the mean and stddev columns, and the paramters of the weight–length relationship (\\(w = \\alpha l^\\beta\\)) can be read from the alpha and beta columns. Note that gadget_update updates the stock file based on their implicit components, which are the following: Component Description stock Basic information (age, length, dl, area) doesgrow The growth model, see this naturalmortality An entry for each age group iseaten If defined then the stock is considered to be a prey, 0 otherwise doeseat If defined the stock is a predator and prey selection needs to be defined, see this doesmigrate doesmature doesmove doesrenew doesspawn doesstray The stock file essentially defines a stock with 10 000 fish that do not grow, consume or die for the duration of the simulation. By writing this file to the disk R has behind the scenes created a folder named simple_model with all the necessary files: fs::dir_ls(gd) ## [01;34msimple_model/Aggfiles[0m [01;34msimple_model/Modelfiles[0m simple_model/main ## simple_model/simple_stock 4.4 Starting a simulation To test if this is working we can run a single simulation first to check for any errors or warning in our setup. gadget_evaluate(gd,log = &#39;simple_log&#39;) ## [1] &quot;simple_model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; This gives you a warning that no understocking likelihood is available. The understocking likelihood is a penalty function used to prevent negative consumption, i.e. more fish being eaten and/or fished than is available. We can safely ignore this warning for the time being. If you get additional errors, ending with ...running command &#39;gadget -s -main main -log simple_log &#39; had status 1 your Gadget run did not work. At this stage in the tutorial, it is likely becuase you have previously run later code from the next section, which has provided additional old files to your Gadget model directory (see above) that do not match the specifications above. This can be easily fixed by deleting the ‘simple_log’ directory and then rerunning the code on this page from the point of defining gd. After running Gadget we see that two new files have been added to the directory, the parameter file (params.out) and the log file (simple_log). We will discuss the parameter file in more detail in the following sections but for now lets look at the log file: If and when you have errors, such as the ‘…status 1’ error above, the log file is the best place to start trying to figure out why the error occurs. read_lines(paste(gd,&#39;simple_log&#39;,sep=&#39;/&#39;))[-(58:175)] ## [1] &quot;Gadget version 2.3.5 running on fv-az76-763 Tue Nov 17 16:59:13 2020&quot; ## [2] &quot;Log file to record Gadget actions that take place during this run&quot; ## [3] &quot;&quot; ## [4] &quot;Starting Gadget from directory: /home/runner/work/gadget-course/gadget-course/simple_model&quot; ## [5] &quot;using data from directory: /home/runner/work/gadget-course/gadget-course/simple_model&quot; ## [6] &quot;&quot; ## [7] &quot;Checking to see if file params.out can be opened ... OK&quot; ## [8] &quot;&quot; ## [9] &quot;Checking to see if file main can be opened ... OK&quot; ## [10] &quot;Opening file main&quot; ## [11] &quot;Checking to see if file Modelfiles/time can be opened ... OK&quot; ## [12] &quot;Opening file Modelfiles/time&quot; ## [13] &quot;Read time file - number of timesteps 40&quot; ## [14] &quot;Closing file Modelfiles/time&quot; ## [15] &quot;Checking to see if file Modelfiles/area can be opened ... OK&quot; ## [16] &quot;Opening file Modelfiles/area&quot; ## [17] &quot;Read temperature data - number of entries 40&quot; ## [18] &quot;Read area file - number of areas 1&quot; ## [19] &quot;Closing file Modelfiles/area&quot; ## [20] &quot;Checking to see if file simple_stock can be opened ... OK&quot; ## [21] &quot;Opening file simple_stock&quot; ## [22] &quot;Checking to see if file Aggfiles/simple_stock.stock.len.agg can be opened ... OK&quot; ## [23] &quot;Opening file Aggfiles/simple_stock.stock.len.agg&quot; ## [24] &quot;Read length aggregation file - number of entries 2&quot; ## [25] &quot;Closing file Aggfiles/simple_stock.stock.len.agg&quot; ## [26] &quot;Read basic stock data for stock simple_stock&quot; ## [27] &quot;Read growth data for stock simple_stock&quot; ## [28] &quot;Read natural mortality data for stock simple_stock&quot; ## [29] &quot;Read prey data for stock simple_stock&quot; ## [30] &quot;Read predator data for stock simple_stock&quot; ## [31] &quot;Checking to see if file Modelfiles/simple_stock.init.normalparam can be opened ... OK&quot; ## [32] &quot;Opening file Modelfiles/simple_stock.init.normalparam&quot; ## [33] &quot;Read initial conditions data file - number of entries 1&quot; ## [34] &quot;Closing file Modelfiles/simple_stock.init.normalparam&quot; ## [35] &quot;Read initial conditions data for stock simple_stock&quot; ## [36] &quot;Read migration data for stock simple_stock&quot; ## [37] &quot;Read maturity data for stock simple_stock&quot; ## [38] &quot;Read transition data for stock simple_stock&quot; ## [39] &quot;Read renewal data for stock simple_stock&quot; ## [40] &quot;Read spawning data for stock simple_stock&quot; ## [41] &quot;Read straying data for stock simple_stock&quot; ## [42] &quot;Read stock OK - created stock simple_stock&quot; ## [43] &quot;Closing file simple_stock&quot; ## [44] &quot;Closing file main&quot; ## [45] &quot;&quot; ## [46] &quot;Finished reading model data files, starting to run simulation&quot; ## [47] &quot;&quot; ## [48] &quot;&quot; ## [49] &quot;Initialising stock simple_stock&quot; ## [50] &quot;Calculated initial condition data for stock simple_stock&quot; ## [51] &quot;Warning in input files - no understocking likelihood component found&quot; ## [52] &quot;&quot; ## [53] &quot;&quot; ## [54] &quot;Reset time in the simulation to timestep 1&quot; ## [55] &quot;Reset natural mortality data for stock simple_stock&quot; ## [56] &quot;Calculated initial condition data for stock simple_stock&quot; ## [57] &quot;Reset stock data for stock simple_stock&quot; ## [58] &quot;The simulation has reached the last timestep for the current model run&quot; ## [59] &quot;&quot; ## [60] &quot;The current likelihood scores for each component are:&quot; ## [61] &quot;&quot; ## [62] &quot;The current overall likelihood score is 0&quot; ## [63] &quot;&quot; ## [64] &quot;Checking to see if file params.out can be opened ... OK&quot; ## [65] &quot;Opening file params.out&quot; ## [66] &quot;Closing file params.out&quot; ## [67] &quot;&quot; ## [68] &quot;Total number of warnings was 1&quot; ## [69] &quot;&quot; ## [70] &quot;Gadget simulation finished OK - runtime was 0 seconds&quot; We can now gather the output from the model using gadget.fit: fit &lt;- gadget.fit(wgts = NULL,gd = gd) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; plot(fit,data=&#39;res.by.year&#39;,type = &#39;num.total&#39;) and the fit object contains a number of useful datasets that can be used for further analysis: names(fit) ## [1] &quot;sidat&quot; &quot;resTable&quot; &quot;nesTable&quot; ## [4] &quot;suitability&quot; &quot;stock.recruitment&quot; &quot;res.by.year&quot; ## [7] &quot;stomachcontent&quot; &quot;likelihoodsummary&quot; &quot;catchdist.fleets&quot; ## [10] &quot;stockdist&quot; &quot;SS&quot; &quot;stock.full&quot; ## [13] &quot;stock.std&quot; &quot;stock.prey&quot; &quot;fleet.info&quot; ## [16] &quot;predator.prey&quot; &quot;params&quot; &quot;catchstatistics&quot; 4.5 Gadget variables It can be tedious to change all the input files whenever you want to try a different value for a certain input parameter. For example if you want to specify natural mortality as some thing else than 0 you can always do: gadgetstock(&#39;simple_stock&#39;,gd) %&gt;% gadget_update(&#39;naturalmortality&#39;,0.2) ## ; Generated by Rgadget 0.5 ## stockname simple_stock ## livesonareas 1 ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## refweightfile Modelfiles/simple_stock.refwgt ## growthandeatlengths Aggfiles/simple_stock.stock.len.agg ## doesgrow 0 ## naturalmortality 0.2 ## iseaten 0 ## doeseat 0 ## initialconditions ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## normalparamfile Modelfiles/simple_stock.init.normalparam ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 And if you want to try many version of natural mortality you can obviously repeat this process for different values of M. There is however a more convenient approach to do this, namely Gadget switches or parameters. A Gadget parameter can be inserted instead of any number in the input file (apart from likelihood data), and are marked with the # character. So for the case of natural mortality we can now update the stock file to include a Gadget parameter by: gadgetstock(&#39;simple_stock&#39;,gd) %&gt;% gadget_update(&#39;naturalmortality&#39;,&quot;#M&quot;) ## ; Generated by Rgadget 0.5 ## stockname simple_stock ## livesonareas 1 ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## refweightfile Modelfiles/simple_stock.refwgt ## growthandeatlengths Aggfiles/simple_stock.stock.len.agg ## doesgrow 0 ## naturalmortality #M ## iseaten 0 ## doeseat 0 ## initialconditions ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 2 ## dl 1 ## normalparamfile Modelfiles/simple_stock.init.normalparam ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 And now we see that the value for natural mortality has been changed from 0 to #M. Now write this to file and rerun run Gadget. ## [1] &quot;simple_model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; After running this, assuming we did everything correctly, we should see that the file in the directory called params.out is no longer empty: ## ; Gadget version 2.3.5 running on fv-az76-763 Tue Nov 17 16:59:14 2020 ## ; a simulation run was performed giving a likelihood value of 0 ## ; -- data -- ## switch value lower upper optimise ## M 1 -9999 9999 0 This file is generated by Gadget based on the switches it encounters when reading in the input files. It lists all parameters, their value as used in the simulation, upper and lower bounds and whether the parameter should optimised (more on that later). You then simply just change the value for M and rerun Gadget by supplying the parameter file as input. This can either be done by manually editing the parameter file or using the init_guess function: read.gadget.parameters(&#39;simple_model/params.out&#39;) %&gt;% init_guess(&#39;M&#39;,value = 0.2) %&gt;% write.gadget.parameters(file = &#39;simple_model/params.in&#39;) gadget_evaluate(params.in = &#39;params.in&#39;) ## [1] &quot;.&quot; Note that when supplying a parameter input you use the i argument in callGadget. Gadget parameters have a few more tricks up their sleeves. Notably you can apply functions or formulas to the parameter. For instance if you want multiply the value of M by 0.1 you can write that as: (* 0.1 #M) Note that functions and formulas are contained within round brackets, so that this structure equates to 0.1*M. Similarly if you need to log transform your variable as log(M), you can use: (log #M) and these can be chained together: (log (* 0.1 #M)) equates to log(0.1*M). This allows you to apply fairly elaborate functions to the parameter. And as in the case of variables formulas can then be inserted instead of numbers. These formulas can be fairly complex and Rgadget provides mechanisms to manipulate Gadget formulae, both allowing you to evaluate the formula using parse.gadget.formula and transform a R statement with to.gadget.formulae: ## R expression to Gadget formula to.gadget.formulae(quote((1+exp(a*b)))) ## [1] &quot;(+ 1 (exp (* #a #b)))&quot; ## Gadget formula to a R expression parse.gadget.formulae(&#39;(* #a #b)&#39;) ## a * b ## evaluate expression parse.gadget.formulae(&#39;(* #a #b)&#39;) %&gt;% eval(list(a=7,b=6)) ## [1] 42 For instance if you want the mean length at age, in for instance the initial conditions, to be based on the Von Bertanlanfy growth function: \\[l_a = L_\\infty(1 - e^{-k(a - a_0)}) \\] you can do that for age 3 as an example using the to.gadget.formulae in the following manner: to.gadget.formulae(quote(linf*(1-exp(-1*k(3-a0))))) ## [1] &quot;(* #linf (- 1 (exp (* (- 1) (k (- 3 #a0))))))&quot; 4.5.0.1 Exercise Change the initial conditions in such a way you can control both the initial number of fish and the natural mortality using the parameter file. What happens to your stock when you change these values? stock %&gt;% gadget_update(&#39;naturalmortality&#39;,&#39;#M&#39;) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 1, area = 1, age.factor = &#39;#init.num&#39;, area.factor =1, mean = 1, stddev = .1, alpha = 1, beta = 1)) %&gt;% write.gadget.file(gd) gadget_evaluate(params.in = &#39;params.in&#39;,log = &#39;test&#39;) read.gadget.parameters(&#39;simple_model/params.out&#39;) %&gt;% init_guess(&#39;M&#39;,value = 0.2) %&gt;% init_guess(&#39;init.num&#39;, value = 3) %&gt;% write.gadget.parameters(file = &#39;simple_model/params.in&#39;) read.gadget.parameters(&#39;simple_model/params.out&#39;) %&gt;% init_guess(&#39;M&#39;,value = 0.6) %&gt;% init_guess(&#39;init.num&#39;, value = 10) %&gt;% write.gadget.parameters(file = &#39;simple_model/params.in2&#39;) fit &lt;- gadget.fit(wgts = NULL, ## make sure that this is relative to ## gadget directory params.file = &#39;params.in&#39;, gd = gd) fit2 &lt;- gadget.fit(wgts = NULL, ## make sure that this is relative to ## gadget directory params.file = &#39;params.in2&#39;, gd = gd) Play around with the Gadget formulae functions, e.g. parse and evaluate the following formula at \\(\\alpha = 0.1\\) and \\(l_{50} = 75\\) : (/ 1 (+ 1 (exp (* (* -1 #alpha) (- 50 #l50))))) parse.gadget.formulae(&#39;(/ 1 (+ 1 (exp (* (* -1 #alpha) (- 50 #l50)))))&#39;) %&gt;% eval(list(alpha = 0.1, l50 = 75)) 4.6 Predation As Gadget is a length-based simulation model, almost all processes are modelled in terms of length of an individual in a particular stock. The rationale for this is that natural processes are better explained in terms of size, e.g. prey must fit into the mouth of the predator. Thus predation and fleet selection are modelled in terms of size. These selection processes can very between predators (and fleets) and therefore Gadget allows the user to define this relationship in a number of ways. In Gadget there are a number of predator-prey relations that can be defined. They include the obvious case where one stock consumes another other. Additionally a cannibalistic relationship can be defined if substocks are modelled as, for example, an immature and a mature substock of the same species. Fleets (survey and/or commercial) are integrated into the model by being considered one of the predators. A fleet can harvest one or both substocks in some or all areas. These relationship are essentially factored into three components: The amount which the predator wants to consume The size range the predator is able to consume The size range of the prey which is available for consumption The availability of a certain prey \\(p\\) and the ability for predator \\(P\\) to consume \\(p\\) is linked by a length-based suitability function \\(S_{P,p}(L,l)\\) of one of the following forms: Function name Formula constant \\(S_{Pp}(L,l) = \\alpha\\) straightline \\(S_{Pp}(L,l) = \\alpha + \\beta l\\) exponential \\(S_{Pp}(L,l) = \\frac{\\delta}{1+e^{(-\\alpha-\\beta l - \\gamma L)}}\\) exponentiall50 \\(S_{Pp}(L,l) = \\frac{1}{1 + e^{-\\alpha(l-l_{50})}}\\) richards \\(S_{Pp}(L,l) = \\left(\\frac{\\delta}{1+e^{(-\\alpha-\\beta l - \\gamma L)}}\\right)^\\eta\\) andersen \\(S_{Pp}(L,l) = \\begin{cases} \\alpha + \\gamma e^{-\\frac{(ln(L/l)-\\beta)^2}{\\delta}}, &amp; \\text{if}\\ a=ln(L/l) &lt; \\beta \\\\\\alpha + \\gamma e^{-\\frac{(ln(L/l)-\\beta)^2}{\\eta}}, &amp; \\text{if}\\ a=ln(L/l) &gt; \\beta \\end{cases}\\) andersenfleet Same as above except \\(L\\) is a parameter gamma \\(S_{Pp}(L,l) = \\bigg(\\frac{1}{(\\alpha -1)\\beta\\gamma)}\\bigg)^{(\\alpha -1)}e^{(\\alpha -1 -\\frac{1}{\\beta\\gamma})}\\) where \\(L\\) and \\(l\\) are the predator and prey lengths respectively. Note that when defining fleets, their lengths are not well defined and in the case of the Andersen suitability function you should use the fleet variant of that function. Note that \\(S_{Pp}\\) is in most cases between 0 and 1. \\(S_{P,p}(L,l)\\) should therefore be interpreted as the percentage of prey abundance at length \\(l\\) available to predator \\(P\\) at length \\(L\\). To help you to choose the appropriate suitability function within Gadget, Rgadget has a helper function, suitability, to help the user to investigate how a particular suitability function behaves, which allows the user to input the function name, parameters and the length of the predators and prey. Below is an example of how to calculate and visualise the exponential suitability function for different sizes of the predator and prey. prey.length &lt;- 1:50 pred.length &lt;- seq(40,100,by=10) param &lt;- c(alpha = -20, beta = 0.5,gamma = 0.1, delta = 1) suit &lt;- suitability(params = param, l = prey.length, L = pred.length, type = &#39;exponential&#39;, to.data.frame = TRUE) ggplot(suit,aes(l,suit,col=as.factor(L))) + geom_line() In Gadget you can define whether a stock is available for consumption, i.e indicate that the stock is a prey, or is a predator (or both) by setting the doeseat and iseaten options in the stock file. You can make the stock available for consumption using the following gadget_update call: gadgetstock(&#39;simple_stock&#39;,gd) %&gt;% gadget_update(&quot;iseaten&quot;,1) %&gt;% write.gadget.file(gd) It is a little more complicated to define the predation parameters so it will be covered at a later stage, when predator-prey interactions are discussed. 4.7 Fleet operations Human interactions in Gadget are often modelled as removals of a particular stock. These removals are defined via a simplified stock object called Fleet, which inherits a less complex predator behaviour than can be defined in a gadget stock (more on that later). The fleet operations are defined as a separate model component/file detailing the main attributes of the fleets. The defintion of a fleet is as follows: Fleet type which can be one of 5 types, TotalFleet,NumberFleet,LinearFleet,EffortFleet and QuotaFleet. Fleet name name of the fleet Suitability how the fleet selection is defined Catch data a table of catch/effort by time step Although the there are five different fleet types they can essentially be grouped into two classes of how the user can define the removals. These are the Total fleets where the total biomass or total number of removals are specified by the user and the Effort fleets that specify the removals in terms of harvest rate on available biomass/abundance. Note that in the Gadget manual and here, harvest rate and effort are used interchangeably, although they are generally not same. The user defines when these removals occur by specifying the year and time steps catch/effort take place (see the fleet files section of the Gadget User Guide for further details). We will begin by looking at the effort type fleets. Their catch, \\(C_{plyt}\\), of prey \\(p\\) at length \\(l\\), year \\(y\\) and timestep \\(t\\) is determined by the following equation: \\[ C_{plyt} = E_{yt}\\Delta t S_{pl}N_{plyt}W_{plyt} \\] where the \\(E\\) denotes the harvest rate of the fleet, \\(S\\) the suitability, \\(N\\) the abundance and \\(W\\) the mean weight for prey \\(p\\) at length \\(l\\). \\(\\Delta t\\) is then the length of the timestep, e.g. 0.25 for a quarter. When defining the harvest rate the user needs to create a table of rates per timestep in a particular format. So for example if the user want set this effort to 1 for all years at step 2 the following code can be used: harvest.rate &lt;- structure(data.frame(year=unique(schedule$year),step=2,area=1,number=1), area_group = list(`1` = 1)) Note that the harvest.rate object is simply a data frame with an associated area attribute (area_group) translating the areas in the data frame to a model area. Adding these attributes using structure may seem a bit of a overkill for this particular data set, but as we will see later on this becomes more useful when handling more diverse data structures. Warning: using the dplyr mutate function removes these attributes. The fleet is then defined is a similar manner as for stocks, you can read/define a fleet with the gadgetfleet command. There is however a minor difference: multiple fleets can be defined in a single file. The fleet files can then be edited using the gadget_update function. So as in the case of creating a stock we will begin by creating an empty stock: gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) where the missingOkay switch means that the function should create a new file if missing. The gadget_update is then supplied with one of the fleet type listed above, which in this case will be the LinearFleet fleet type: gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;linearfleet&#39;, name = &#39;simple_fleet&#39;, suitability = list(simple_stock=list(type=&#39;function&#39;,suit_func = &#39;constant&#39;,value=0.2)), data = harvest.rate) %&gt;% write.gadget.file(gd) The suitabilty of each prey for removal by the fleet is defined as a list of all stocks caught by the fleet with a suitability function assigned to each of them, allowing for wholly different prey selection between the various stocks. In this case the constant selection function is used, where 20\\(\\%\\) of the whole stock at all sizes is available to the fleet. To see the effects of the fleet operations on our stock we can use the gadget.fit function: fit &lt;- gadget.fit(wgts = NULL, gd = gd, params.file = &#39;params.in&#39;) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; plot(fit,data = &#39;res.by.year&#39;,type=&#39;num.total&#39;) + expand_limits(y=0) plot(fit,data = &#39;res.by.year&#39;,type=&#39;num.catch&#39;) + expand_limits(y=0) This formulation of the fleet assumes that a fixed harvest rate is applied for all years. This is probably not representative of reality, so Gadget allows the user do define varying rates by year. To do that you simply edit the harvest rate data frame above and update the fleet file accordingly: harvest.rate &lt;- structure(data.frame(year=unique(schedule$year),step=2,area=1, ## HR are now random variations around 1 number= exp(rnorm(length(unique(schedule$year))))), area_group = list(`1` = 1)) ## update the fleet file gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;linearfleet&#39;, name = &#39;simple_fleet&#39;, suitability = list(simple_stock=list(type=&#39;function&#39;,suit_func = &#39;constant&#39;,value=0.2)), data = harvest.rate) %&gt;% write.gadget.file(gd) ## And re-run fit &lt;- gadget.fit(wgts = NULL, gd = gd, params.file = &#39;params.in&#39;) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; plot(fit,data = &#39;res.by.year&#39;,type=&#39;num.total&#39;) + expand_limits(y=0) plot(fit,data = &#39;res.by.year&#39;,type=&#39;num.catch&#39;) + expand_limits(y=0) 4.7.1 Excercise TotalFleet and NumberFleet are defined exactly the same way as the LinearFleet, apart from the interpretation of the data file which now tells Gadget how many fish or how many kilograms are consumed by the fleet. Redo the example above with either of the fleet types, but make sure you do not overconsume (i.e., don’t take more that is available). catch &lt;- structure(data.frame(year=unique(schedule$year),step=2,area=1, number= 500, area_group = list(`1` = 1)) ## update the fleet file gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;numberfleet&#39;, name = &#39;simple_fleet&#39;, suitability = list(simple_stock=list(type=&#39;function&#39;,suit_func = &#39;constant&#39;,value=0.2)), data = catch) %&gt;% write.gadget.file(gd) ## And re-run fit &lt;- gadget.fit(wgts = NULL, gd = gd, params.file = &#39;params.in&#39;) Where do you think it is possible to define model variables in the definition of the fleet file? Change as much as you can so the model can be controlled by the parameter file. catch &lt;- structure(data.frame(year=unique(schedule$year),step=2,area=1, ## put a gadget parameter for each year number= sprintf(&#39;#catch.%s&#39;,unique(schedule$year))), area_group = list(`1` = 1)) 4.8 Recruitment There are two types of recruitment processes in Gadget, those that are the result of spawning and what is called renewal. The difference between the two processes is that the spawning process depends on the size of the spawning stock while the renewal process is independent from other processes in the model. Setting up the spawning process is fairly involved and will be covered in later sections. Today we will focus on the renewal process and how it is defined. Renewals in Gadget allow the user to freely define the number of individuals that are recruited into the stock at any time, area and age. This is done by setting up a schema not unlike the one used for the initial conditions with the addition of the timing of the recuitment. For our simple model we will start by defining a data frame with the recruits: recruits &lt;- tibble(year = 1:10, ## Year of recruitment, step = 1, ## timing of recruitment (q1) area = 1, ## where does the rec. take place age = 1, ## age of recruits number = 1, ## num. of recruits (x10 000) mean = 1, ## mean length stddev = .1, ## std in length alpha = 1, ## a in w = aL^b beta = 1) This table will add 10 000 individuals at age 1 to our simulation every year. To add this to our model we need to update the stock file: gadgetstock(&#39;simple_stock&#39;,gd) %&gt;% gadget_update(&#39;doesrenew&#39;, normalparam = recruits) %&gt;% write.gadget.file(gd) and we can now re-run the model to see the effects of the recruitment to the abundance in the stock: fit &lt;- gadget.fit(wgts = NULL, params.file = &#39;params.in&#39;,gd=gd) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; plot(fit,data = &#39;res.by.year&#39;,type=&#39;num.total&#39;) + expand_limits(y=0) plot(fit,data = &#39;res.by.year&#39;,type=&#39;num.catch&#39;) + expand_limits(y=0) 4.8.1 Exercise For the remainder of the session we are going to play with the simple model we have created. Below are a couple of ideas to play with the model: Try to insert model variables where ever you can. stock %&gt;% gadget_update(&#39;doesrenew&#39;, normalparam = tibble(year = 1:10, ## Year of recruitment, step = 1, ## timing of recruitment (q1) area = 1, ## where does the rec. take place age = 1, ## age of recruits number = sprintf(&#39;#rec.%s&#39;,year), ## num. of recruits (x10 000) mean = &#39;#ml&#39;, ## mean length stddev = &#39;#sdl&#39;, ## std in length alpha = &#39;#alpha&#39;, ## a in w = aL^b beta = &#39;#beta&#39;)) %&gt;% write.gadget.file(gd) Investigate how you can introduce randomness into the model, e.g variability in recruitment and fishing effort. gadget_evaluate(gd) read.gadget.parameters(&#39;simple_model/params.out&#39;) %&gt;% init_guess(&#39;rec.+&#39;,value = 6*rlnorm(10)) %&gt;% init_guess(&#39;catch.+&#39;, value = 3*rlnorm(10)) %&gt;% write.gadget.parameters(&#39;simple_model/params.in&#39;) Change the time horizon, i.e run the model for 50 years, and investigate the effects of different harvest rates on the biomass levels. For those feeling adventurous think about how to set up a stochastic simulation to estimate the maximum sustainable yield. "],["defining-stock-interations.html", "5 Defining stock interations 5.1 Fish recruits into a stock 5.2 Spawning 5.3 Consumption", " 5 Defining stock interations As we have already seen there are a number of ways we can define interactions between stocks. Here we will, however, explore further the various different mechanisms implemented in Gadget. These interaction can essentially be grouped into two categories: Fish entering stock due to a process in a related stock This can be either movement between stocks or spawning Fish is removed from a stock due to predation We will illustrate these processes using a simple multistock model: gd &lt;- gadget.variant.dir(&#39;simple_multistock_model&#39;) schedule &lt;- expand.grid(year = 1:30, step = 1:4) %&gt;% arrange(year) gadgetfile(&#39;Modelfiles/area&#39;, file_type = &#39;area&#39;, components = list(list(areas = 1, size = 1, temperature = schedule %&gt;% mutate(area = 1, temperature = 5)))) %&gt;% write.gadget.file(gd) gadgetfile(&#39;Modelfiles/time&#39;, file_type = &#39;time&#39;, components = list(list(firstyear = min(schedule$year), firststep=1, lastyear=max(schedule$year), laststep=4, notimesteps=c(4,3,3,3,3)))) %&gt;% ## number of time steps and step length in months write.gadget.file(gd) stock_template &lt;- gadgetstock(&#39;stock_1&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;stock&#39;, livesonareas = 1, maxage = 1, minage = 1, minlength = 0, maxlength = 2, dl = 1) %&gt;% gadget_update(&#39;doesgrow&#39;,0) %&gt;% gadget_update(&#39;naturalmortality&#39;, 0.2) %&gt;% gadget_update(&#39;refweight&#39;,data=tibble(length=0:2,mean=0:2)) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 1, area = 1, age.factor = 0, area.factor =1, mean = 1, stddev = .1, alpha = 1, beta = 1)) %&gt;% gadget_update(&#39;doesrenew&#39;, normalparam = schedule %&gt;% filter(step == 1) %&gt;% mutate(area = 1, ## where does the rec. take place age = 1, ## age of recruits number = 1, ## num. of recruits (x10 000) mean = 1, ## mean length stddev = .1, ## std in length alpha = 1, ## a in w = aL^b beta = 1)) We will use the stock template to define multiple stocks to illustrate the various possible interactions the user is able to define in a Gadget model. 5.1 Fish recruits into a stock We have already seen how to implment the most straitforward version of recruitment into a stock, that is the renewal process. To recap, the renewal process adds fish into a stock based on a predefined schedule on the number and age of fish at a given time step. The most obvious use of this feature is to define a non-parametric recruitment to a stock a the minimum age of the stock. However one can use it also to add migrations from a related to stock, where the dynamics of the related stock is not modelled. An example of this would be the sporadic migrations of cod from Greenlandic waters into Icelandic waters. Movement between stocks can however be defined to more elaborate. We have already seen how maturation can be modelled as a two step approach, that is a combination of Maturation and Movement. Movement is the simplest approach as it simply takes the oldest fish of one stock and pushes it into a another stock, provided that this other stocks age range includes the maximum age of the first stock. young_stock &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;young_stock&#39;) %&gt;% gadget_update(&#39;doesmove&#39;, ## be careful how you spell this transitionstocksandratios = list(stock=&#39;old_stock&#39;,ratio = 1), transitionstep = 4) old_stock &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;old_stock&#39;, minage = 2, maxage = 2) %&gt;% gadget_update(&#39;doesrenew&#39;,0) %&gt;% gadget_update(&#39;naturalmortality&#39;, 0.2) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 2, area = 1, age.factor = 0, area.factor =1, mean = 1, stddev = .1, alpha = 1, beta = 1)) young_stock %&gt;% write.gadget.file(gd) old_stock %&gt;% write.gadget.file(gd) fit &lt;- gadget.fit(wgts = NULL,gd=gd,steps = 2) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; ## better color scheme scale_fill_crayola &lt;- function(n = 100, ...) { # taken from RColorBrewer::brewer.pal(12, &quot;Paired&quot;) pal &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) pal &lt;- rep(pal, n) ggplot2::scale_fill_manual(values = pal, ...) } plot(fit,data=&#39;res.by.year&#39;,type=&#39;num.total&#39;) plot(fit,data=&#39;stock.std&#39;) + scale_fill_crayola() And this process can of course continue further. Two processes allow the user to define movement based on size or age. These are the maturation process and the straying process. These behave in a similar manner but there are key differences, in particular how you can define the movement. In the ling example the maturity process was a continuous process where the probability of a maturing at a certain length or age was determing using the following equation: \\[ p_{la} = \\frac{1}{1+e^{-\\alpha(l - l_{50}) - \\beta(a - a_{50})}} \\] For a stock to mature you need to set doesmature,maturityfunction and maturityfile. The maturityfile defines the maturation function parameters and to which stock(s) the immmature stock matures into. Gadget has three additional functions you can use to define movement from an immmature to a mature stock: constant which is essentially the same as the continous function apart from the definition of the maturitysteps, i.e. when the maturation takes place. constantweight same as above but the probability of maturation is now also a function of the body condition: \\[ p_{la} = \\frac{1}{1+e^{-\\alpha(l - l_{50}) - \\beta(a - a_{50}) - \\gamma(k-k_{50})}} \\] where the body condition, \\(k\\), is determined by dividing the reference weight to the modelled weight fixedlength which is a knife-edge selection in terms of length. You need to define the maturitysteps and maturitylengths. The straying process is slightly different as it is thought of as the means to provide mechanisms to define processes such as dispersal between breeding components and different growth rates within the same stock due to different enviromental factors. To setup the straying process you will need to define when the straying occurs, where it occurs (i.e. what area) and what fish strays. The fish that strays is defined by specific length selection listed below: constant: \\(S_l = \\alpha\\) straightline: \\(S_l = \\alpha l + \\beta\\) exponential: \\(S_l = \\frac{1}{1+e^{\\alpha(l-l_{50})}}\\) For our simple model we will define 20\\(\\%\\) straying between two stock components, from stock_a to stock_b: stock_a &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;stock_a&#39;) %&gt;% gadget_update(&#39;doesstray&#39;, straysteps = 3, strayareas = 1, straystocksandratios = list(stock=&#39;stock_b&#39;,ratio = 1), proportionfunction = list(sel_function=&#39;constant&#39;,alpha = 0.2)) stock_b &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;stock_b&#39;) %&gt;% gadget_update(&#39;doesrenew&#39;,0) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 1, area = 1, age.factor = .1, area.factor =1, mean = 1, stddev = .1, alpha = 1, beta = 1)) stock_a %&gt;% write.gadget.file(gd) stock_b %&gt;% write.gadget.file(gd) fit &lt;- gadget.fit(wgts = NULL,gd=gd,steps = 2) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; fit$res.by.year %&gt;% filter(stock %in% c(&#39;stock_a&#39;,&#39;stock_b&#39;)) %&gt;% ggplot(aes(year,total.number,lty = stock)) + geom_line() 5.1.1 Excercise Depletion of stock components is often a concern. Using the straying mechanism set up a three stock model where individual are slowly dispersed between all three components. Define a fishing fleet that targets only one of the stocks and investigate how different dispersion levels affect the depletion of all stocks. Gadget allow you to set up a catch at age model. Use the movement mechanism to define a model with a maximum age of 10, where each age is a separate stock. How would you define the fleets for this model so you could use commercial catch at age directly into the model? 5.2 Spawning The spawning process allows the user to define recruits into as stock as function of the size of another stock. A number of relationships can be defined: fecundity \\[R = p_0 \\sum_a\\sum_l l^{p_1}a^{p_2}N_{al}^{p_3}W_{al}^{p_4}\\] simplessb \\[R = \\mu S\\] where \\(S = \\sum_a\\sum_l N_{al}W_{al}\\) ricker \\[R = \\mu Se^{-\\lambda S}\\] bevertonholt \\[R = \\frac{\\mu S}{\\lambda + S}\\] hockeystick \\[R = R = \\begin{cases} R_0,&amp;\\text{If } B_{lim} \\leq S \\\\ \\frac{R_0S}{B_{lim}} &amp; \\text{If } 0 \\leq S \\leq B_{lim} \\end{cases} \\] In addition the user can define using the same length based selection function as for straying which of the stock “spawns” and what happens to them, i.e. what mortalities are applied to the stock and changes in condition. The spawning stock is updated according to the following equations: \\[ N_l = N_l(1 + P_l(e^{-m_l} - 1)) \\] \\[ W_l = W_l\\frac{1 + P_l((2-w_l)e^{-m_l} -1)}{(1 + P_l(2e^{-m_l} -1))} \\] where \\(P_l\\) is proportion that will spawn, \\(m_l\\) is the mortality for and \\(w_l\\) is the weight loss for length group \\(l\\). To illustrate how to set up spawning for a particular stock we will use the simple stock templates from above and use those to define parent and offspring stocks: parent &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;parent&#39;) %&gt;% gadget_update(&#39;doesrenew&#39;,0) %&gt;% gadget_update(&#39;doesspawn&#39;, spawnsteps = 1, spawnareas = 1, firstspawnyear = 1, lastspawnyear = 30, spawnstocksandratios = list(stock=&#39;offspring&#39;, ratio = 1), proportionfunction = list(sel_func = &#39;constant&#39;, alpha = 1), mortalityfunction = list(sel_func = &#39;constant&#39;, alpha = 0), weightlossfunction = list(sel_func = &#39;constant&#39;, alpha = 0), recruitment = list(spawn_function = &#39;ricker&#39;, mu = 2, lambda = 1e-4), stockparameters = list(mean = 1, stddev = .1, alpha = 1, beta = 1)) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 1, area = 1, age.factor = 1, area.factor = .1, mean = 1, stddev = .1, alpha = 1, beta = 1)) offspring &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;offspring&#39;, minage = 0, maxage = 0) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 0, area = 1, age.factor = 0, area.factor = 0, mean = 1, stddev = .1, alpha = 1, beta = 1)) %&gt;% gadget_update(&#39;doesrenew&#39;,0) %&gt;% gadget_update(&#39;doesmove&#39;, transitionsteps = 4, transitionstocksandratios = list(stock=&#39;parent&#39;,ratio=1)) parent %&gt;% write.gadget.file(gd) offspring %&gt;% write.gadget.file(gd) fit &lt;- gadget.fit(wgts = NULL, gd = gd, steps = 2) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; fit$res.by.year %&gt;% filter(stock %in% c(&#39;parent&#39;,&#39;offspring&#39;)) %&gt;% ggplot(aes(year,total.number,lty = stock)) + geom_line() + expand_limits(y=0) The code above defines a Ricker recruitment function between the parent and offspring stocks. As evident from the graph above the relationship between the two stocks is a fairly deterministic. This type of relationship, however, is hardly ever observed without error (both in process and observation). To include process variation into the model Gadget has another trick up its sleave, Time variables. 5.2.1 Time variables Time variables allow Gadget to change the value of parameters with time. They are an extension to the Gadget formulae functionality and can be use (almost) where ever you can use Gadget formulae. To define a time variable you will need to define a data frame with the start time for a particular value, which will be valid until the next change. Example uses might be shifts fleet selection due to changes in regulation and temperature effects in growth. In the case of the simple stock recruitment relationship above we may want change the value for \\(\\mu\\) with time. To introduce time variables into this model you will need to create a special file: mu_time &lt;- gadgetfile(&#39;Modelfiles/mu_time&#39;, file_type = &#39;timevariable&#39;, components = list(list(&#39;mu_time&#39;, data = schedule %&gt;% filter(step == 1) %&gt;% mutate(value = 2*rlnorm(n = 30, sdlog = 0.2))))) mu_time %&gt;% write.gadget.file(gd) mu_time ## ; Generated by Rgadget 0.5 ## mu_time ## data ## ; year step value ## 1 1 2.13615794277241 ## 2 1 1.98661364728197 ## 3 1 2.73698869826468 ## 4 1 1.86893808461558 ## 5 1 2.10111001818921 ## 6 1 2.00961616938739 ## 7 1 2.03274248653886 ## 8 1 1.97134753443569 ## 9 1 2.05633195999244 ## 10 1 1.99546559648948 ## 11 1 1.93308105872179 ## 12 1 2.19021504490595 ## 13 1 1.55642887773901 ## 14 1 1.78438226896451 ## 15 1 2.56835025590086 ## 16 1 1.80544888510365 ## 17 1 2.1713826320093 ## 18 1 2.89465778957073 ## 19 1 2.42684238351758 ## 20 1 2.16303320455432 ## 21 1 1.7004232153173 ## 22 1 2.03378611387857 ## 23 1 2.0357189475761 ## 24 1 2.74053147196963 ## 25 1 2.06683884876955 ## 26 1 2.32809477299807 ## 27 1 1.97891345106346 ## 28 1 1.85668495947396 ## 29 1 2.38881893290369 ## 30 1 1.66528100782491 and then we need to replace value for \\(\\mu\\) with this file: parent &lt;- parent %&gt;% gadget_update(&#39;doesspawn&#39;, spawnsteps = 1, spawnareas = 1, firstspawnyear = 1, lastspawnyear = 30, spawnstocksandratios = list(stock=&#39;offspring&#39;, ratio = 1), proportionfunction = list(sel_func = &#39;constant&#39;, alpha = 1), mortalityfunction = list(sel_func = &#39;constant&#39;, alpha = 0), weightlossfunction = list(sel_func = &#39;constant&#39;, alpha = 0), recruitment = list(spawn_function = &#39;ricker&#39;, mu = &quot;Modelfiles/mu_time&quot;, lambda = 1e-4), stockparameters = list(mean = 1, stddev = .1, alpha = 1, beta = 1)) parent %&gt;% write.gadget.file(gd) fit &lt;- gadget.fit(wgts = NULL, gd = gd, steps = 2) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; fit$res.by.year %&gt;% filter(stock %in% c(&#39;parent&#39;,&#39;offspring&#39;)) %&gt;% ggplot(aes(year,total.number,lty = stock)) + geom_line() + expand_limits(y=0) 5.2.2 Excercise Modify the code above such that the spawning is split into two stocks, representing e.g. either the male or female part of the stock. Using the simple stock template define a auto-spawning stock, i.e. a stock that spawns into it self. Instead of the Ricker function try to parametrise the Beverton and Holt recruitment function for the example above. In the ling example consider how you would project the recruitment into the future. 5.3 Consumption In Gadget there are a number of predator-prey relations that can be defined. They include the obvious case where one substock predates the other. Additionally a cannibalistic relationship can be defined if the substocks are modelled as an immature and a mature part of the same species. The predation in Gadget is implemented as follows. Each predator will conceptually be assigned availability of a certain prey in comparison with other food sources and a feeding level, i.e., fraction of available food the predator wants to consume. Combining these two terms the amount that the predator wants to consume is calculated. The availability of a certain prey \\(p\\) for a predator \\(P\\) is determined by the prey biomass per length group (\\(N_{l}W_{l}\\), where \\(W_l\\) is the weight at length \\(l\\)) and a length based suitability function listed here. In the simple predator-prey relation between the substocks in Gadget the prey availability to a predator becomes \\[\\frac{F_{Ll}}{\\sum_{l&#39;}F_{Ll&#39;}+OA}\\] where \\[F_{Ll} = (S_{Pp}(L,l) N_{pl}W_{pl})^{d_p}\\] is the prey biomass of length \\(l\\) that the predator could consume, \\(W_{pl}\\) is the average weight for prey of length \\(l\\), \\(d_p\\) is the preference, and \\(O\\) is the density, per unit area, of other unspecified food sources and \\(A\\) is the size of the area. The feeding level of the predator is \\[\\Psi_L = M_L \\frac{\\sum_{l&#39;}F_{Ll&#39;}+OA}{\\sum_{l&#39;}F_{Ll&#39;}+OA+HA}\\] where \\(M_L\\) is the maximum consumption of a predator of length \\(L\\) for a particular time step length \\(\\Delta t\\). It is determined by \\[M_L=m_0L^{m_4}\\Delta t e^{(m_1 T - m_2 T^3)}\\] where \\(m_0\\) to \\(m_4\\) are user defined constants. \\(H\\) is the density (biomass per area unit) of available food at which the predator can consume half maximum consumption. Note that \\(H\\) should reflect how able the predator is to pursue its prey, which should factor in variables such as temperature and the cost of search. \\(H\\) determines therefore how quickly the predators consumption reaches \\(M_L\\). \\(H=0\\) would indicate that the predator would easily consume \\(M_L\\) of the available biomass. A larger value for \\(H\\) would indicate that prey is harder to find and therefore prey needs to be more abundant for the predator to reach \\(M_L\\). Given the feeding level and the prey availability the desired consumption of all predators of length \\(L\\) is \\[ \\begin{split} C_{L,l}&amp;=N_{L}\\Psi_{L}\\left[\\frac{F_{Ll}}{\\sum_{l&#39;}F_{Ll&#39;}+OA}\\right]\\\\ &amp;=N_{L}M_{L}\\frac{F_{Ll}}{\\sum_{l&#39;}F_{Ll&#39;}+OA+HA}\\\\ \\end{split} \\] For each prey an upper limit needs to be set on the total amount consumed by all predators, including the fleets, to prevent more consumption than the available biomass. To prevent this overconsumption when fitting a Gadget model the understocking likelihood component is usually added to the likelihood. To illustrate how one can set up a predator prey relationship in Gadget we will take the simple case of one stock, predator, predating another, prey. First we will need to set up the prey stock: prey &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;prey&#39;) %&gt;% gadget_update(&#39;iseaten&#39;, ## define how many KJ per gram energycontent = 1) We also have to define something called “Otherfood”. Otherfood refers to other non-dynamic food items that the predator consumes. It is usually defined in order for the stock to consume something else in the absense of the prey. otherfood &lt;- gadgetfile(&#39;Modelfiles/otherfood&#39;, file_type = &#39;otherfood&#39;, components = list(component=list(foodname = &#39;otherfood&#39;, livesonareas = 1, lengths = list(min = 1, max = 2), energycontent = 1, amount = gadgetfile(&#39;Data/otherfood&#39;, component = list(schedule %&gt;% mutate(area = 1, food_name = &#39;otherfood&#39;,amount = 1e6)))))) The predator stock is bit more involved: predator &lt;- stock_template %&gt;% gadget_update(&#39;stock&#39;, stockname = &#39;predator&#39;) %&gt;% gadget_update(&#39;doeseat&#39;, suitability = list(paste(&#39;\\n&#39;,prey = &#39;prey&#39;,type=&#39;function&#39;,suit_func = &#39;constant&#39;, alpha = 1,&#39;\\n&#39;, sep = &#39;\\t&#39;), paste(prey = &#39;otherfood&#39;,type=&#39;function&#39;,suit_func = &#39;constant&#39;, alpha = 0.5, sep = &#39;\\t&#39;)), preference = paste(&#39;\\n&#39;,&#39;prey&#39;,1,&#39;\\n&#39;,&#39;otherfood&#39;, 1), maxconsumption = list(m0=1,m1=0,m2=0,m3=0), halffeedingvalue = 0.2) Now save this all to file and run Gadget: prey %&gt;% write.gadget.file(gd) predator %&gt;% write.gadget.file(gd) otherfood %&gt;% write.gadget.file(gd) fit &lt;- gadget.fit(wgts = NULL, gd = gd, steps = 2) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; fit$res.by.year %&gt;% filter(stock %in% c(&#39;predator&#39;,&#39;prey&#39;)) %&gt;% ggplot(aes(year,total.number,lty = stock)) + geom_line() + expand_limits(y=0) fit$predator.prey %&gt;% group_by(year) %&gt;% summarise(num = sum(number_consumed)) %&gt;% ggplot(aes(year,num)) + geom_line() 5.3.1 Excercise In the example above, insert variable names instead of direct numbers for the selection and predation parameters. Investigate the effects of changing the selection parameter has on the consumption. E.g: Change the otherfood time series such that it is more variable Change the recruitment of both predator and prey Add a new prey "],["building-complex-gadget-models.html", "6 Building complex Gadget models 6.1 Defining growth 6.2 Ling stock assessment in Icelandic waters 6.3 Model initiation 6.4 Run the simulation using pre-determined parameters 6.5 Talking points", " 6 Building complex Gadget models 6.1 Defining growth Let us begin by setting the scene with time and area in the typical fashion: library(tidyverse) library(Rgadget) gd &lt;- gadget.variant.dir(&#39;simple_growth_model&#39;) gd ## [1] &quot;simple_growth_model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; ## lets look at the files in gd #fs::dir_ls(gd) ## nothing has happened ## Time file schedule &lt;- expand.grid(year = 1:10, step = 1:4) %&gt;% arrange(year) gadgetfile(&#39;Modelfiles/time&#39;, file_type = &#39;time&#39;, components = list(list(firstyear = min(schedule$year), firststep=1, lastyear=max(schedule$year), laststep=4, notimesteps=c(4,3,3,3,3)))) %&gt;% ## number of time steps and step length in months write.gadget.file(gd) ## Area file gadgetfile(&#39;Modelfiles/area&#39;, file_type = &#39;area&#39;, components = list(list(areas = 1, size = 1, temperature = schedule %&gt;% mutate(area = 1, temperature = 5)))) %&gt;% write.gadget.file(gd) Now that we have attributes of the time and place, we can insert a population into it. Remember that population subcomponents are called ‘stocks’ in Gadget. To do this, we use the function gadgetstock. However, using gadgetstock also has some default settings built in for convenience. The first one is that it automatically sets up the Gadget model with growth implemented. If we first generate a default stock (with name ‘test’), we find that much of the structural information we supplied above was not supplied, and most of the other settings are turned off (value = 0, more on those settings later). gadgetstock(&#39;test&#39;,gd,missingOkay = TRUE) ## ; Generated by Rgadget 0.5 ## stockname test ## livesonareas ## minage ## maxage ## minlength ## maxlength ## dl ## refweightfile ## growthandeatlengths ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #test.Linf (* 0.001 #test.k) #test.walpha #test.wbeta ## beta (* 10 #test.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 However, growth is the exception: doesgrow is turned on (value set to 1) with the growth function lengthvbsimple implemented and parameters supplied to that function as ‘test.Linf’, ‘test.k’ (multiplied by 0.001 to keep it help the optimisation routine by placing it on a similar scale to other parameters), ‘test.walpha’, ‘test.wbeta’, ‘test.bbin’ (also multiplied by a scalar), and a constant value for maxlengthgroupgrowth. 6.1.1 Growth Growth is implemented using three processes in Gadget. The first process is described by a growth function that shows how mean body size at age changes over time. The second process generates variability around that mean length at age relationship using a beta binomial distribution (currently, no other distributions are implemented). The third process translates between lengths and weights. The first and third processes are implemented together via the chosen growth function. In the default Rgadget lengthvbsimple function implementation, the length at infinity and growth rate parameters supplied to this function are automatically named test.Linf and test.k to signify that these parameters only refer to growth within the ‘test’ stock. Similarly, an exponential relationship is used to represent growth, using the automatically named test.walpha and test.wbeta parameters. Because they are by default supplied here and supplied as switches with ‘#’ preceding them, they will be automatically generated in the parameter file when an initial Gadget simulation is run, and their values can then be controlled from this file (as demonstrated in Day 1 material). Beyond lengthvbsimple, there are a variety of other growth functions that can be implemented, including those that implement starvation, time- and area- dependent growth, or reading weights from a length-weight key. These are described in the Gadget User Guide. The second process is implemented in the default by providing a single switch ‘test.bbin’ parameter to the beta-binomial distribution, along with a constant value for maxlengthgroupgrowth. The beta-binomial distribution is implemented in Gadget because high flexibility in the distribution of growth deviations is provided by changing only a single estimable parameter. The constant value for maxlengthgroupgrowth describes the maximum number of length bins a fish is allowed to grow in a single time step, so it should be set high enough to be realistic. As growth is one of the major determinants of population dynamics, some words of caution should be mentioned in any discussion of the implementation of growth in Gadget. The first is that the implementation of the Von Bertalanffy growth curves used in Gadget are based on predicting changes in length over a time step, based on the length at the end of the previous time step and the length of the time step. Therefore, length is not directly associated with age. This is a useful property when Gadget is being used for estimation, because it implies that age data are not a prerequisite to estimating growth (although it does help a lot). However, it also implies that the parameter values obtained when estimating (i.e., the length at infinity and growth rate parameters) are not directly comparable to those estimated when using length and age data in non-linear models estimation (standard methods). In particular, length at infinity using standard estimation methods with age data would represent the mean length attainable at infinity, but in Gadget it represents the maximal length that could be expected at infinity, and therefore almost all fish tracked in the model should actually be below this value. If individuals happen to surpass length at infinity in one time step due to variability in growth implemented via the beta binomial distribution, those individuals will exhibit negative growth in the next time step. This process is not represented by standard methods of estimation using age data. Therefore, care should be taken that any final values used for length at infinity within Gadget should be roughly above that expected of most fish observed, in order to avoid accidentally implementing unexpected and unrealistic negative growth. The second word of caution is that although the beta-binomial distribution has proven to be a very useful distribution for capturing realistic patterns in the variability of the growth process, it is not a very well-known or intuitive distribution. High values of beta produce a narrow distribution, while lower values produce a more dispersed distribution with a larger right-hand tail. Very low values should be avoided because it changes the expected shape of the distribution. In addition, the default value of maximum 15 length bin steps by which a fish could grow is set to be generous to allow the beta-binomial enough space to estimate the shape of the distribution without being confined by an upper limit. However, in practice, where growth is difficult to estimate or cohorts have very narrow length distributions, setting this parameter to a much lower value (2 - 4) can sometimes better capture observed patterns in growth variability. Finally, it should be kept in mind that growth, like all other time-dependent processes, is implemented within Gadget according to the time steps provided, not corresponding to an annual basis. For example, a model with quarterly time steps would yield annual growth based on \\(\\Delta t = 1/4\\), whereas the same in monthly time steps would yield \\(\\Delta t = 1/12\\). Likewise, setting maxlengthgroupgrowth to 2 would be far more constricting for a model with quarterly time steps than a model with monthly time steps: at most \\(2 * 4 = 8\\) length group steps would be allowed per annum rather than \\(2 * 12 = 24\\). An exception to this implementation is values for mortality: they are expected to be suppled as annual mortality rates, and are therefore subsequently divided among the time steps before implementation (e.g., so that \\(M = 0.2\\) is the same in quarterly and monthly models). To play around with the growth model we can now define a simple growth model to test the effect of various parameter settings: ## Stock file stock &lt;- gadgetstock(&#39;growth_stock&#39;,gd,missingOkay = TRUE) stock ## ; Generated by Rgadget 0.5 ## stockname growth_stock ## livesonareas ## minage ## maxage ## minlength ## maxlength ## dl ## refweightfile ## growthandeatlengths ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #growth_stock.Linf (* 0.001 #growth_stock.k) #growth_stock.walpha #growth_stock.wbeta ## beta (* 10 #growth_stock.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 stock &lt;- stock %&gt;% gadget_update(&#39;stock&#39;, livesonareas = 1, maxage = 1, minage = 1, minlength = 0, maxlength = 100, dl = 1) %&gt;% gadget_update(&#39;naturalmortality&#39;,0) %&gt;% gadget_update(&#39;refweight&#39;,data=tibble(length=0:100,mean=1)) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = 1, area = 1, age.factor = 1, area.factor =1, mean = 1, stddev = .1, alpha = 1, beta = 1)) stock %&gt;% write.gadget.file(gd) stock ## ; Generated by Rgadget 0.5 ## stockname growth_stock ## livesonareas 1 ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 100 ## dl 1 ## refweightfile Modelfiles/growth_stock.refwgt ## growthandeatlengths Aggfiles/growth_stock.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #growth_stock.Linf (* 0.001 #growth_stock.k) #growth_stock.walpha #growth_stock.wbeta ## beta (* 10 #growth_stock.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality 0 ## iseaten 0 ## doeseat 0 ## initialconditions ## minage 1 ## maxage 1 ## minlength 0 ## maxlength 100 ## dl 1 ## normalparamfile Modelfiles/growth_stock.init.normalparam ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 For the sake of testing let run the model and see if the run is successful: gadget_evaluate(gd, log = &#39;growth_log&#39;) ## [1] &quot;simple_growth_model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; To play with the effects of various settings: read.gadget.parameters(paste(gd, &#39;params.out&#39;, sep = &#39;/&#39;)) %&gt;% init_guess(&#39;alpha&#39;, value = 1) %&gt;% init_guess(&#39;beta&#39;, value = 1) %&gt;% init_guess(&#39;Linf&#39;, value = 100) %&gt;% init_guess(&#39;k$&#39;, value = 100) %&gt;% write.gadget.parameters(paste(gd, &#39;params.in&#39;, sep = &#39;/&#39;)) fit &lt;- gadget.fit(wgts = NULL, params.file = &#39;params.in&#39;, gd = gd) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; fit$stock.full %&gt;% ggplot(aes(length,number,col=as.factor(year))) + geom_line() We can also test a different value for \\(\\beta\\) in the beta binomial: ## different value for the beta binomial read.gadget.parameters(paste(gd, &#39;params.in&#39;, sep = &#39;/&#39;)) %&gt;% init_guess(&#39;bbin&#39;, value = 100) %&gt;% write.gadget.parameters(paste(gd, &#39;params.in2&#39;, sep = &#39;/&#39;)) fit2 &lt;- gadget.fit(wgts = NULL, params.file = &#39;params.in2&#39;, gd = gd) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; fit$stock.full %&gt;% bind_rows(fit2$stock.full,.id=&#39;model&#39;) %&gt;% ggplot(aes(length,number,col=as.factor(year),lty = as.factor(model))) + geom_line() 6.1.1.1 Excercise Investigate what are the effects of different growth rates (\\(k\\)) and \\(L_\\infty\\) on the length distribution. 6.2 Ling stock assessment in Icelandic waters As touched on in the Introduction, Gadget is particularly useful in a stock assessment setting when age data are absent or sparse. In these cases, parameterising age-based stock assessement models may require a lot of pre-processing based on sparse age data to calculate the model input (e.g., catch at age), which can produce bias. Using length- and age-based models instead are appealing because comparisons sparse data can be directly incorporated into the model likelihood, rather than pre-processed. This was the original main motivation for developing the model presented here that is currently used for stock assessment. In this example we present the stock assessment model used for ling Molva molva in Icelandic fisheries as an example of a length- and age-based model with all the standard components implemented, including natural mortality, fishing, growth, maturation, and recruitment. 6.3 Model initiation First we load Rgadget, set up directories, and some default model dimensions and names to use throughout. library(Rgadget) base_dir &lt;- &#39;ling_model&#39; vers &lt;- c(&#39;01-base&#39;) gd &lt;- gadget.variant.dir(sprintf(paste0(&quot;%s/&quot;,vers),base_dir)) schedule &lt;- expand.grid(year = 1982:2018, step = 1:4) %&gt;% arrange(year) gadgetfile(&#39;Modelfiles/time&#39;, file_type = &#39;time&#39;, components = list(list(firstyear = min(schedule$year), firststep=min(schedule$step), lastyear=max(schedule$year), laststep=max(schedule$step), notimesteps=c(4,3,3,3,3)))) %&gt;% write.gadget.file(gd) ## Write out areafile and update mainfile with areafile location gadgetfile(&#39;Modelfiles/area&#39;, file_type = &#39;area&#39;, components = list(list(areas = 1, size = 1, temperature= schedule %&gt;% mutate(area = 1, temperature = 5)))) %&gt;% write.gadget.file(gd) 6.3.1 Maturation as multi-‘stock’ models 6.3.1.1 Generating stocks In Gadget, maturation is modeled as a distributional shift between ‘stocks’, or more accurately substocks, of a true biological stock. In the case of standard fish stocks, this simply means that immature individuals are tracked within the immature ‘stock’ until they ‘transition’ to mature stock component. This structure is convenient because the generalized multi-‘stock’ implementation of life stages can be applied to more biologically complex scenarios that have more than two life stages, or biologically distinct components that need to be tracked separately (e.g., by sex), but still contribute to the entire population. For ling, we set up an immature and a mature stock file using the gadgetstock function, then update the ‘stock’ component of the file using gadget_update. Each ‘stock’ requires a separate stock file with all biological processes defined; therefore each stock can have different processes described for each stock. For example, note that the stocks are also structured a little bit differently: since we know young mature and old immature ling don’t exist, we don’t bother tracking them in the model. mat_stock &lt;- &#39;lingmat&#39; imm_stock &lt;- &#39;lingimm&#39; ## setup the immature stock first ling.imm &lt;- gadgetstock(imm_stock,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;stock&#39;, minage = 3, maxage = 10, minlength = 20, maxlength = 160, dl = 4, livesonareas = 1) ling.mat &lt;- gadgetstock(mat_stock,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;stock&#39;, minage = 5, maxage = 15, minlength = 20, maxlength = 160, dl = 4, livesonareas = 1) As described above in the Growth section, default settings are provided by the gadgetstock function. However, those settings give parameters that are named to be stock-specific. To simplify the model a bit, we change the parameters to have the same value in both stocks, so that both stocks are governed by the same growth equation: ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;doesgrow&#39;, growthparameters=c(linf=&#39;#ling.Linf&#39;, k=to.gadget.formulae(quote(0.001*ling.k)), alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39;), beta = to.gadget.formulae(quote(10*ling.bbin))) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;doesgrow&#39;, growthparameters=c(linf=&#39;#ling.Linf&#39;, k=to.gadget.formulae(quote(0.001*ling.k)), alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39;), beta = to.gadget.formulae(quote(10*ling.bbin))) An alternative way of implementing this would have been to keep the default parameter names, but supply the same parameter value within the parameter file. Also notice that although it is necessary to define the structural arguments listed above (minage, maxage, minlength, maxlength, dl, and livesonareas), updating the ‘stock’ component with gadget_update also sets up a few more convenient default settings in the gadget stock file. print(&#39;Immature&#39;) ## [1] &quot;Immature&quot; ling.imm ## ; Generated by Rgadget 0.5 ## stockname lingimm ## livesonareas 1 ## minage 3 ## maxage 10 ## minlength 20 ## maxlength 160 ## dl 4 ## refweightfile ## growthandeatlengths Aggfiles/lingimm.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #ling.Linf (* 0.001 #ling.k) #ling.walpha #ling.wbeta ## beta (* 10 #ling.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 print(&#39;Mature&#39;) ## [1] &quot;Mature&quot; ling.mat ## ; Generated by Rgadget 0.5 ## stockname lingmat ## livesonareas 1 ## minage 5 ## maxage 15 ## minlength 20 ## maxlength 160 ## dl 4 ## refweightfile ## growthandeatlengths Aggfiles/lingmat.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #ling.Linf (* 0.001 #ling.k) #ling.walpha #ling.wbeta ## beta (* 10 #ling.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) In particular, growthandeatlengths has been supplied with a file path name ‘Aggfiles/lingmat.stock.len.agg’, which corresponds with a file that will be automatically generated once the stock file is written [check it out in your folders]. This new aggregation file (or ‘Aggfile’) is required by Gadget, and contains information on how to aggregate true lengths into length bins as individuals are tracked through the model. Aggregation files also become important for the purposes of comparing simulations to data, so they will be revisited later on Day 3 when model-fitting procedures are introduced. In addition, natural mortality parameters have been supplied as automatically named switches (‘lingimm.M’ or ‘lingmat.M’) for every age. In the default case, mortality is not age-dependent, so the same parameter is provided for every age. 6.3.1.2 Maturation process and timing To implement maturation, we only want the immature stock to be able to mature and transition, or be moved (ie., to the mature stock). Therefore, doesmove and doesmature components are both switched on (values set to 1) by supplying additional information to them, whereas neither of these are switched on for the mature stock. Maturation is split into a two-step process in Gadget. For all ages included in the immature stock, maturation is determined by a maturation function (set using the doesmature component). For all ages older than the immature stock, maturation is governed by a stepwise ‘transition’ (or lack of transition) to the mature stock (set using the doesmove component). For all ages within the immature stock, at what length individuals in the immature stock become mature is governed by the maturation function in the doesmature component. When choosing a maturity function, both the rate of maturation and timing of maturity should be considered. For example, the maturity function used below (continuous) reflects a maturation that occurs continuously through the year (not seasonal) at a rate with a logistic dependence on length, age, or both. The first two parameters listed under the coefficients correspond with length-dependency (alpha and L50, respectively), whereas the last two correspond with age-dependency (beta and a50, respectively). Therefore, for ling, we have only implemented length-dependency. Maturation in the continuous functions occurs instantaneously (i.e., the maturation function is evaluated and individuals are moved to the mature stock in every time step). When individuals transition, they are placed into the same age-length bins of the destination stock. If that bin does not exist in the destination stock, or transitioning is not defined to occur, then the fish remain in the oldest age-length bins of the source stock, which act as a plus group. The Gadget User Guide describes other possible maturity functions, which implement for example a dependency on body condition, seasonal maturation (in which maturation is only evaluated in a certain time step), and length-dependent knife-edged (rather than logistic) maturation. For all ages older than the immature stock, maturation is governed by a stepwise ‘transition’ (or lack of transition) to the mature stock, set using the doesmove component. In our example we turn on the doesmove component to require that all fish in the oldest age of the immature stock should be moved to the mature stock upon aging beyond the range of the immature stock. If this doesmove is not turned on, then these individuals would instead remain in the immature stock as the oldest age would be considered a plus group, and could lead to a large component of old immature fish populating the model. For both the doesmove and doesmature components, the proportion of the originating stock transitioning to the destination stock needs to be designated. This is because both components additionally allow for maturation / transition into multiple stocks. It is therefore required that the stock names and corresponding ratios are supplied that describe what proportion of the immature should mature into each stock. Our example shows all (ratio = 1) immature ling to be maturing into the mature stock (‘lingmat’) under the argument maturestocksandratios, as well as transitioning to the same stock (under argument transitionstocksandratios) in the fourth time step of every year when in the maximal age bin of the immature stock. mat_stock &lt;- &#39;lingmat&#39; imm_stock &lt;- &#39;lingimm&#39; ## setup the immature stock first ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;doesmature&#39;, maturityfunction = &#39;continuous&#39;, maturestocksandratios = list(stock=&#39;lingmat&#39;, ratio = 1), coefficients = list(alpha = to.gadget.formulae(quote(0.001*ling.mat1)), l50=&#39;#ling.mat2&#39;, beta=0, a50=0)) %&gt;% gadget_update(&#39;doesmove&#39;, transitionstocksandratios = &#39;lingmat 1&#39;, transitionstep = 4) Note that although the doesmove component as described here is used for the maturation process, it actually provides far more flexibility in designing Gadget models by providing a mechanism for tracking stock components as the transition from one state to another. For example, in another case it may be useful to track the transition from male to female in a species that exhibits sequential hermaphroditism. 6.3.2 Initial conditions The model structures defined in the previous sections shows that numbers within each stock will be tracked in simulations for both stocks at a certain age, within one of 35 length bins, and on area 1. print(&#39;Immature&#39;) ## [1] &quot;Immature&quot; ling.imm ## ; Generated by Rgadget 0.5 ## stockname lingimm ## livesonareas 1 ## minage 3 ## maxage 10 ## minlength 20 ## maxlength 160 ## dl 4 ## refweightfile ## growthandeatlengths Aggfiles/lingimm.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #ling.Linf (* 0.001 #ling.k) #ling.walpha #ling.wbeta ## beta (* 10 #ling.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 1 ## maturityfunction continuous ## maturityfile Modelfiles/lingimm.maturity ## doesmove 1 ## transitionstocksandratios lingmat 1 ## transitionstep 4 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 print(&#39;Mature&#39;) ## [1] &quot;Mature&quot; ling.mat ## ; Generated by Rgadget 0.5 ## stockname lingmat ## livesonareas 1 ## minage 5 ## maxage 15 ## minlength 20 ## maxlength 160 ## dl 4 ## refweightfile ## growthandeatlengths Aggfiles/lingmat.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #ling.Linf (* 0.001 #ling.k) #ling.walpha #ling.wbeta ## beta (* 10 #ling.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M ## iseaten 0 ## doeseat 0 ## initialconditions ## doesmigrate 0 ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 As Gadget is set up as a forward simulation, initial conditions need to be supplied to each bin defined by a stock’s structure. For example, the immature stock needs 11 age x 35 length x 1 area bins to contain initial numbers of individuals. Gadget is set up by default to put 10 000 fish in each age group per area. However, in reality, at any point in time, including the initial time step of the model, the numbers at age of a real population are not expected to be equal. In any population with mortality, for example, there should be fewer older individuals than younger individuals. Similarly, differences between areas can shift all numbers at age to be higher or lower than those found in another area. In addition, each set of 10 000 fish, which correspond to an age and area, need to be assigned length bins according to a mean length, and some level of variability around that mean. These two attributes, numbers for each age x area group and distribution of those numbers across length bins, are controlled by using gadget_update to modify the initialconditions component of the stock file. In our ling example, this is done by supplying a data frame to an argument called normparam. Calling the normparam argument specifies the distribution of lengths to be according to a normal parameteric distribution, and that body weights calculated from these are according to an exponential equation of the same form as supplied in under the section Growth. Alternatively, it is possible to implement weights according to condition factor and length-weight key, or supply the numbers that make up the stock distribution rather than a theoretical distribution. Implementation methods for these should be referred to in the Gadget User Guide. The data frame supplied to normalparam needs one row per age x area combination; therefore, the first two columns in our example specify ages found in the stock (first columns), all with an area set to 1 (second column). [That is, using the . placeholder passes the ling.imm object to that location, where minage and maxage information is extracted]. The next two columns implement differences among ages and differences among areas respectively, by supplying age - and area - specific factors against which the 10 000 initial fish will be multiplied. These columns are called age.factor and area.factor, respectively. The next two columns reflect the mean length and standard deviation that will be used to distribute lengths for that age x area combination. Note that although different lengths at age could in theory be supplied for different areas, only one growth function is supplied for all areas, so justifying the utility of different lengths at age among different areas for only the initial time step may be difficult. Standard deviations of length are supplied by age age x area groups. The data frame described above can be filled with constants, but as we saw on Day 1, we can also replace these constants with parameter switches whose values can be controlled within the parameter file, or even formulas containing constants, switches, or both. For example, both the parameters used to describe the exponential length-weight relationship (alpha and beta, last columns of the data frame) and standard deviations (third-from-last column) are set here to be empirically derived constants. However, in the code below, we supply standard deviations as numerical values but alpha and beta as switches, as the latter are also used in other components of the stock file (growth). Today we will use this capability to set the initial conditions of the ling model to have two properties that aid in realism and internal consistency. First, we would like numbers at age to be distributed according to a total mortality experienced by the population at the beginning of the time series. Second, we would like to set mean lengths of the age groups to be those expected by the same Von Bertalanffy relationship implemented under the Growth section. To implement the first pattern via the age.factor column, a different equation per age is supplied. Each equation is based on an age-specific initial number parameter (e.g., lingimm.init.3 for age 3), which is then multiplied times the exponent of negative total mortality rate times the number of annual time steps since recruitment (i.e., the age). This ensures that the distribution in numbers among ages will be close to that expected simply from natural mortality. In addition, the pre-supplied natural mortality parameter lingimm.M is added to user-defined parameter ling.init.F, which represents an initial level of fishing mortality experienced before the first time step of the model. Doing this slightly changes the distribution to account for prior effects of fishing. Under this transformation, all initial parameters (lingimm.init.3, lingimm.init.4, etc.) have the same interpretation: they are the back-calculated recruitment values for the year classes to which the observed ages correspond. Implementing the initial parameters with a consistent interpretation yields the benefits of expecting their values to be on roughly the same scale and fosters easier communication (e.g., fixing all age-specific parameters to the same value would denote fixed recruitment during the years prior to the time series). So in mathematical terms the initial number of fish at age a will: \\[N_a = 10 000 \\times q \\nu_a e^{-a(M_a+F_0)}\\] And is written as: quote(exp(-1*(lingimm.M+ling.init.F)*3)*lingimm.init.3) %&gt;% to.gadget.formulae() ## [1] &quot;(* (exp (* (* (- 1) (+ #lingimm.M #ling.init.F)) 3)) #lingimm.init.3)&quot; To implement the second pattern, in mean lengths-at-age provided, we can borrow an Rgadget convenience function von_b_formula that writes out the lengthvbsimple equations in Gadget-friendly formulae. von_b_formula(3,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;) ## [1] &quot;(* #ling.Linf (- 1 (exp (* (* (- 1) (* 0.001 #ling.k)) (- 3 (+ 1 (/ (log (- 1 (/ #ling.recl #ling.Linf))) (* 0.001 #ling.k))))))))&quot; To be internally consistent, the parameters supplied to this convenience function, as well as the alpha and beta columns defined in the normalparam data frame, are set to be the same as those used when implementing growth in the doesgrow component above. Notice one more parameter called ling.recl is also supplied for internal consistency with recruitment settings, which are explained in the next section. #taken from data analyses init.sigma.i &lt;- rep(2, length(ling.imm[[1]]$minage:ling.imm[[1]]$maxage)) init.sigma.m &lt;- rep(2, length(ling.mat[[1]]$minage:ling.mat[[1]]$maxage)) ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = .[[1]]$minage:.[[1]]$maxage, area = 1, age.factor = parse(text=sprintf(&#39;exp(-1*(lingimm.M+ling.init.F)*%1$s)*lingimm.init.%1$s&#39;,age)) %&gt;% purrr::map(to.gadget.formulae) %&gt;% unlist(), area.factor = &#39;#lingimm.init.scalar&#39;, mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = init.sigma.i, alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39;)) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = .[[1]]$minage:.[[1]]$maxage, area = 1, age.factor = parse(text=sprintf(&#39;exp(-1*(lingmat.M+ling.init.F)*%1$s)*lingmat.init.%1$s&#39;,age)) %&gt;% purrr::map(to.gadget.formulae) %&gt;% unlist(), area.factor = &#39;#lingmat.init.scalar&#39;, mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = init.sigma.m, alpha = &#39;#lingmat.walpha&#39;, beta = &#39;#lingmat.wbeta&#39;)) ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) Note that the new files ‘Modelfiles/lingimm.init.normalparam’ and ‘Modelfiles/lingmat.init.normalparam’ are created to hold the information in the data frames. 6.3.3 Renewal Renewal can be thought of as another type of Initial Condition. In addition to numbers-at-age and their length distributions being needed for all ages in the first time step of the model, each year forward also needs individuals to populate the youngest age of each stock. Mature stocks are populated by the immature stocks through maturation, but the immature stocks requires inputted individuals from a recruitment process. Remember from day 1 that this can be accomplished either through renewal, in which a number is added to a certain age at a certain time step in every year, or it can occur via a stock-recruitment relationship, which is covered in day 4 material. For ling we keep it simple and provide switches for each year’s number at the youngest age. That way, these can either be inputted as values through a paramater file or they can be estimated at a later stage. To incorporate renewal, gadget_update is used to switch on the doesrenew argument to have a value of 1 in the stock file, and a data frame very similar to the initial conditions data frame is provided, except that it includes a year and step column to specify when the recruitment occurs. An area and age combination also need to be provided as in initial conditions, so that 10 000 fish can be supplied to this combination, and lengths distributed to these 10 000 fish in a similar manner as in initial conditions (i.e., via a parameteric distribution or a numerical distribution). A factor is then supplied under the column ‘number’ that scales these 10 000 fish up or down relative to other year x time-step combinations. Below, we have provided a knew parameter for each year (beginning with ling.rec), each of which are multiplied by the scalar ling.rec.scalar which is used to scale the whole time series of renewal values. Here, lengths are supplied via a normal parametric distribution (as under initial conditions), so a column is also provided for mean and stddev to designate the parametric distribution. Just as in initial conditions, the mean was set using the same Von Bertalanffy equation and parameters, including the ling.recl, which represents length at age 0. In the last columns, the same ling.walpha and ling.wbeta parameters are provided for translation into biomass. ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;doesrenew&#39;, normalparam = tibble(year = schedule$year, step = 1, area = 1, age = .[[1]]$minage, number = parse(text=sprintf(&#39;ling.rec.scalar*ling.rec.%s&#39;,year)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = &#39;#ling.rec.sd&#39;, alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39;)) ## write to file ling.imm %&gt;% write.gadget.file(gd) Note that the new file Modelfiles/lingimm.rec.normalparam is created to hold the information in the data frame. 6.3.4 Reference Weight Some implementations of the initial conditions and growth functions translate between lengths and weights via a constant length-weight key. Although the functions provided in our example here do not depend on it, we provide an example in the following code for how gadget_update can be used to update the refweight component to provide the key as a data frame, which is the same for both stocks. #For internal consistency, these parameter values should be the #same as those for ling.walpha &amp; ling.wbeta in the params file lw_pars &lt;- c(0.00000228, 3.20) ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;refweight&#39;, data=tibble(length=seq(.[[1]]$minlength,.[[1]]$maxlength,.[[1]]$dl), mean=lw_pars[1]*length^lw_pars[2])) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;refweight&#39;, data=tibble(length=seq(.[[1]]$minlength,.[[1]]$maxlength,.[[1]]$dl), mean=lw_pars[1]*length^lw_pars[2])) ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) Note that the new files Modelfiles/lingimm.refwgt and Modelfiles/lingmat.refwgt are created to hold the information in the data frames. 6.3.5 Is fished / eaten Finally, it is important to designate the component iseaten to have a value of 1, if the stock is to be consumed by other species or by fished by fleets. In Gadget, fishing is considered to be one of many forms of consumption. ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;iseaten&#39;,1) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;iseaten&#39;,1) ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) 6.3.6 Set up fleets using catch or effort data If fleets will be set up using data, catch or effort data must be first organized in the same structure as the model (units kg for catch). Here we continue with totalfleet examples that requires catch data for four fishing fleets: “foreign”, “longline”, “bottom trawl”, and “gillnet” fleets. [Foreign vessels are assumed to use long lines, but are kept separate because the have no biological data from fishery samples - more on this later]. Fleets are separated by gear so that a different selectivity curve can be implemented for each fleet (but foreign is assumed to have the same selectivity as the longline fleet). The survey is also treated as a fleet here so that it too can have a different selectivity curve implemented. However, note that because we don’t want the survey to actually have any fishing impact on the population, but we still want to use biological ‘fishery data’ resulting from the survey’s catches, we ‘trick’ Gadget by only allowing it to have a 1 kg catch in within each step / year combination. Gadget will give an error if there exists no catch in the time steps and areas when/where biological fishery data originate. Also notice that the attribute area_group needs to be applied to the data frame using the function structure. These attributes are called on by Rgadget when creating the appropriate aggregation files. The following will use files that can be downloaded here ## download.file(&#39;https://heima.hafro.is/~bthe/data_provided.zip&#39;) unzip(&#39;data_provided&#39;) lln.landings &lt;- structure(read_csv(&#39;data_provided/lln.csv&#39;), area_group = list(`1` = 1)) bmt.landings &lt;- structure(read_csv(&#39;data_provided/bmt.csv&#39;), area_group = list(`1` = 1)) gil.landings &lt;- structure(read_csv(&#39;data_provided/gil.csv&#39;), area_group = list(`1` = 1)) for.landings &lt;- structure(read_csv(&#39;data_provided/for.csv&#39;), area_group = list(`1` = 1)) surv.landings &lt;- structure(read_csv(&#39;data_provided/surv.csv&#39;), area_group = list(`1` = 1)) lln.landings ## [90m# A tibble: 100 x 4[39m ## year step area total_weight ## [90m*[39m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m1[24m994 1 1 [4m2[24m[4m3[24m[4m2[24m073 ## [90m 2[39m [4m1[24m994 2 1 [4m6[24m[4m3[24m300 ## [90m 3[39m [4m1[24m994 3 1 [4m2[24m[4m3[24m[4m0[24m816 ## [90m 4[39m [4m1[24m994 4 1 [4m4[24m[4m6[24m[4m5[24m965 ## [90m 5[39m [4m1[24m995 1 1 [4m3[24m[4m5[24m[4m1[24m216 ## [90m 6[39m [4m1[24m995 2 1 [4m1[24m[4m5[24m[4m8[24m494 ## [90m 7[39m [4m1[24m995 3 1 [4m1[24m[4m9[24m[4m2[24m527 ## [90m 8[39m [4m1[24m995 4 1 [4m6[24m[4m1[24m[4m7[24m108 ## [90m 9[39m [4m1[24m996 1 1 [4m5[24m[4m1[24m[4m6[24m931 ## [90m10[39m [4m1[24m996 2 1 [4m2[24m[4m8[24m[4m5[24m695 ## [90m# … with 90 more rows[39m surv.landings ## [90m# A tibble: 37 x 4[39m ## year step area number ## [90m*[39m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m1[24m982 2 1 1 ## [90m 2[39m [4m1[24m983 2 1 1 ## [90m 3[39m [4m1[24m984 2 1 1 ## [90m 4[39m [4m1[24m985 2 1 1 ## [90m 5[39m [4m1[24m986 2 1 1 ## [90m 6[39m [4m1[24m987 2 1 1 ## [90m 7[39m [4m1[24m988 2 1 1 ## [90m 8[39m [4m1[24m989 2 1 1 ## [90m 9[39m [4m1[24m990 2 1 1 ## [90m10[39m [4m1[24m991 2 1 1 ## [90m# … with 27 more rows[39m After obtaining the data, it is time to create the fleet files using gadgetfleet and gadget_update as we have seen before. There are a variety of fleet types that can be implemented in Gadget depending on the purpose and data available. Below we designate the fleet as a totalfleet because the data available are landings by biomass at time. It is an ‘ouput’ implementation, as is another option called numberfleet, which requires landings numbers (not biomass) at time. Possible ‘input’ options are linearfleet or effortfleet which are implementations that control effort. The last option quotafleet is more dynamic because it sets the kg taken by each fleet through a simple harvest control rule based on the previous year’s biomass level, then splits it among the fleet. Setting up a fleet using gadget_update requires setting the fleet type (below to totalfleet), giving the fleet a name (below surv, lln, bmt, gil, and foreign), designating a suitability function, and supplying the catch data described above. In Gadget, the fleets act as a simple predator in the model, with consumption controlled by input or output data to the fleet (i.e., effort or landings), depending on the type of fleet chosen. Therefore, ‘suitability’ is the term Gadget uses to encompass patterns of selectivity patterns related to both fleet and predator consumption. However, fleet files are set up differently than predator files (designated as another ‘stock’) because of common differences in data and a lack of variation in predator ‘size’ when it comes to fishing fleets. gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;surv&#39;, suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.surv.alpha&#39;, beta = &#39;#ling.surv.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.surv.alpha&#39;, beta = &#39;#ling.surv.l50&#39;)), data = surv.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;lln&#39;, suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;)), data = lln.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;bmt&#39;, suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.bmt.alpha&#39;, beta = &#39;#ling.bmt.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.bmt.alpha&#39;, beta = &#39;#ling.bmt.l50&#39;)), data = bmt.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;gil&#39;, suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.gil.alpha&#39;, beta = &#39;#ling.gil.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.gil.alpha&#39;, beta = &#39;#ling.gil.l50&#39;)), data = gil.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;foreign&#39;, suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;)), # list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;andersenfleet&#39;, # p0 = &#39;#ling.lln.p0&#39;, # p1 = to.gadget.formulae(quote(log(180/ling.lln.lmode))), # p2 = &#39;#ling.lln.p2&#39;, # p3 = &#39;#ling.lln.p3&#39;, # p4 = &#39;#ling.lln.p4&#39;, # L = &#39;180&#39;), # lingmat = list(type=&#39;function&#39;,suit_func=&#39;andersenfleet&#39;, # p0 = &#39;#ling.lln.p0&#39;, # p1 = to.gadget.formulae(quote(log(180/ling.lln.lmode))), # p2 = &#39;#ling.lln.p2&#39;, # p3 = &#39;#ling.lln.p3&#39;, # p4 = &#39;#ling.lln.p4&#39;, # L = &#39;180&#39;)), data = for.landings) %&gt;% write.gadget.file(gd) 6.3.6.1 Exercise Try changing the longline and foreign fleet to the andersenfleet function (see commented out code under the foreign fleet, as well as day 1 material). Use the Rgadget helper function to explore it. Under what conditions could this function be useful? [Hint: also look up the description in the Gadget User Guide] 6.4 Run the simulation using pre-determined parameters Now we run Gadget on the ling model just as in the simple model example. gadget_evaluate(gd,log = &#39;ling_log&#39;) ## [1] &quot;ling_model/01-base&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; read.gadget.parameters(paste0(gd,&#39;/params.out&#39;)) ## [90m# A tibble: 81 x 5[39m ## switch value lower upper optimise ## [90m*[39m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ling.Linf 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 2[39m ling.k 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 3[39m ling.walpha 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 4[39m ling.wbeta 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 5[39m ling.bbin 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 6[39m lingimm.M 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 7[39m lingimm.init.scalar 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 8[39m ling.init.F 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 9[39m lingimm.init.3 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m10[39m lingimm.init.4 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m# … with 71 more rows[39m As you can see above, a default simulation run uses unrealistic parameter values when none are provided. To make it a little more interesting, we change the input parameter file to one that we know contains some reasonable values. params.forsim &lt;- read.gadget.parameters(&#39;data_provided/params.forsim&#39;) gadget_evaluate(gd,log = &#39;simple_log2&#39;,params.in = params.forsim) ## [1] &quot;ling_model/01-base&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; params.forsim ## [90m# A tibble: 80 x 5[39m ## switch value lower upper optimise ## [90m*[39m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ling.Linf 163. 1.00[90me[39m+ 2 200 1 ## [90m 2[39m ling.k 96.2 4.00[90me[39m+ 1 100 1 ## [90m 3[39m ling.walpha 0.000[4m0[24m[4m0[24m[4m2[24m28 1.00[90me[39m[31m-10[39m 1 0 ## [90m 4[39m ling.wbeta 3.20 2.00[90me[39m+ 0 4 0 ## [90m 5[39m ling.bbin 26.7 1.00[90me[39m[31m- 8[39m 100 1 ## [90m 6[39m lingimm.M 0.15 1.00[90me[39m[31m- 3[39m 1 0 ## [90m 7[39m lingimm.init.scalar 1.66 1.00[90me[39m+ 0 300 1 ## [90m 8[39m ling.init.F 0.219 1.00[90me[39m[31m- 1[39m 1 1 ## [90m 9[39m lingimm.init.3 366. 1.00[90me[39m[31m- 3[39m [4m1[24m000 1 ## [90m10[39m lingimm.init.4 377. 1.00[90me[39m[31m- 3[39m [4m1[24m000 1 ## [90m# … with 70 more rows[39m We can as before look into the simulation results: params.forsim %&gt;% write.gadget.parameters(paste(gd, &#39;params.forsim&#39;, sep= &#39;/&#39;)) fit &lt;- gadget.fit(gd = gd, wgts = NULL, params.file = &#39;params.forsim&#39;) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; ## standard ICES plot library(patchwork) plot(fit, data = &#39;res.by.year&#39;,type=&#39;catch&#39;) + plot(fit, data = &#39;res.by.year&#39;, type = &#39;rec&#39;) + plot(fit, data = &#39;res.by.year&#39;, type = &#39;F&#39;) + plot(fit, data = &#39;res.by.year&#39;, type = &#39;total&#39;) 6.5 Talking points How would you structure your model? Split by sex? How many fleets? … "],["fitting-a-model-to-data.html", "7 Fitting a model to data 7.1 Introducing likelihood functions 7.2 Incorporating data (Ling case study cont.) 7.3 Setting up likelihood components 7.4 Fitting a Gadget model to data 7.5 Set optimisation routine 7.6 Using the iterative reweighting function to fit a Gadget statistical model 7.7 Visualize Gadget statistical model fit", " 7 Fitting a model to data 7.1 Introducing likelihood functions In Gadget, a likelihood function is specified by supplying likelihood components within the likelihood file, which is referred to by the main file. Individual likelihood component scores are summed together after being multiplied by weights to form a total likelihood score, and each likelihood score is defined by the type of likelihood component specified. Component types define both the kind of data and likelihood function being calculated for that component. Although we refer to ‘likelihood scores’ throughout this description, it should be kept in mind that these are more accurately sums of log likelihoods, so that the objective function used for model fitting attempts to minimize the total likelihood score. 7.2 Incorporating data (Ling case study cont.) In introducing likelihood components, we will first go through those used within the ling example in detail, but only mention the other types as they follow similar patterns of implementation. To use Rgadget to set up likelihood files, the first consideration that should be made is what data are available that would be useful for creating a likelihood component. These have been provided for you here: in the ‘data_provided’ folder, you will find catch data (as introduced with the fleets), as well as survey indices, catch distribution, and ‘stock’ distribution data. Catch distributions include numbers at length as well as numbers at age and length by fleet. These therefore include both biological samples in fishery data as well as survey data. Each length- or age-bin has been defined as having the lower bound only inclusive, except that the lower bound of the smallest bin and the upper bound of the largest bin are open-ended to include all values lower or higher, respectively. These numbers are then used within Gadget to form proportions among defined bins, which are compared to the same proportions among the same bins simulated in the model. Stock distribution data are numbers within each stock, which for ling is immature or mature, but could for example be gender-specific stocks. Stock distribution numbers are similarly used to form proportions within Gadget. As we saw when incorporating catch data into fleet files (day 2), certain attributes need to be present in order for the proper and internally consistent Gadget aggregation files to be created alongside these data files. For catch and stock distribution data, these include area, length, and age aggregations. Even when there is only a single bin, these aggregations need to be specified. For example a single area and a single age group is needed for length distributions, in addition to the length bins. Note that bins need not be evenly distributed across the total length range; instead they are highly flexible and can be specified as any grouping. Therefore the user should be careful to ensure that the definitions make sense and that bins do not overlap. In our example below, we show how to add those necessary attributes, although in reality to do this we also use another R package named ‘mfdb’ that is aimed at database management and data extraction [more on this in day 5]. library(tidyverse) library(Rgadget) #assuming you are beginning in a fresh session; this information should be in an #initialization script base_dir &lt;- &#39;ling_model&#39; vers &lt;- c(&#39;01-base&#39;) gd &lt;- normalizePath(gadget.variant.dir(sprintf(paste0(&quot;%s/&quot;,vers),base_dir))) ling.imm &lt;- gadgetstock(&#39;lingimm&#39;,gd) ling.mat &lt;- gadgetstock(&#39;lingmat&#39;,gd) area_file &lt;- read.gadget.file(gd, &#39;Modelfiles/area&#39;) minage &lt;- ling.imm[[1]]$minage maxage &lt;- ling.mat[[1]]$maxage maxlength &lt;- ling.mat[[1]]$maxlength minlength &lt;- ling.imm[[1]]$minlength dl &lt;- ling.imm[[1]]$dl create_intervals &lt;- function (prefix, vect) { x&lt;- structure(vect[1:(length(vect)-1)], names = paste0(prefix, vect[1:(length(vect)-1)])) %&gt;% as.list(.) %&gt;% purrr::map(~structure(seq(.,vect[-1][which(vect[1:(length(vect)-1)]==.)],1)[-length(seq(.,vect[-1][which(vect[1:(length(vect)-1)]==.)],1))], min = ., max = vect[-1][which(vect[1:(length(vect)-1)]==.)])) x[[length(x)]] &lt;- c(x[[length(x)]], attributes(x[[length(x)]])$max) %&gt;% structure(., min = min(.), max = max(.)) return(x) } #just to see what this function does: create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)) %&gt;% .[1:3] ## $len20 ## [1] 20 21 22 23 ## attr(,&quot;min&quot;) ## [1] 20 ## attr(,&quot;max&quot;) ## [1] 24 ## ## $len24 ## [1] 24 25 26 27 ## attr(,&quot;min&quot;) ## [1] 24 ## attr(,&quot;max&quot;) ## [1] 28 ## ## $len28 ## [1] 28 29 30 31 ## attr(,&quot;min&quot;) ## [1] 28 ## attr(,&quot;max&quot;) ## [1] 32 #catch distribution data available: #length distributions do not regard age bins ldist.surv &lt;- structure(read_csv(&#39;data_provided/ldist_sur.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;all&#39;,seq(minage, maxage, maxage-minage)) ) ldist.lln &lt;- structure(read_csv(&#39;data_provided/ldist_lln.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;all&#39;,seq(minage, maxage, maxage-minage)) ) ldist.bmt &lt;- structure(read_csv(&#39;data_provided/ldist_bmt.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;all&#39;,seq(minage, maxage, maxage-minage)) ) ldist.gil &lt;- structure(read_csv(&#39;data_provided/ldist_gil.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;all&#39;,seq(minage, maxage, maxage-minage)) ) attributes(ldist.surv) %&gt;% purrr::map(head) ## $names ## [1] &quot;year&quot; &quot;step&quot; &quot;area&quot; &quot;age&quot; &quot;length&quot; &quot;number&quot; ## ## $class ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 4 5 6 ## ## $spec ## $spec$cols ## $spec$cols$year ## &lt;collector_double&gt; ## ## $spec$cols$step ## &lt;collector_double&gt; ## ## $spec$cols$area ## &lt;collector_double&gt; ## ## $spec$cols$age ## &lt;collector_character&gt; ## ## $spec$cols$length ## &lt;collector_character&gt; ## ## $spec$cols$number ## &lt;collector_double&gt; ## ## ## $spec$default ## &lt;collector_guess&gt; ## ## $spec$skip ## [1] 1 ## ## ## $area ## $area$`1` ## [1] 1 ## ## ## $length ## $length$len20 ## [1] 20 21 22 23 ## attr(,&quot;min&quot;) ## [1] 20 ## attr(,&quot;max&quot;) ## [1] 24 ## ## $length$len24 ## [1] 24 25 26 27 ## attr(,&quot;min&quot;) ## [1] 24 ## attr(,&quot;max&quot;) ## [1] 28 ## ## $length$len28 ## [1] 28 29 30 31 ## attr(,&quot;min&quot;) ## [1] 28 ## attr(,&quot;max&quot;) ## [1] 32 ## ## $length$len32 ## [1] 32 33 34 35 ## attr(,&quot;min&quot;) ## [1] 32 ## attr(,&quot;max&quot;) ## [1] 36 ## ## $length$len36 ## [1] 36 37 38 39 ## attr(,&quot;min&quot;) ## [1] 36 ## attr(,&quot;max&quot;) ## [1] 40 ## ## $length$len40 ## [1] 40 41 42 43 ## attr(,&quot;min&quot;) ## [1] 40 ## attr(,&quot;max&quot;) ## [1] 44 ## ## ## $age ## $age$all3 ## [1] 3 4 5 6 7 8 9 10 11 12 13 14 15 ## attr(,&quot;min&quot;) ## [1] 3 ## attr(,&quot;max&quot;) ## [1] 15 #age bins needed for age-length distributions aldist.surv &lt;- structure(read_csv(&#39;data_provided/aldist_sur.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;age&#39;,c(minage:11, maxage)) ) aldist.lln &lt;- structure(read_csv(&#39;data_provided/aldist_lln.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;age&#39;,c(minage:11, maxage)) ) aldist.bmt &lt;- structure(read_csv(&#39;data_provided/aldist_bmt.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;age&#39;,c(minage:11, maxage)) ) aldist.gil &lt;- structure(read_csv(&#39;data_provided/aldist_gil.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl)), age = create_intervals(&#39;age&#39;,c(minage:11, maxage)) ) attributes(aldist.surv)$age %&gt;% head(3) ## $age3 ## [1] 3 ## attr(,&quot;min&quot;) ## [1] 3 ## attr(,&quot;max&quot;) ## [1] 4 ## ## $age4 ## [1] 4 ## attr(,&quot;min&quot;) ## [1] 4 ## attr(,&quot;max&quot;) ## [1] 5 ## ## $age5 ## [1] 5 ## attr(,&quot;min&quot;) ## [1] 5 ## attr(,&quot;max&quot;) ## [1] 6 #stock distribution data available: matp.surv &lt;- structure(read_csv(&#39;data_provided/matp_sur.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;,seq(minlength, maxlength, dl*2)), age = list(mat_ages = ling.mat[[1]]$minage:ling.mat[[1]]$maxage) ) #attributes(matp.surv) For ling, length-based indices were used by choosing 7 ‘slices’ of abundance indices across the length range of ling observed. Index bounds are defined as above, generally inclusive of the lower bound only, but open-ended for the smallest and largest bins. It is important to note that only area and length attributes are included as attributes on these data frames, rather than age, as in the distributional components. The length attribute allows gadget_update to recognize these data as length-based indices, rather than age-based or acoustic indices, for example. It is also important to keep in mind here that each slice will have its own estimated catchability per survey (single data frame below) and area combination (multiple areas may be within a data frame). #survey index data available: slices &lt;- list(&#39;len20&#39; = c(20,52), &#39;len52&#39; = c(52,60), &#39;len60&#39; = c(60,72), &#39;len72&#39; = c(72,80), &#39;len80&#39; = c(80,92), &#39;len92&#39; = c(92,100), &#39;len100&#39; = c(100,160) ) # just to illustrate slices: ldist.surv %&gt;% mutate(length = substring(length, 4) %&gt;% as.numeric) %&gt;% filter(year %in% c(2000,2005,2010,2015)) %&gt;% group_by(year,length) %&gt;% summarise(n = sum(number)) %&gt;% ggplot(aes(x = length, y = n)) + geom_line() + geom_vline(aes(xintercept = length), lty = 2, col = &#39;orange&#39;, data = slices %&gt;% bind_rows() %&gt;% t() %&gt;% .[-1,1] %&gt;% tibble(length = .)) + facet_wrap(~year) # set up aggregation info for length-based survey indices SI1 &lt;- structure(read_csv(&#39;data_provided/SI1.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[1]])) SI2 &lt;- structure(read_csv(&#39;data_provided/SI2.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[2]])) SI3 &lt;- structure(read_csv(&#39;data_provided/SI3.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[3]])) SI4 &lt;- structure(read_csv(&#39;data_provided/SI4.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[4]])) SI5 &lt;- structure(read_csv(&#39;data_provided/SI5.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[5]])) SI6 &lt;- structure(read_csv(&#39;data_provided/SI6.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[6]])) SI7 &lt;- structure(read_csv(&#39;data_provided/SI7.csv&#39;), area = list(area_file[[1]]$areas) %&gt;% set_names(.), length = create_intervals(&#39;len&#39;, slices[[7]])) 7.2.1 Exercise Change the aggregation levels of the age-length distribution data so that data are compared to model results within the bins 3 - 6, 7, 8, 9, 10 - 11, and 12 - 15. 7.3 Setting up likelihood components Using Rgadget, writing the files that specify the likelihood componenets is straightforward. When calling gadgetlikelihood and then writing it with write.gadget.file, a likelihood file is created within R and written to disc. The likelihood file contains a list of likelihood component specifications, and within each component is where the likelihood function, data, and weighting of the likelihood component is specified. Here we start with the distributional components. In all cases, each component receives a distinct name (to be referenced later so keep them short and distinct), weights (1 to yield equal weights for now), data as imported above, and the fleet names and stock names to which these data apply. As a default, Rgadget specifies a sum of squares function to calculate the likelihood score (sumofsquares), although a variety of other functions are possible, including one for stratified sum of squares (stratified), multinomial function (multinomial), pearson function (pearson), gamma function (gamma), log function (log), multivariate normal function (mvn) or a multivariate logistic function (mvlogistic). Many of these functions have been tailored for specific data situations (e.g., including tagging or predation data into a likelihood component). More on these functions can be read in the Gadget User Guide. To change the default setting to the stratified sum of squares, for example, one would include an additional argument function = 'stratified', to the gadget_update call. lik &lt;- gadgetlikelihood(&#39;likelihood&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.surv&quot;, weight = 1, data = ldist.surv, fleetnames = c(&quot;surv&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.surv&quot;, weight = 1, data = aldist.surv, fleetnames = c(&quot;surv&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.lln&quot;, weight = 1, data = ldist.lln, fleetnames = c(&quot;lln&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.lln&quot;, weight = 1, data = aldist.lln, fleetnames = c(&quot;lln&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.gil&quot;, weight = 1, data = ldist.gil, fleetnames = c(&quot;gil&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.gil&quot;, weight = 1, data = aldist.gil, fleetnames = c(&quot;gil&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.bmt&quot;, weight = 1, data = ldist.bmt, fleetnames = c(&quot;bmt&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.bmt&quot;, weight = 1, data = aldist.bmt, fleetnames = c(&quot;bmt&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;stockdistribution&quot;, name = &quot;matp.surv&quot;, weight = 1, data = matp.surv, fleetnames = c(&quot;surv&quot;), stocknames =c(&quot;lingimm&quot;,&quot;lingmat&quot;)) lik ## ; Generated by Rgadget 0.5 ## ; ## [component] ## name ldist.surv ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.ldist.surv.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.ldist.surv.area.agg ## ageaggfile Aggfiles/catchdistribution.ldist.surv.age.agg ## lenaggfile Aggfiles/catchdistribution.ldist.surv.len.agg ## fleetnames surv ## stocknames lingimm lingmat ## ; ## [component] ## name aldist.surv ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.aldist.surv.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.aldist.surv.area.agg ## ageaggfile Aggfiles/catchdistribution.aldist.surv.age.agg ## lenaggfile Aggfiles/catchdistribution.aldist.surv.len.agg ## fleetnames surv ## stocknames lingimm lingmat ## ; ## [component] ## name ldist.lln ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.ldist.lln.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.ldist.lln.area.agg ## ageaggfile Aggfiles/catchdistribution.ldist.lln.age.agg ## lenaggfile Aggfiles/catchdistribution.ldist.lln.len.agg ## fleetnames lln ## stocknames lingimm lingmat ## ; ## [component] ## name aldist.lln ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.aldist.lln.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.aldist.lln.area.agg ## ageaggfile Aggfiles/catchdistribution.aldist.lln.age.agg ## lenaggfile Aggfiles/catchdistribution.aldist.lln.len.agg ## fleetnames lln ## stocknames lingimm lingmat ## ; ## [component] ## name ldist.gil ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.ldist.gil.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.ldist.gil.area.agg ## ageaggfile Aggfiles/catchdistribution.ldist.gil.age.agg ## lenaggfile Aggfiles/catchdistribution.ldist.gil.len.agg ## fleetnames gil ## stocknames lingimm lingmat ## ; ## [component] ## name aldist.gil ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.aldist.gil.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.aldist.gil.area.agg ## ageaggfile Aggfiles/catchdistribution.aldist.gil.age.agg ## lenaggfile Aggfiles/catchdistribution.aldist.gil.len.agg ## fleetnames gil ## stocknames lingimm lingmat ## ; ## [component] ## name ldist.bmt ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.ldist.bmt.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.ldist.bmt.area.agg ## ageaggfile Aggfiles/catchdistribution.ldist.bmt.age.agg ## lenaggfile Aggfiles/catchdistribution.ldist.bmt.len.agg ## fleetnames bmt ## stocknames lingimm lingmat ## ; ## [component] ## name aldist.bmt ## weight 1 ## type catchdistribution ## datafile Data/catchdistribution.aldist.bmt.sumofsquares ## function sumofsquares ## aggregationlevel 0 ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/catchdistribution.aldist.bmt.area.agg ## ageaggfile Aggfiles/catchdistribution.aldist.bmt.age.agg ## lenaggfile Aggfiles/catchdistribution.aldist.bmt.len.agg ## fleetnames bmt ## stocknames lingimm lingmat ## ; ## [component] ## name matp.surv ## weight 1 ## type stockdistribution ## datafile Data/stockdistribution.matp.surv.sumofsquares ## function sumofsquares ## overconsumption 0 ## epsilon 10 ## areaaggfile Aggfiles/stockdistribution.matp.surv.area.agg ## ageaggfile Aggfiles/stockdistribution.matp.surv.age.agg ## lenaggfile Aggfiles/stockdistribution.matp.surv.len.agg ## fleetnames surv ## stocknames lingimm lingmat Note here that Rgadget automatically creates references to necessary data files (‘Data/…’) and aggregation files (‘Agg/…’) that define the bin structure as defined by data attributes (see previous section). When write.gadget.file is finally called after we are done adding all likelihood components, these data and agg files will be written alongside this likelihood file, and a reference to this likelihood file will also be drawn within the ‘main’ file. You can also see how individual aggregation files will be printed by e.g.: lik[[2]]$ageaggfile ## ; Generated by Rgadget 0.5 ## age3 3 ## age4 4 ## age5 5 ## age6 6 ## age7 7 ## age8 8 ## age9 9 ## age10 10 ## age11 11 12 13 14 15 which gives you the age aggregation for the second likelihood component. 7.3.1 Setting up survey indices Incorporating survey index components is very similar except that 1) the fact that the survey index is length-based is determined by the length attribute of the data frame, which sets the argument si_type to a value of lengths, and 2) a catchability function is also specified under the argument 'fittype'. In addition, the argument biomass has a default setting of 0, signifying a numbers-based index (rather than a biomass-based index, which has a value of 1). Other options for si_type can be read about in the Gadget User Guide, and ages, fleets, acoustic, and effort. The catchability function defines the type of linear regression to be used to calculate the likelihood score. Options include a linear fit on the orignal or log scale (linearfit or loglinearfit), linear fit with a fixed slope on the original or log scale (fixedslopelinearfit or fixedslopeloglinearfit), linear fit with a fixed intercept on the original or log scale (fixedinterceptlinearfit or fixedinterceptlinearfit), or a linear/loglinear function with both the slope and intercept fixed (fixedlinearfit or fixedloglinearfit). In the first set of cases (linear or loglinear fits), two parameters would be estimated; in the next two sets of cases, only a single parameter is estimated (slope or intercept, whichever is not fixed). In the last set of cases (fixed liner or loglinear fits), no parameters are estimated. Whenever a parameter is fixed, its value needs to be included as an additional argument to gadget_update. For example, catchability of the indices of smaller sized fish below are estimated using a log linear fit with both slopes and intercepts estimated, but catchabilities for indices of larger sized fish are calculated using log linear fits with fixed slopes. The slopes are fixed to a value of 1, so the argument slope = 1 is included in the gadget_update call. Notice that, unlike the distributional likelihood components, a fleet is not specified for the survey indices, unless si_type is set to fleets, effort, acoustic (rather than length as in our example). When indices are not length- or age-based, a single catchability is estimated, rather than the series of catchabilities estimated for each age or length index series. Each survey index is matched to stock size observations at a given time and area; therefore, if there are two length- or age-based survey index series with the same time and area, they can each be incorporated as separate likelihood components as long as they have different names. lik &lt;- lik %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[1]), weight = 1, data = SI1, fittype = &#39;loglinearfit&#39;, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[2]), weight = 1, data = SI2, fittype = &#39;loglinearfit&#39;, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[3]), weight = 1, data = SI3, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[4]), weight = 1, data = SI4, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[5]), weight = 1, data = SI5, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[6]), weight = 1, data = SI6, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[7]), weight = 1, data = SI7, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) lik Finally, there are two components to the likelihood that do not incorporate data but are instead used to ensure that the optimisation search algorithm remains within reasonable ranges of the defined model. The first component provides penalties to for exceeding parameter bounds as set by the user in the input parameter file. In this example, the weight is set to 0.5, but see the troubleshooting page for cases in which it may be wise to set this weight higher. The data frame provided to this likelihood component specifies the power and parameter weights supplied if the parameter value exceeds its upper and lower bounds. If the likelihood of a parameter exceeds either the upper or lower bound, the distance between the bound and the parameter value is squared and multiplied by the parameter weights 10 000; then the sum of these scores across all parameters is multiplied by the 0.5 weighting before being summed along with the other likelihood components to form the total. 7.3.2 Penalty functions Understocking introduces a penalty when there are insufficent prey to met the requirements of the predators. For example, if landings of the fleets exceeds available biomass, then the penalty is applied. The understocking penalty likelihood is then defined as the sum of the number of prey that are ‘missing’, raised to a power set by default to 2, and multiplied by the likelihood weight of 100 as indicated below. lik &lt;- lik %&gt;% gadget_update(&quot;penalty&quot;, name = &quot;bounds&quot;, weight = &quot;0.5&quot;, data = data.frame( switch = c(&quot;default&quot;), power = c(2), upperW=10000, lowerW=10000, stringsAsFactors = FALSE)) %&gt;% gadget_update(&quot;understocking&quot;, name = &quot;understocking&quot;, weight = &quot;100&quot;) lik %&gt;% write.gadget.file(gd) Notice that when the likelihood file is written, so are all the supporting aggregation files under the ‘Aggfiles’ folder. 7.4 Fitting a Gadget model to data Now that all data and likelihood components are incorporated, it is possible to run gadget_optimise to run a fitting procedure. Like any other optimisation routine, what is still needed are 1) starting values for the parameters, and 2) optimisation routine settings. 7.4.1 Create starting values If we start here with the same simple gadget_evaluate simulation as in day 2 of the ling model, we can see that a file called ‘params.out’ is automatically generated (same timestamp as the simple_log). However, if you open this file, is shows that each parameter was given a value of 1 with bounds set to {-9999, 9999} and no optimisation (0). Therefore, this simulation was run with very unrealistic parameters. Obviously this is not a helpful run in itself, but it is at least useful for conveniently generating an initial parameter file with the correct Gadget structure containing all the parameters specified throughout the Gadget model files. gadget_evaluate(gd,log = &#39;ling_log&#39;) ## [1] &quot;/home/runner/work/gadget-course/gadget-course/ling_model/01-base&quot; read.gadget.parameters(paste0(gd,&#39;/params.out&#39;)) ## [90m# A tibble: 81 x 5[39m ## switch value lower upper optimise ## [90m*[39m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ling.Linf 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 2[39m ling.k 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 3[39m ling.walpha 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 4[39m ling.wbeta 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 5[39m ling.bbin 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 6[39m lingimm.M 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 7[39m lingimm.init.scalar 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 8[39m ling.init.F 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m 9[39m lingimm.init.3 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m10[39m lingimm.init.4 1 -[31m[4m9[24m99[39m[31m9[39m [4m9[24m999 0 ## [90m# … with 71 more rows[39m Now that the structure is set, it is much easier to change the bounds and starting values to more realistic ones using init_guess. This function uses the grepl function internally to match names, so that large chunks of parameters with similar names can have their bounds similarly changed. lw_pars &lt;- c(0.00000228, 3.20) #same values as in day 2 ## update the input parameters with sane initial guesses read.gadget.parameters(sprintf(&#39;%s/params.out&#39;,gd)) %&gt;% init_guess(&#39;rec.[0-9]|init.[0-9]&#39;,1,0.001,1000,1) %&gt;% init_guess(&#39;recl&#39;,12,4,20,1) %&gt;% init_guess(&#39;rec.sd&#39;,5, 4, 20,1) %&gt;% init_guess(&#39;Linf&#39;,160, 100, 200,1) %&gt;% init_guess(&#39;k$&#39;,90, 40, 100,1) %&gt;% init_guess(&#39;bbin&#39;,6, 1e-08, 100, 1) %&gt;% init_guess(&#39;alpha&#39;, 0.5, 0.01, 3, 1) %&gt;% init_guess(&#39;l50&#39;,50,10,100,1) %&gt;% init_guess(&#39;walpha&#39;,lw_pars[1], 1e-10, 1,0) %&gt;% init_guess(&#39;wbeta&#39;,lw_pars[2], 2, 4,0) %&gt;% init_guess(&#39;M$&#39;,0.15,0.001,1,0) %&gt;% init_guess(&#39;rec.scalar&#39;,400,1,500,1) %&gt;% init_guess(&#39;init.scalar&#39;,200,1,300,1) %&gt;% init_guess(&#39;mat2&#39;,60,0.75*60,1.25*60,1) %&gt;% init_guess(&#39;mat1&#39;,70, 10, 200, 1) %&gt;% init_guess(&#39;init.F&#39;,0.4,0.1,1,1) %&gt;% write.gadget.parameters(.,file=sprintf(&#39;%s/params.in&#39;,gd)) read.gadget.parameters(sprintf(&#39;%s/params.in&#39;,gd)) ## [90m# A tibble: 81 x 5[39m ## switch value lower upper optimise ## [90m*[39m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ling.Linf 160 1.00[90me[39m+ 2 200 1 ## [90m 2[39m ling.k 90 4.00[90me[39m+ 1 100 1 ## [90m 3[39m ling.walpha 0.000[4m0[24m[4m0[24m[4m2[24m28 1.00[90me[39m[31m-10[39m 1 0 ## [90m 4[39m ling.wbeta 3.2 2.00[90me[39m+ 0 4 0 ## [90m 5[39m ling.bbin 6 1.00[90me[39m[31m- 8[39m 100 1 ## [90m 6[39m lingimm.M 0.15 1.00[90me[39m[31m- 3[39m 1 0 ## [90m 7[39m lingimm.init.scalar 200 1.00[90me[39m+ 0 300 1 ## [90m 8[39m ling.init.F 0.4 1.00[90me[39m[31m- 1[39m 1 1 ## [90m 9[39m lingimm.init.3 1 1.00[90me[39m[31m- 3[39m [4m1[24m000 1 ## [90m10[39m lingimm.init.4 1 1.00[90me[39m[31m- 3[39m [4m1[24m000 1 ## [90m# … with 71 more rows[39m Now is a good point to scan the resulting ‘params.in’ file to make sure that a parameter was not forgotten and left with default values and bounds. 7.4.1.1 Exercise Suppose that age sampling was done so that the same sampling effort was spread across all ages equally (roughly 30 fish per length range to attain roughly 30 age samples per age). Change the likelihood component function for age-length data to the appropriate function. Change the survey indices to be biomass indices using gadget_update. Use init_guess to change the bounds of only one set of selectivity parameters. 7.5 Set optimisation routine To run an optimisation via gadget_optimize is simple, the user provides an input parameter file with starting values (below as params.in = 'params.in'), and providing a file name to which final parameter values should be written (below as params.out = 'params.init'). timestamp() gadget_optimize(gd,params.in = &#39;params.in&#39;, params.out = &#39;params.init&#39;) timestamp() Now that reasonable bounds and starting values have been set for an optimisation run, default settings can be used to run a short and simple Gadget optimisation. If you open the params.init file, comments can be found at the top that detail the computer and timing of the run (as in a simulation run), as well as optimisation information (something like ‘Hooke &amp; Jeeves algorithm ran for 1039 function evaluations’), the likelihood value at the end ‘1e+10’ and a reason for stopping (‘because the maximum number of function evaluations was reached’). You can also see from the timestamps above that this run took roughly 30 seconds, depending on the computer being used. Obviously, the default settings for optimisation (1000 function evaluations using the Hooke and Jeeves algorithm), are insufficient to find a reasonable optimum. Gadget can also take quite a while to optimise a model (~ 6 hours for ling on a very fast computer). Therefore, it is best to plan ahead of time on which computer and when a model will be optimised, as well as which optimisation methods will be used. To change from the default settings, an opimisation file needs to be provided to gadget_optimize via the control argument. This is the file we provide for demonstration: it shows that we have implemented 3 consecutive optimisation routines. The first begins with simulated annealing (and parameter settings needed for it as well as a seed), followed by a Hooke and Jeeves algorithm that begins where simulated annealing leaves off, and finally a BFGS algorithm. The three routines are listed in this manner to consecutively to transition from a broader global search (simulated annealing) to one that provides faster (Hooke and Jeeves) and more precise (BFGS) results, in an attempt to make the search more efficient. These three are the only algorithms currently implemented, but others are in a development phase. Also note that a seed is set in the beginning algorithm: it is good practice to both use random starting values as well as a set seed to check for possible optimisation problems. More information on parameters specific to each algorithm can be found in the Gadget User Guide. Each algorithm also has a low maximum number of iterations set in the optimisation file below, which is clearly not enough to be realistic: realistic values used for ling are given as notes within the optinfofile and are not read below. However, the each model presents new challenges to the search algorithm, so in some complex cases it may be necessary to rely mostly on simulating annealing, whereas in other more well-defined cases it may be possible to rely mostly on the faster algorithms. At this point in development, speeding Gadget runs is mostly done by using computers with multiple cores and faster processors. optinfo &lt;- read.gadget.file(&#39;data_provided&#39;, &#39;optinfofile&#39;) optinfo ## ; Generated by Rgadget 0.5 ## [simann] ## simanniter 200 ; number of simulated annealing iterations, normally set to 1000000 for ling ## simanneps 0.001 ; minimum epsilon, simann halt criteria ## t 30000000 ; simulated annealing initial temperature ## rt 0.85 ; temperature reduction factor ## nt 2 ; number of loops before temperature adjusted ## ns 5 ; number of loops before step length adjusted ## vm 1 ; initial value for the maximum step length ## cstep 2 ; step length adjustment factor ## lratio 0.3 ; lower limit for ratio when adjusting step length ## uratio 0.7 ; upper limit for ratio when adjusting step length ## check 4 ; number of temperature loops to check ## seed 5908 ## [hooke] ## hookeiter 100 ; number of hooke &amp; jeeves iterations, normally set to 40000 for ling ## hookeeps 1e-04 ; minimum epsilon, hooke &amp; jeeves halt criteria ## rho 0.5 ; value for the resizing multiplier ## lambda 0 ; initial value for the step length ## [bfgs] ## bfgsiter 100 ; number of bfgs iterations, normally set to 10000 for ling ## bfgseps 0.01 ; minimum epsilon, bfgs halt criteria ## sigma 0.01 ; armijo convergence criteria ## beta 0.3 ; armijo adjustment factor ## Here, we have implemented a fitting procedure that begins where the last default optimisation values left off (in the ‘params.init’ file). The ‘params.opt’ file will therefore be the result of a longer and more well-defined search as described by the ‘optinfofile’. timestamp() gadget_optimize(gd,params.in = &#39;params.in&#39;, params.out = &#39;params.init&#39;, control = optinfo) timestamp() 7.5.0.1 Exercise Try changing the parameter starting values to the params.forsim file within the ‘data_provided’ folder. Does the optimisation finish any quicker? 7.6 Using the iterative reweighting function to fit a Gadget statistical model The total objective function used the modeling process combines equations to using the following formula: \\[\\begin{equation}\\label{eq:loglik} l^{T} = \\sum_g w_{gf}^{SI} l_{g,S}^{SI} + \\sum_{f\\in \\{S,T,G,L\\}} \\left( w_{f}^{LD} l_{f}^{LD} + w_{f}^{AL} l_{f}^{AL}\\right) + w^{M}l^{M} \\end{equation}\\] where \\(f=S,T,G\\) or \\(L\\) denotes the spring survey, trawl, gillnet and longline fleets respectively and \\(w\\)’s are the weights assigned to each likelihood components. The weights, \\(w_i\\), are necessary for several reasons. First of all it is used to to prevent some components from dominating the likelihood function. When one data source dominates, the model fits that one exactly and ignores information from the other data sources. Another would be to reduce the effect of low quality data. It can be used as an a priori estimates of the variance in each subset of the data. Assigning likelihood weights is not a trivial matter; it has in the past been the most time-consuming part of developing a Gadget model. Historicall this was been done using some form of ‘expert judgement’. General heuristics have recently been developed to estimated these weights objectively. Here the iterative re–weighting heuristic introduced by @stefansson2003issues, and subsequently implemented in @taylor2007simple, is used. Rgadget implements this heuristing using the gadget.iterative function. The general idea behind the iterative re-weighting is to assign the inverse variance of the fitted residuals as component weights. This pattern suggests that the more variable the residuals are from a particular data source, the less weight it should receive. The variances, and hence the final weights, are calculated according the following algorithm: Calculate the initial sums of squares (SS) given the initial parameterization for all likelihood components. Assign the inverse SS as the initial weight for all likelihood components, resulting in a total initial score of 1 for each component. For each likelihood component, do an optimization run with the initial weighted SS for that component set to 10 000. This run represents a model fit where essentially only that component contributes to model fitting, and therefore that component receives the best fit achievable. Then estimate the residual variance using the resulting SS of that component divided by the degrees of freedom (\\(df^*\\)), i.e. \\(\\hat{\\sigma}^2 = \\frac{SS}{df^*}\\). After the optimization of each component separately, set the final weight for each component to be the inverse of the estimated variance from the step above (weight \\(=1/\\hat{\\sigma}^2\\)). The number of non-zero data-points (\\(df^{*}\\)) is used as a proxy for the degrees of freedom. While this may be a satisfactory proxy for larger data sets, it could be a gross overestimate of the degrees of freedom for smaller data sets. In particular, if the survey indices are weighed on their own while the annual recruitment is estimated, they could be over-fitted. In general, problem such as these can be solved with component grouping. Component grouping is achieved in step 2: likelihood components that should behave similarly, such as survey indices representing similar age ranges, are weighted and optimized together. The gadget.iterative function implements the iterative reweighting heuristic and is invoked in the following manner: ## In its current version, gadget.iterative needs to be run from within the ## directory that contains the Gadget model old &lt;- getwd() file.copy(sprintf(&#39;%s/optinfofile&#39;,&#39;data_provided&#39;),gd) ## [1] TRUE setwd(gd) ## run gadget iterative ## WARNING: Each time gadget.iterative runs with the given optinfofile, ## it takes 11 mins to run on a reasonably fast computer with 2 cores. timestamp() ## ##------ Tue Nov 17 16:59:46 2020 ------## run &lt;- gadget.iterative() timestamp() ## ##------ Tue Nov 17 17:03:07 2020 ------## This will start an iterative run that will estimate the weights for all likelihood components, and run a final optimisation run with the resulting likelihood weights. Penalising likelihood components, such as boundlikelihood and understocking, are left as is. As the iterative reweighting requires several optimisation runs, gadget.iterative tries to spread these runs across the available cores on your computer. In the case of the number of cores lower than the number of runs, the excess runs will wait until a core becomes available. The resulting parameter estimates are then stored in a folder called WGTS in your model directory, where the file params.final contains the final parameter estimate. When running gadget.iterative with standard setting you assume that all data sets have enough data to allow all parameters to be estimated without overfitting the data. It is not always the case that this is appropriate. For instance survey indices have in general only one data point per year, step and size group, and when estimating annual recruitment this usually leads overfitting of that particular component when heavily emphasized. Similar problem can arise when only one year, or a few disjoint years, worth of compositional data is supplied to the likelihood function. To account for this issue the user can group similar likelihood components together using the grouping argument in the gadget.iterative function. When estimating annual recruitment, for example, this ensures that at least two data points are available to estimate each of the recruitment parameters. In the case of Ling, the survey indices were split into two groups, sizes 20 to 72 cm and 72 to 160 cm, and the compositional data from the commercial trawl and gillnet fleets were grouped due to a low number of data points. Note that when rerunning gadget.reiterative, it is best for file management purposes to delete the old ‘WGTS’ folder before reruinning gadget.iterative, for example by running unlink(\"WGTS\", recursive=TRUE). Alternatively, if both sets of results should be kept, then the ‘WGTS’ folder should be renamed by changing the default argument wgts = 'WGTS'. This is especially important when visualizing model results in the next step using gadget.fit. run &lt;- gadget.iterative(grouping = list(sind1=c(&#39;si.len20&#39;,&#39;si.len52&#39;,&#39;si.len60&#39;), sind2=c(&#39;si.len72&#39;,&#39;si.len80&#39;,&#39;si.len92&#39;, &#39;si.len100&#39;), comm=c(&#39;ldist.gil&#39;,&#39;ldist.bmt&#39;, &#39;aldist.gil&#39;,&#39;aldist.bmt&#39;)), wgts = &#39;WGTS2&#39;) Note that if a likelihood component is not present in the defined grouping list it is assumed that the component is treated individually. Sometimes this is not enough to prevent overfitting and therefore the user can define a maximum weight of sorts by defining the minimum CV for survey indices used for weight assignment. This is done using the cv.floor argument: run &lt;- gadget.iterative(cv.floor = 0.2, wgts = &#39;WGTS3&#39;) The cv.floor argument is often used after the final optimisation run has crashed so it is convenient to be able to pick up the “thread” where the run crashed and resume the final optimisation. The resume.final switch allows for this and essentially only runs the last optimisation, thereby assuming that the preceding steps have been completed: run &lt;- gadget.iterative(resume.final = TRUE, cv.floor = 0.2, wgts = &#39;WGTS3&#39;) Related to resume.final there are the run.final and run.serial arguments that instruct the function to whether to run the final optimisation from the beginning and whether all optimisations should be run on a single core respectively. Note for Windows users: the user needs to explicitly define a cluster for gadget.iterative to run in parallel, see here for ways around this problem. In post-hoc analyses of the effect of certain data sources on model fitting, differential treatment of data is often investigated. For example, the effect of a certain dataset can be analysed by omitting it from the estimation or changing its grouping. gadget.iterative allows you to have multiple WGTS folders in the same model directory by setting the wgts argument. In addition the user can explicitly define (or remove) which component are to be used in the optimisation using a combination of the comp and inverse arguments: ## only want to fit to ldist.gil, all others discarded run &lt;- gadget.iterative(comp = &#39;ldist.gil&#39;, wgts = &#39;WGTS3&#39;) ## remove ldist.gil, all others kept run &lt;- gadget.iterative(comp = &#39;ldist.gil&#39;, inverse = TRUE, wgts = &#39;WGTS3&#39;) 7.7 Visualize Gadget statistical model fit To obtain information on the model fit and properties of the model, one can use the gadget.fit function to query the model and return conveniently structured output. Notice that there is a default argument in gadget.fit that matches gadget.reiterative: the wgts = 'WGTS' argument. This means that by default gadget.fit will load the reiterative results stored under ‘WGTS’, but this can be changed. Here we load results from the first run of gadget.iterative where no grouping was implemented. setwd(gd) # Make sure we are in gd first fit &lt;- gadget.fit() ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; theme_set(theme_light()) ## set the plot theme (optional) library(patchwork) ## optional packages scale_fill_crayola &lt;- function(n = 100, ...) { # taken from RColorBrewer::brewer.pal(12, &quot;Paired&quot;) pal &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) pal &lt;- rep(pal, n) ggplot2::scale_fill_manual(values = pal, ...) } The fit object is essentially a list of data.frames that contain the likelihood data merged with the model output. fit %&gt;% names() ## [1] &quot;sidat&quot; &quot;resTable&quot; &quot;nesTable&quot; ## [4] &quot;suitability&quot; &quot;stock.recruitment&quot; &quot;res.by.year&quot; ## [7] &quot;stomachcontent&quot; &quot;likelihoodsummary&quot; &quot;catchdist.fleets&quot; ## [10] &quot;stockdist&quot; &quot;SS&quot; &quot;stock.full&quot; ## [13] &quot;stock.std&quot; &quot;stock.prey&quot; &quot;fleet.info&quot; ## [16] &quot;predator.prey&quot; &quot;params&quot; &quot;catchstatistics&quot; and one can access those data.frames simply by calling their name: fit$sidat ## [90m# A tibble: 238 x 20[39m ## name year step area label number intercept slope sse stocknames sitype ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m ## [90m 1[39m si.l… [4m1[24m985 2 1 len1… 1.06[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 2[39m si.l… [4m1[24m986 2 1 len1… 1.50[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 3[39m si.l… [4m1[24m987 2 1 len1… 2.12[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 4[39m si.l… [4m1[24m988 2 1 len1… 2.92[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 5[39m si.l… [4m1[24m989 2 1 len1… 3.81[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 6[39m si.l… [4m1[24m990 2 1 len1… 4.67[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 7[39m si.l… [4m1[24m991 2 1 len1… 5.41[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 8[39m si.l… [4m1[24m992 2 1 len1… 5.99[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m 9[39m si.l… [4m1[24m993 2 1 len1… 6.49[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m10[39m si.l… [4m1[24m994 2 1 len1… 6.84[90me[39m6 -[31m11[39m[31m.[39m[31m7[39m 1 20.2 [90m&quot;[39mlingimm\\… lengt… ## [90m# … with 228 more rows, and 9 more variables: fittype [3m[90m&lt;chr&gt;[90m[23m, length [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# age [3m[90m&lt;lgl&gt;[90m[23m, survey [3m[90m&lt;lgl&gt;[90m[23m, fleet [3m[90m&lt;lgl&gt;[90m[23m, observed [3m[90m&lt;dbl&gt;[90m[23m, lower [3m[90m&lt;int&gt;[90m[23m,[39m ## [90m# upper [3m[90m&lt;int&gt;[90m[23m, predict [3m[90m&lt;dbl&gt;[90m[23m[39m For further information on what the relevant data.frames contain refer to the help page for gadget.fit. In addition a plot routine for the fit object is implement in Rgadget. The input to the plot function is simply the gadget.fit object, the data set one wants to plot and the type. The default plot is a survey index plot: plot(fit) To produce a likelihood summary: plot(fit,data=&#39;summary&#39;) A weighted summary plot: plot(fit,data=&#39;summary&#39;,type = &#39;weighted&#39;) and a pie chart of likelihood components: plot(fit,data=&#39;summary&#39;,type=&#39;pie&#39;) To plot the fit to catch proportions (either length or age) you simply do: tmp &lt;- plot(fit,data = &#39;catchdist.fleets&#39;) names(tmp) ## [1] &quot;aldist.bmt&quot; &quot;aldist.gil&quot; &quot;aldist.lln&quot; &quot;aldist.surv&quot; &quot;ldist.bmt&quot; ## [6] &quot;ldist.gil&quot; &quot;ldist.lln&quot; &quot;ldist.surv&quot; and then plot them one by one: tmp$aldist.surv tmp$ldist.surv One can also produce bubble plots bubbles &lt;- plot(fit,data = &#39;catchdist.fleets&#39;,type=&#39;bubble&#39;) names(bubbles) ## [1] &quot;ldist&quot; &quot;aldist&quot; Age bubbles bubbles$aldist Length bubbles bubbles$ldist One can also illustrate the fit to growth in the model: grplot &lt;- plot(fit,data = &#39;catchdist.fleets&#39;,type=&#39;growth&#39;) names(grplot) ## [1] &quot;aldist.bmt&quot; &quot;aldist.gil&quot; &quot;aldist.lln&quot; &quot;aldist.surv&quot; Illstrate the fit to the autumn survey grplot$aldist.surv And the fit to maturity data: plot(fit,data=&#39;stockdist&#39;) ## $matp.surv And selection by year and step plot(fit,data=&quot;suitability&quot;) Age age compostion plot(fit,data=&#39;stock.std&#39;) + scale_fill_crayola() And the standard ICES plots plot(fit,data=&#39;res.by.year&#39;,type=&#39;total&#39;) + theme(legend.position = &#39;none&#39;) + plot(fit,data=&#39;res.by.year&#39;,type=&#39;F&#39;) + theme(legend.position = &#39;none&#39;) + plot(fit,data = &#39;res.by.year&#39;,type=&#39;catch&#39;) + theme(legend.position = &#39;none&#39;) + plot(fit, data=&#39;res.by.year&#39;,type=&#39;rec&#39;) 7.7.0.1 Exercise Try plotting the catchabilities on the normal scale (exponentiated, not log as given) across ages for each survey. What shape are they when plotted? What information is stored under fit$SS? Try changing the grouping structure above to one that makes more sense to you. Do model results fit any better? "],["defining-multi-area-models.html", "8 Defining multi area models 8.1 Alternate structures: multiple areas", " 8 Defining multi area models 8.1 Alternate structures: multiple areas Let’s return to the initial set-up of the ling model and modify it such that the stock live on two areas. The first step to do this is to modify the area file and stock files to include a second area. library(Rgadget) library(tidyverse) #assuming you are beginning in a fresh session; this information should be in an #initialization script base_dir &lt;- &#39;ling_model&#39; vers &lt;- c(&#39;01-base&#39;) gd &lt;- gadget.variant.dir(sprintf(paste0(&quot;%s/&quot;,vers),base_dir)) ling.imm &lt;- gadgetstock(&#39;lingimm&#39;,gd) ling.mat &lt;- gadgetstock(&#39;lingmat&#39;,gd) #area_file &lt;- read.gadget.file(gd, &#39;Modelfiles/area&#39;, file_type = &#39;area&#39;) ## Write out areafile and update mainfile with areafile location schedule &lt;- expand.grid(year = 1982:2018, step = 1:4, area = 1:2) %&gt;% arrange(year, step, area) area_file &lt;- gadgetfile(&#39;Modelfiles/area&#39;, file_type = &#39;area&#39;, components = list(list(areas = c(1,2), size = c(1,1), temperature= schedule %&gt;% mutate(temperature = 5)))) area_file %&gt;% write.gadget.file(gd) ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;stock&#39;, livesonareas = area_file[[1]]$areas) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;stock&#39;, livesonareas = area_file[[1]]$areas) ling.imm ## ; Generated by Rgadget 0.5 ## stockname lingimm ## livesonareas 1 2 ## minage 3 ## maxage 10 ## minlength 20 ## maxlength 160 ## dl 4 ## refweightfile Modelfiles/lingimm.refwgt ## growthandeatlengths Aggfiles/lingimm.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #ling.Linf (* 0.001 #ling.k) #ling.walpha #ling.wbeta ## beta (* 10 #ling.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M #lingimm.M ## iseaten 1 ## preylengths Aggfiles/lingimm.stock.len.agg ## energycontent 1 ## doeseat 0 ## initialconditions ## minage 3 ## maxage 10 ## minlength 20 ## maxlength 160 ## dl 4 ## normalparamfile Modelfiles/lingimm.init.normalparam ## doesmigrate 0 ## doesmature 1 ## maturityfunction continuous ## maturityfile Modelfiles/lingimm.maturity ## doesmove 1 ## transitionstocksandratios lingmat 1 ## transitionstep 4 ## doesrenew 1 ## minlength 20 ## maxlength 160 ## dl 4 ## normalparamfile Modelfiles/lingimm.rec.normalparam ## doesspawn 0 ## doesstray 0 In theory, the only details left that are necessary to set up a two-area model is to provide initial values and recruitment, as these are designated both by area and age combinations: #taken from data analyses init.sigma.i &lt;- rep(2, length(ling.imm[[1]]$minage:ling.imm[[1]]$maxage)) init.sigma.m &lt;- rep(2, length(ling.mat[[1]]$minage:ling.mat[[1]]$maxage)) ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = expand.grid(age = ling.imm[[1]]$minage:ling.imm[[1]]$maxage, area = area_file[[1]]$areas) %&gt;% as_tibble() %&gt;% mutate( age.factor = parse(text=sprintf(&#39;exp(-1*(lingimm.M+ling.init.F)*%1$s)*lingimm.init.%1$s&#39;,age)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), area.factor = &#39;#lingimm.init.scalar&#39;, mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = rep(init.sigma.i,2), alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39; ) ) %&gt;% gadget_update(&#39;doesrenew&#39;, normalparam = expand.grid(year = schedule$year,area = area_file[[1]]$areas) %&gt;% distinct() %&gt;% as_tibble() %&gt;% mutate(step = 1, age = ling.imm[[1]]$minage, number = parse(text=sprintf(&#39;ling.rec.scalar*ling.rec.%s&#39;,year)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = &#39;#ling.rec.sd&#39;, alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39; ) ) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = expand.grid(age = ling.mat[[1]]$minage:ling.mat[[1]]$maxage, area = area_file[[1]]$areas) %&gt;% as_tibble() %&gt;% mutate( age.factor = parse(text=sprintf(&#39;exp(-1*(lingmat.M+ling.init.F)*%1$s)*lingmat.init.%1$s&#39;,age)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), area.factor = &#39;#lingmat.init.scalar&#39;, mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = rep(init.sigma.m,2), alpha = &#39;#lingmat.walpha&#39;, beta = &#39;#lingmat.wbeta&#39; ) ) ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) The only changes added to the above model were to add a second area with the same exact values in initial conditions and recruitment as found in the previous model with only a single area. The second area is therefore a simulated mirror of the first, but with no fishing, as the fleets only exist on area 1. Structurally, this is the minimum possible information needed to include a second area. gadget_evaluate(gd,log = &#39;log_area2&#39;) 8.1.1 Migration A model as shown in the previous section may be useful for theoretical simulations, otherwise it is not particularly interesting, and has no effect on what goes on in area 1, including the model fitting procedures (as data are specified by area). A slightly more interesting model could be a single population in two areas that can interact between areas via migration, which determines how much the individuals move among areas. Migration is specified in the stock file under the migration section, and is therefore updated first by indicating that migration exists by turning the doesmigrate option from 0 to 1, and providing a migration matrix or migration ratios (two forms of the same information). In Rgadget, this can be done by creating a migration matrix file and using gadget_update to modify the migration component of the stock file to refer to this file. A migration matrix is a square n x n matrix for the n areas that the stock is defined on with proportions moving from each area given in columns to the area given in rows. Migration should not change the total number of fish in the model, so each column in the migration matrix should sum to 1. Therefore in the following example, at the start of migration, 60% of individuals in area 1 remain there, 40% move to area 2. Likewise, 30% of individuals in area 2 move to area 1, whereas 70% remain there: matrix(c(0.6, 0.4, 0.3, 0.7), nrow = 2) ## [,1] [,2] ## [1,] 0.6 0.3 ## [2,] 0.4 0.7 An alternate method for supplying these values is via migration ratios, which instead lists only the proportions of fish moving, and lets Gadget calculate the full matrix from those. To represent the above matrix in this form, we would write: matrix(c(1,2,0.4,2,1,0.3), nrow = 2, byrow = T) ## [,1] [,2] [,3] ## [1,] 1 2 0.4 ## [2,] 2 1 0.3 In this form, within each row, the first column shows the origin area, the second the destination area, and the third the proportion. Note that migrations of 0% are calculated automatically, so they should be omitted. In this example we continue with the migration ratios format. Ratios can be replaced with switches that are specified in the parameters file, and the matrix can be placed into a Gadget file with the necessary name and keyword [migrationmatrix] using gadgetfile: tmp.mat &lt;- matrix(c(1,2,0.4,2,1,&#39;#mig&#39;), nrow = 2, byrow = T) #produce a migration matrix gadgetfile(&#39;Modelfiles/migration&#39;, components = list(migrationmatrix = list( name = &#39;test&#39;, as.list(tmp.mat[1,]), as.list(tmp.mat[2,]) ) ) ) ## ; Generated by Rgadget 0.5 ## [migrationmatrix] ## name test ## 1 2 0.4 ## 2 1 #mig Each migration file can include a series of migrations, but note that the order of evaluation of these affects the ratios that should be written. For example, suppose we have 1000 fish in each area, and we want to represent the situation that 30% of the fish in area 1 will move to area 2 in time step 1, and the same ratio will migrate to area 1 from 2 in time step 2. We would write the following: tmp.mat.w &lt;- matrix(c(1,2,0.3), nrow = 1, byrow = T) tmp.mat.e &lt;- matrix(c(2,1,0.3), nrow = 1, byrow = T) mig_file &lt;- gadgetfile(&#39;Modelfiles/migration&#39;, components = list(migrationmatrix = list( name = &#39;west&#39;, as.list(tmp.mat.w[1,]) ), migrationmatrix =list( name = &#39;east&#39;, as.list(tmp.mat.e[1,]) ) ) ) mig_file ## ; Generated by Rgadget 0.5 ## [migrationmatrix] ## name west ## 1 2 0.3 ## [migrationmatrix] ## name east ## 2 1 0.3 This indicates that 300 fish will move from area 1 to 2 in step 1, and then subsequently 0.3 x 1300 = 390 fish will move from area 2 to area 1. It does not mean that 300 fish will move back, or that these fish are the same individuals that moved in step 1. For this pattern a different model structure (with a new stock) is needed, so that those 300 individuals can be tracked separately. For our purposes, let’s set the migration proportions to switches: tmp.mat.w &lt;- matrix(c(1,2,&#39;#ling.mig.w&#39;), nrow = 1, byrow = T) tmp.mat.e &lt;- matrix(c(2,1,&#39;#ling.mig.e&#39;), nrow = 1, byrow = T) mig_file &lt;- gadgetfile(&#39;Modelfiles/migration&#39;, components = list(migrationmatrix = list( name = &#39;west&#39;, as.list(tmp.mat.w[1,]) ), migrationmatrix =list( name = &#39;east&#39;, as.list(tmp.mat.e[1,]) ) ) ) mig_file %&gt;% write.gadget.file(gd) mig_file ## ; Generated by Rgadget 0.5 ## [migrationmatrix] ## name west ## 1 2 #ling.mig.w ## [migrationmatrix] ## name east ## 2 1 #ling.mig.e Although in the above example we have time steps for migration in mind, we have not yet designated them in a Gadget file. To do this, the next step is to create a migration timing file: gadgetfile(&#39;Modelfiles/migrationtime&#39;, file_type = &#39;data&#39;, components = list(bind_rows( tibble(year = schedule$year %&gt;% unique, step = 2, defineratios=&#39;east&#39;), tibble(year = schedule$year %&gt;% unique, step = 1, defineratios=&#39;west&#39;) ))) %&gt;% write.gadget.file(gd) Finally, we modify the stock files for the stocks that should use this migration matrix and time files: ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;doesmigrate&#39;, yearstepfile = &#39;Modelfiles/migrationtime&#39;, defineratios = &#39;Modelfiles/migration&#39;) ling.mat &lt;- ling.mat%&gt;% gadget_update(&#39;doesmigrate&#39;, yearstepfile = &#39;Modelfiles/migrationtime&#39;, defineratios = &#39;Modelfiles/migration&#39;) ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) ling.mat ## ; Generated by Rgadget 0.5 ## stockname lingmat ## livesonareas 1 2 ## minage 5 ## maxage 15 ## minlength 20 ## maxlength 160 ## dl 4 ## refweightfile Modelfiles/lingmat.refwgt ## growthandeatlengths Aggfiles/lingmat.stock.len.agg ## doesgrow 1 ## growthfunction lengthvbsimple ## growthparameters #ling.Linf (* 0.001 #ling.k) #ling.walpha #ling.wbeta ## beta (* 10 #ling.bbin) ## maxlengthgroupgrowth 15 ## naturalmortality #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M #lingmat.M ## iseaten 1 ## preylengths Aggfiles/lingmat.stock.len.agg ## energycontent 1 ## doeseat 0 ## initialconditions ## minage 5 ## maxage 15 ## minlength 20 ## maxlength 160 ## dl 4 ## normalparamfile Modelfiles/lingmat.init.normalparam ## doesmigrate 1 ## yearstepfile Modelfiles/migrationtime ## defineratios Modelfiles/migration ## doesmature 0 ## doesmove 0 ## doesrenew 0 ## doesspawn 0 ## doesstray 0 gadget_evaluate(gd,log = &#39;log_area2&#39;) 8.1.2 Using data from multiple areas It is also possible to fit a Gadget model using area-specific data. If data are available from both areas, then there must be fleets operating in both areas, so the first step is to modify the fleets. This is easily done in Rgadget by including catch data from both areas and including area 2 in the attributes: lln.landings &lt;- structure( bind_rows(read_csv(&#39;data_provided/lln.csv&#39;), read_csv(&#39;data_provided/lln.csv&#39;) %&gt;% mutate(area=2, total_weight = round(total_weight*rlnorm(n(), sdlog = 0.5))) %&gt;% filter(total_weight &gt; 0)), area_group = list(`1` = 1, `2` = 2)) bmt.landings &lt;- structure( bind_rows(read_csv(&#39;data_provided/bmt.csv&#39;), read_csv(&#39;data_provided/bmt.csv&#39;) %&gt;% mutate(area=2, total_weight = round(total_weight*rlnorm(n(), sdlog = 0.5))) %&gt;% filter(total_weight &gt; 0)), area_group = list(`1` = 1, `2` = 2)) gil.landings &lt;- structure( bind_rows(read_csv(&#39;data_provided/gil.csv&#39;), read_csv(&#39;data_provided/gil.csv&#39;) %&gt;% mutate(area=2, total_weight = round(total_weight*rlnorm(n(), sdlog = 0.5))) %&gt;% filter(total_weight &gt; 0)), area_group = list(`1` = 1, `2` = 2)) for.landings &lt;- structure( bind_rows(read_csv(&#39;data_provided/for.csv&#39;), read_csv(&#39;data_provided/for.csv&#39;) %&gt;% mutate(area=2, total_weight = round(total_weight*rlnorm(n(), sdlog = 0.5))) %&gt;% filter(total_weight &gt; 0)), area_group = list(`1` = 1, `2` = 2)) surv.landings &lt;- structure( bind_rows(read_csv(&#39;data_provided/surv.csv&#39;), read_csv(&#39;data_provided/surv.csv&#39;) %&gt;% mutate(area=2)), area_group = list(`1` = 1, `2` = 2)) lln.landings ## [90m# A tibble: 200 x 4[39m ## year step area total_weight ## [90m*[39m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m1[24m994 1 1 [4m2[24m[4m3[24m[4m2[24m073 ## [90m 2[39m [4m1[24m994 2 1 [4m6[24m[4m3[24m300 ## [90m 3[39m [4m1[24m994 3 1 [4m2[24m[4m3[24m[4m0[24m816 ## [90m 4[39m [4m1[24m994 4 1 [4m4[24m[4m6[24m[4m5[24m965 ## [90m 5[39m [4m1[24m995 1 1 [4m3[24m[4m5[24m[4m1[24m216 ## [90m 6[39m [4m1[24m995 2 1 [4m1[24m[4m5[24m[4m8[24m494 ## [90m 7[39m [4m1[24m995 3 1 [4m1[24m[4m9[24m[4m2[24m527 ## [90m 8[39m [4m1[24m995 4 1 [4m6[24m[4m1[24m[4m7[24m108 ## [90m 9[39m [4m1[24m996 1 1 [4m5[24m[4m1[24m[4m6[24m931 ## [90m10[39m [4m1[24m996 2 1 [4m2[24m[4m8[24m[4m5[24m695 ## [90m# … with 190 more rows[39m surv.landings ## [90m# A tibble: 74 x 4[39m ## year step area number ## [90m*[39m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m [4m1[24m982 2 1 1 ## [90m 2[39m [4m1[24m983 2 1 1 ## [90m 3[39m [4m1[24m984 2 1 1 ## [90m 4[39m [4m1[24m985 2 1 1 ## [90m 5[39m [4m1[24m986 2 1 1 ## [90m 6[39m [4m1[24m987 2 1 1 ## [90m 7[39m [4m1[24m988 2 1 1 ## [90m 8[39m [4m1[24m989 2 1 1 ## [90m 9[39m [4m1[24m990 2 1 1 ## [90m10[39m [4m1[24m991 2 1 1 ## [90m# … with 64 more rows[39m Then when these catch data are included in the fleet files, the areas of operation with the fleets will be automatically updated. The current Rgadget version cannot update fleet components separately, so here we rewrite the entire fleet file the same way we did on day 2. gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;totalfleet&#39;, livesonareas = c(1,2), name = &#39;surv&#39;, suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.surv.alpha&#39;, beta = &#39;#ling.surv.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.surv.alpha&#39;, beta = &#39;#ling.surv.l50&#39;)), data = surv.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;lln&#39;, livesonareas = c(1,2), suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;)), data = lln.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;bmt&#39;, livesonareas = c(1,2), suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.bmt.alpha&#39;, beta = &#39;#ling.bmt.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.bmt.alpha&#39;, beta = &#39;#ling.bmt.l50&#39;)), data = bmt.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;gil&#39;, livesonareas = c(1,2), suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.gil.alpha&#39;, beta = &#39;#ling.gil.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.gil.alpha&#39;, beta = &#39;#ling.gil.l50&#39;)), data = gil.landings) %&gt;% gadget_update(&#39;totalfleet&#39;, name = &#39;foreign&#39;, livesonareas = c(1,2), suitability = list(lingimm = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;), lingmat = list(type=&#39;function&#39;,suit_func=&#39;exponentiall50&#39;, alpha = &#39;#ling.lln.alpha&#39;, beta = &#39;#ling.lln.l50&#39;)), data = for.landings) %&gt;% write.gadget.file(gd) Now that there are fleets fishing on area 2 with catches removed, it is possible for biological samples to be generated from area 2. Because all fish in the model, whether they belong to the area 1 or 2, belong to the same stocks (immature or mature), they all need to conform to the same stock-related processes, such as growth, maturation, and selectivity of a fleet as it fishes that stock. Different stocks would be necessary to change these by area. However, because initial conditions and recruitment are area-specific, they can be set with different values or switches. Previously we had written the same parameters for both areas, resulting in mirror images; here we change these parameters to be area-specific. Also remember that catchability is also estimated separately by area in relation to survey indices. ling.imm &lt;- ling.imm %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = expand.grid(age = ling.imm[[1]]$minage:ling.imm[[1]]$maxage, area = area_file[[1]]$areas) %&gt;% as_tibble() %&gt;% mutate( age.factor = parse(text=sprintf(&#39;exp(-1*(lingimm.M+ling.init.F)*%1$s)*lingimm.init.%1$s&#39;,age)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), area.factor = sprintf(&#39;#lingimm.init.scalar.%1$s&#39;,area), mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = rep(init.sigma.i,2), alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39; ) ) %&gt;% gadget_update(&#39;doesrenew&#39;, normalparam = expand.grid(year = schedule$year,area = area_file[[1]]$areas) %&gt;% distinct() %&gt;% as_tibble() %&gt;% mutate(step = 1, age = ling.imm[[1]]$minage, number = parse(text=sprintf(&#39;ling.rec.scalar*ling.rec.%1$s.%2$s&#39;,year,area)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = &#39;#ling.rec.sd&#39;, alpha = &#39;#ling.walpha&#39;, beta = &#39;#ling.wbeta&#39; ) ) ling.mat &lt;- ling.mat %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = expand.grid(age = ling.mat[[1]]$minage:ling.mat[[1]]$maxage, area = area_file[[1]]$areas) %&gt;% as_tibble() %&gt;% mutate( age.factor = parse(text=sprintf(&#39;exp(-1*(lingmat.M+ling.init.F)*%1$s)*lingmat.init.%1$s&#39;,age)) %&gt;% map(to.gadget.formulae) %&gt;% unlist(), area.factor = sprintf(&#39;#lingmat.init.scalar.%1$s&#39;,area), mean = von_b_formula(age,linf=&#39;ling.Linf&#39;,k=&#39;ling.k&#39;,recl=&#39;ling.recl&#39;), stddev = rep(init.sigma.m,2), alpha = &#39;#lingmat.walpha&#39;, beta = &#39;#lingmat.wbeta&#39; ) ) ## write to file ling.imm %&gt;% write.gadget.file(gd) ling.mat %&gt;% write.gadget.file(gd) Finally, these data can be used to rewrite the likelihood function. lik &lt;- gadgetlikelihood(&#39;likelihood&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.surv&quot;, weight = 1, data = ldist.surv, fleetnames = c(&quot;surv&quot;), stocknames =c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.surv&quot;, weight = 1, data = aldist.surv, fleetnames = c(&quot;surv&quot;), stocknames =c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.lln&quot;, weight = 1, data = ldist.lln, fleetnames = c(&quot;lln&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.lln&quot;, weight = 1, data = aldist.lln, fleetnames = c(&quot;lln&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.gil&quot;, weight = 1, data = ldist.gil, fleetnames = c(&quot;gil&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.gil&quot;, weight = 1, data = aldist.gil, fleetnames = c(&quot;gil&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;ldist.bmt&quot;, weight = 1, data = ldist.bmt, fleetnames = c(&quot;bmt&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;catchdistribution&quot;, name = &quot;aldist.bmt&quot;, weight = 1, data = aldist.bmt, fleetnames = c(&quot;bmt&quot;), stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;stockdistribution&quot;, name = &quot;matp.surv&quot;, weight = 1, data = matp.surv, fleetnames = c(&quot;surv&quot;), stocknames =c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[1]), weight = 1, data = SI1, fittype = &#39;loglinearfit&#39;, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[2]), weight = 1, data = SI2, fittype = &#39;loglinearfit&#39;, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[3]), weight = 1, data = SI3, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[4]), weight = 1, data = SI4, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[5]), weight = 1, data = SI5, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[6]), weight = 1, data = SI6, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;)) %&gt;% gadget_update(&quot;surveyindices&quot;, name = paste0(&quot;si.&quot;, names(slices)[7]), weight = 1, data = SI7, fittype = &#39;fixedslopeloglinearfit&#39;, slope=1, stocknames = c(&quot;lingimm&quot;,&quot;lingmat&quot;))%&gt;% gadget_update(&quot;penalty&quot;, name = &quot;bounds&quot;, weight = &quot;0.5&quot;, data = data.frame( switch = c(&quot;default&quot;), power = c(2), upperW=10000, lowerW=10000, stringsAsFactors = FALSE)) %&gt;% gadget_update(&quot;understocking&quot;, name = &quot;understocking&quot;, weight = &quot;100&quot;) lik %&gt;% write.gadget.file(gd) 8.1.2.1 Exercise Now that the area model is set up with new parameters and area structure, 1) use callGadget to create a new parameters file, 2) use init_guess to set bounds and initial starting values of all parameters in the new parameters file, and 3) use callGadget again to take create another parameter file that contains reasonable starting values for a longer Gadget optimization run, and use 4) gadget.reiterative to create a final model run with decent weights among data sources. If you are not sure where to start, look back at the procedure in day 3. Now run gadget.fit on the results and create model fit figures that are area-specific. ## [1] &quot;ling_model/01-base&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; ## [90m# A tibble: 122 x 5[39m ## switch value lower upper optimise ## [90m*[39m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ling.Linf 160 1.00[90me[39m+ 2 200 1 ## [90m 2[39m ling.k 90 4.00[90me[39m+ 1 100 1 ## [90m 3[39m ling.walpha 0.000[4m0[24m[4m0[24m[4m2[24m28 1.00[90me[39m[31m-10[39m 1 0 ## [90m 4[39m ling.wbeta 3.2 2.00[90me[39m+ 0 4 0 ## [90m 5[39m ling.bbin 6 1.00[90me[39m[31m- 8[39m 100 1 ## [90m 6[39m lingimm.M 0.15 1.00[90me[39m[31m- 3[39m 1 0 ## [90m 7[39m lingimm.init.scalar.1 200 1.00[90me[39m+ 0 300 1 ## [90m 8[39m lingimm.init.scalar.2 200 1.00[90me[39m+ 0 300 1 ## [90m 9[39m ling.init.F 0.4 1.00[90me[39m[31m- 1[39m 1 1 ## [90m10[39m lingimm.init.3 1 1.00[90me[39m[31m- 3[39m [4m1[24m000 1 ## [90m# … with 112 more rows[39m ## [1] &quot;ling_model/01-base&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; ## ##------ Tue Nov 17 17:05:00 2020 ------## ## ##------ Tue Nov 17 17:11:44 2020 ------## ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; "],["marine-mammals.html", "9 Marine mammals", " 9 Marine mammals Marine mammals, like fish populations, can be modelled using the Gadget framework, although some caveats in the population population dynamics need to be considered. These include: Slower reproduction rate Growth in size typically reaches a plateau early compared when whaling occurs. Longer lifespans Less data … "],["setting-up-a-model-for-a-hypothetical-whale-stock.html", "10 Setting up a model for a hypothetical whale stock", " 10 Setting up a model for a hypothetical whale stock As usual we will start by setting up a Gadget model directory: gd &lt;- gadget.variant.dir(&#39;whale-model&#39;) and typically we are working with a longer time horizon for whales: schedule &lt;- expand.grid(year = 1880:2020, step = 1:4) %&gt;% arrange(year) gadgetfile(&#39;Modelfiles/time&#39;, file_type = &#39;time&#39;, components = list(list(firstyear = min(schedule$year), firststep=1, lastyear=max(schedule$year), laststep=4, notimesteps=c(4,3,3,3,3)))) %&gt;% ## number of time steps and step length in months write.gadget.file(gd) and they migrate between multiple jurisdictions so let’s add areas to the model: gadgetfile(&#39;Modelfiles/area&#39;, file_type = &#39;area&#39;, components = list(list(areas = 1:5, size = rep(1,5), temperature = schedule %&gt;% expand(year,step, area = 1:5, temperature = 5) %&gt;% arrange(year,step,area)))) %&gt;% write.gadget.file(gd) To mimic the population dynamics we need to split each stock into two stock components, males and females: You need to know the initial number at age when at carrying capacity. \\[ N_{a0} = N_0 e^{-aM}\\] where \\[ K = \\sum_a N_{a0} = N_0 \\frac{1-e^{-aM}}{1-e^{-M}}\\] so \\[N_0 = K\\frac{1-e^{-M}}{1-e^{-aM}}\\] so in the initial conditions we will specify the age factor to be \\(e^{-aM}\\) and the area factor as \\(N_0\\). lw.constants &lt;- list(estimate=c(0.001, 3)) ## arbitrary lw coeffs init.sigma &lt;- list(ms=rep(50, 41)) whale_m &lt;- gadgetstock(&#39;whale_m&#39;,gd, missingOkay = TRUE) %&gt;% gadget_update(&#39;stock&#39;, livesonareas = 1:5, minage = 0, maxage = 40, minlength = 50, maxlength = 1000, dl = 50) %&gt;% gadget_update(&#39;iseaten&#39;, 1) %&gt;% #gadget_update(&#39;naturalmortality&#39;, sprintf(&quot;#%s.M.%s&quot;, .[[1]]$stockname, .[[1]]$minage:.[[1]]$maxage)) %&gt;% gadget_update(&#39;doesgrow&#39;, ## note to self the order of these parameters make difference growthparameters=c(linf=&#39;#whale_m.Linf&#39;, k=to.gadget.formulae(quote(0.001*whale_m.k)), alpha = &#39;#whale_m.walpha&#39;, beta = &#39;#whale_m.wbeta&#39;), maxlengthgroupgrowth = 2, beta = to.gadget.formulae(quote(10*whale.bbin))) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = .[[1]]$minage:.[[1]]$maxage, area = 1, age.factor = parse(text=sprintf(&#39;exp(-1*(whale_m.M+whale_m_init.F)*%1$s)&#39;,age)) %&gt;% purrr::map(to.gadget.formulae) %&gt;% unlist(), area.factor = to.gadget.formulae(quote(prop_m*whale_k*(1-exp(-whale_m.M))/(1-exp(-40*whale_m.M)))), mean = von_b_formula(age,linf=&#39;whale_m.Linf&#39;,k=&#39;whale_m.k&#39;,recl=&#39;whale_m.recl&#39;), stddev = init.sigma$ms[age+1], alpha = &#39;#whale_m.walpha&#39;, beta = &#39;#whale_m.wbeta&#39;) %&gt;% bind_rows(expand_grid(age = 0:40,area=2:5,age.factor=&#39;0&#39;,area.factor=&#39;0&#39;) %&gt;% mutate(mean = von_b_formula(age,linf=&#39;whale_m.Linf&#39;,k=&#39;whale_m.k&#39;,recl=&#39;whale_m.recl&#39;), stddev = init.sigma$ms[age+1], alpha = &#39;#whale_m.walpha&#39;, beta = &#39;#whale_m.wbeta&#39;))) %&gt;% gadget_update(&#39;refweight&#39;, data=tibble(length=seq(.[[1]]$minlength,.[[1]]$maxlength,.[[1]]$dl), mean=lw.constants$estimate[1]*length^lw.constants$estimate[2])) whale_f &lt;- gadgetstock(&#39;whale_f&#39;,gd, missingOkay = TRUE) %&gt;% gadget_update(&#39;stock&#39;, livesonareas = 1:5, minage = 0, maxage = 40, minlength = 50, maxlength = 1200, dl = 50) %&gt;% gadget_update(&#39;iseaten&#39;, 1) %&gt;% #gadget_update(&#39;naturalmortality&#39;, sprintf(&quot;#%s.M.%s&quot;, .[[1]]$stockname, .[[1]]$minage:.[[1]]$maxage)) %&gt;% gadget_update(&#39;doesgrow&#39;, ## note to self the order of these parameters make difference growthparameters=c(linf=&#39;#whale_f.Linf&#39;, k=to.gadget.formulae(quote(0.001*whale_f.k)), alpha = &#39;#whale_f.walpha&#39;, beta = &#39;#whale_f.wbeta&#39;), maxlengthgroupgrowth = 2, beta = to.gadget.formulae(quote(10*whale.bbin))) %&gt;% gadget_update(&#39;initialconditions&#39;, normalparam = tibble(age = .[[1]]$minage:.[[1]]$maxage, area = 1, age.factor = parse(text=sprintf(&#39;exp(-1*(whale_f.M+whale_f_init.F)*%1$s)&#39;,age)) %&gt;% purrr::map(to.gadget.formulae) %&gt;% unlist(), area.factor = to.gadget.formulae(quote((1-prop_m)*whale_k*(1-exp(-whale_f.M))/(1-exp(-40*whale_f.M)))), mean = von_b_formula(age,linf=&#39;whale_f.Linf&#39;,k=&#39;whale_f.k&#39;,recl=&#39;whale_f.recl&#39;), stddev = init.sigma$ms[age+1], alpha = &#39;#whale_f.walpha&#39;, beta = &#39;#whale_f.wbeta&#39;) %&gt;% bind_rows(expand_grid(age = 0:40,area=2:5,age.factor=&#39;0&#39;,area.factor=&#39;0&#39;) %&gt;% mutate(mean = von_b_formula(age,linf=&#39;whale_f.Linf&#39;,k=&#39;whale_f.k&#39;,recl=&#39;whale_f.recl&#39;), stddev = init.sigma$ms[age+1], alpha = &#39;#whale_f.walpha&#39;, beta = &#39;#whale_f.wbeta&#39;))) %&gt;% gadget_update(&#39;refweight&#39;, data=tibble(length=seq(.[[1]]$minlength,.[[1]]$maxlength,.[[1]]$dl), mean=lw.constants$estimate[1]*length^lw.constants$estimate[2])) This sets up two stock, male and female part of the stocks. Two important parts remain in the population dynamics to capture what is needed, migration and births. Let’s start with the birth function. Only females give birth so the birth process only applies to that stock: whale_f &lt;- whale_f %&gt;% gadget_update(&quot;doesspawn&quot;, spawnsteps = 1, spawnareas = 1, firstspawnyear = 1881, spawnstocksandratios = list(stock1 = &quot;whale_f&quot;, ratio1 = 0.5, stock2 = &#39;whale_m&#39;, ratio2 = 0.5), proportionfunction = list(sel_func = &#39;constant&#39;, alpha = 1), mortalityfunction = list(sel_func = &#39;constant&#39;, alpha = 0), weightlossfunction = list(sel_func = &#39;constant&#39;, alpha = 0), recruitment = list(spawn_function = &#39;baleen&#39;, num_births = &#39;#whale_num_births&#39;, resil_a = &#39;#whale_resil.a&#39;, ## everything is in multiples of 1e4 K = to.gadget.formulae(quote(whale_k*1e4)), z = &#39;#whale_z&#39;), stockparameters = list(mean = &#39;#whale_f.recl&#39;, stddev = &#39;#whale_f.recsd&#39;, alpha = &#39;#whale_f.walpha&#39;, beta = &#39;#whale_f.wbeta&#39;)) Migratio: area 1 is a spawning area, areas 2 to 5 are feeding areas. whale_f &lt;- whale_f %&gt;% gadget_update(&#39;doesmigrate&#39;, yearstepfile = &#39;Modelfiles/migrationtime&#39;, defineratios = &#39;Modelfiles/migration&#39;) %&gt;% write.gadget.file(gd) whale_m &lt;- whale_m %&gt;% gadget_update(&#39;doesmigrate&#39;, yearstepfile = &#39;Modelfiles/migrationtime&#39;, defineratios = &#39;Modelfiles/migration&#39;) %&gt;% write.gadget.file(gd) Let’s define the migration matricies from spaning to feeding areas: feeding_migration &lt;- tibble(from = 1, to = 2:5, prop = sprintf(&#39;#feed_area_prop.%s&#39;,to)) spawn_migration &lt;- tibble(from = 2:5, to = 1, prop = 1) no_migration &lt;- &quot;&quot; gadgetfile(&#39;Modelfiles/migration&#39;, components = list(migrationmatrix = list( name = &#39;feeding&#39;, feeding_migration %&gt;% unite(tmp,from:prop,sep = &quot; &quot;) %&gt;% .$tmp %&gt;% paste(collapse = &#39;\\n\\t&#39;)), migrationmatrix =list( name = &#39;spawning&#39;, spawn_migration %&gt;% unite(tmp,from:prop,sep = &quot; &quot;) %&gt;% .$tmp %&gt;% paste(collapse = &#39;\\n\\t&#39;)), migrationmatrix = list(name = &#39;stay_put&#39;, no_migration) )) %&gt;% write.gadget.file(gd) and the schedule when each matrix is used: gadgetfile(&#39;Modelfiles/migrationtime&#39;, file_type = &#39;data&#39;, components = list(schedule %&gt;% #filter(step %in% c(1,2)) %&gt;% ## migration occurs at the beginning of the timestep mutate(defineratios = case_when(step == 2~&#39;feeding&#39;, step == 1~&#39;spawning&#39;, TRUE~&#39;stay_put&#39;)))) %&gt;% write.gadget.file(gd) Setting up fleets with random numbers whale_catch &lt;- schedule %&gt;% mutate(area = 3, number = rbinom(n(),50,runif(n())), number = ifelse(step == 1, 0, number)) whale_catch &lt;- structure(whale_catch,area_group = list(`3`= 3)) gadgetfleet(&#39;Modelfiles/fleet&#39;,gd,missingOkay = TRUE) %&gt;% gadget_update(&#39;numberfleet&#39;, name = &#39;whale_fleet&#39;, livesonareas = 3, suitability = list(whale_m=list(type=&#39;function&#39;,suit_func = &#39;exponentiall50&#39;,alpha = &quot;#whale_fleet.alpha&quot;, l50 = &quot;#whale_fleet.l50&quot;), whale_f=list(type=&#39;function&#39;,suit_func = &#39;exponentiall50&#39;,alpha = &quot;#whale_fleet.alpha&quot;, l50 = &quot;#whale_fleet.l50&quot;)), data = whale_catch) -&gt; tmp tmp$component$livesonareas &lt;- 3 # weird bug tmp$component$amount$data$area &lt;- 3 tmp %&gt;% write.gadget.file(gd) 10.0.1 Run Gadget and set initial parameters gadget_evaluate(gd, log = &#39;init.log&#39;) ## [1] &quot;whale-model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; read.gadget.parameters(paste(gd,&#39;params.out&#39;,sep=&#39;/&#39;)) %&gt;% init_guess(&#39;_f.Linf&#39;,1100,lower = 800, upper = 1400, optimise = 1) %&gt;% init_guess(&#39;_m.Linf&#39;,900,lower = 800, upper = 1400, optimise = 1) %&gt;% init_guess(&#39;\\\\.k$&#39;,180,lower = 150, upper = 300, optimise = 1) %&gt;% init_guess(&#39;_k$&#39;,1000,lower = 5, upper = 3000, optimise = 1) %&gt;% init_guess(&#39;\\\\.bbin&#39;,180,lower = 150, upper = 300, optimise = 1) %&gt;% init_guess(&#39;prop_m&#39;,0.5,lower = 0, upper = 1, optimise = 0) %&gt;% init_guess(&#39;init.F&#39;,0,lower = 0, upper = 1, optimise = 0) %&gt;% init_guess(&#39;recl&#39;,50,lower = 50, upper = 300, optimise = 1) %&gt;% init_guess(&#39;\\\\.k$&#39;,180,lower = 150, upper = 300, optimise = 1) %&gt;% init_guess(&#39;\\\\.walpha$&#39;,0.001,lower = 0, upper = 1, optimise = 0) %&gt;% init_guess(&#39;\\\\.wbeta&#39;,3,lower = 0, upper = 4, optimise = 0) %&gt;% init_guess(&#39;\\\\.recsd$&#39;,50,lower = 0, upper = 300, optimise = 1) %&gt;% init_guess(&#39;\\\\.M$&#39;,0.16,lower = 0, upper = 1, optimise = 0) %&gt;% init_guess(&#39;num_births&#39;,2,lower = 1, upper = 2, optimise = 1) %&gt;% init_guess(&#39;feed_area_prop&#39;,1/4,lower = 0, upper = 1, optimise = 0) %&gt;% init_guess(&#39;resil.a&#39;,1.6,lower = 0, upper = 10, optimise = 0) %&gt;% init_guess(&#39;_z&#39;,2,lower = 0, upper = 3, optimise = 0) %&gt;% init_guess(&#39;fleet.alpha&#39;,0.08,lower = 0, upper = 1, optimise = 1) %&gt;% init_guess(&#39;fleet.l50&#39;,300,lower = 150, upper = 600, optimise = 1) %&gt;% write.gadget.parameters(paste(gd,&#39;params.in&#39;,sep=&#39;/&#39;)) gadget_evaluate(gd,params.in = &#39;params.in&#39;, log = &#39;run.log&#39;) ## [1] &quot;whale-model&quot; ## attr(,&quot;mainfile&quot;) ## [1] &quot;main&quot; ## attr(,&quot;class&quot;) ## [1] &quot;gadget.variant&quot; &quot;list&quot; fit &lt;- gadget.fit(gd = gd, wgts = NULL, params.file = &#39;params.in&#39;) ## [1] &quot;Reading input data&quot; ## [1] &quot;Running Gadget&quot; ## [1] &quot;Reading output files&quot; ## [1] &quot;Gathering results&quot; ## [1] &quot;Merging input and output&quot; plot(fit, data= &#39;res.by.year&#39;, type = &#39;num.total&#39;) "],["processing-input-data-with-mfdb.html", "11 Processing input data with MFDB 11.1 Working with data 11.2 Description of the MFDB system 11.3 Importing data 11.4 Importing data 11.5 Querying data 11.6 Uploading the DATRAS database to MFDB 11.7 Dumping / Restoring a DB", " 11 Processing input data with MFDB 11.1 Working with data Fisheries stock assessment aims to provide a satisfactory level of catch based the estimated stock status. Typically this means the abundance or biomass of the resource in question. In all but rare cases it is next to impossible to observe these numbers directly as the fish species in question live in the deep oceanc. Therefore the most of the information on the population is derived from assumptions on the population dynamics combined with observations on various aspects of the population. This includes relative abundance/biomass from scientific surveys and catch size and/or age composition. Assessing stock or ecosystem status is therefore often a exhaustive exercise of data gathering and aggregation. The assessment method often require that the data are pre-processed in a certain manner in order for them to be used and it is in this processing of the data is where the stock assessor needs to draw on insights to piece them together. Examples of this expert judgment process is the borrowing of age length keys between years and/or gears or filling up length distribution for certain days. On of the key utilities of Gadget is its ability to digest this disparate array of observations with minimal aggregation, ensuring that when observations are truly available for a stock/gear/time combination it can be compared with model output and effectively moves the “guess-work” into the model where is belongs. Regardless of the modeling approach employed, fisheries stock assessment requires robust data management especially for those assessment that are used annually to produce advice on catch advice as it is imperative for whole process to be reproducible between years. There has been increased interest in developing tools/procedures to ensure this reproducibility which can be seen from project such as the ICES TAF and stockassessment.org. One such project, MFDB, was developed explicitly to deal with formatting data for ecosystem models and Gadget models. In this chapter an overview of the key components of the MFDB system is provided with simple illustration based on Icelandic data. 11.2 Description of the MFDB system MFDB is essentially a custom built database system written to smooth out kinks in the process of collating the various snippets of data. The user interface is written entirely in R allowing the user to leverage the tools available in the R environment thus enabling automated processing of fisheries data into suitable forms for running ecosystem models against it such as Gadget MFDB contains several distinct sets of functions: Create and connect to a PostgreSQL database schema (mfdb function) Import data into a PostgreSQL database (mfdb_import_* functions) Sample / group data from database (other mfdb_* functions) Using this, you can install PostgreSQL locally and have a script automating the process of: Importing data from your sources Uploading into your local MFDB database Sampling / grouping this data Producing set of Gadget data files ready to be run by Gadget Also, MFDB can be used to connect to a remote database and generate model files from that data. Before doing anything with mfdb, it is worth knowing a bit about how data is stored. Broadly, there are 2 basic types of table in mfdb, taxonomy and measurement tables. The measurement tables store all forms of sample data supported, at the finest available detail. These are then aggregated when using any of the mfdb query functions. All measurement data is separated by case study, so multiple case studies can be loaded into a database without conflicts. Taxonomy tables store all possible values for terms and their meaning, to ensure consistency in the data. For example, species stores short-names and full latin names of all known species to MFDB, to ensure consistency in naming. Most Taxonomies have defaults which are populated when the database is created, and their definitions are stored as data attached to this package. See mfdb-data for more information on these. Others, such as areacell and sampling_type are case study specific, and you will need to define your terms before you can import data. 11.2.1 Installing MFDB MFDB is available from CRAN and is intalled in the typical fashion: install.packages(&#39;mfdb&#39;) However MFDB requires that the user has access to a running postgreSQL database. To install postgreSQL on your local machine you can follow these instructions but if you expect more users working on the same DB it may be wise to consider installing it on a (widely) accessible server. 11.3 Importing data Unless you are working with a remote database, you will need to populate the database at least once before you are able to do any querying. The steps your script needs to do are: 11.3.1 Connect to database Use the mfdb() function. This will create tables / populate taxonomies if necessary. The user opens the link with the following command: mdb &lt;- mfdb(&#39;Iceland&#39;) where the string the mfdb represents the “case study”, or simply just the data set the user want to link to. Note that this string can be set as anything allowing the user to maintain different versions of the data depending on the time (e.g. between assessment periods). If it is the first time the mfdb function is called with a particular case study name it will spew out a lot of gunk similar to: 2020-09-27 14:25:41 INFO:mfdb:No schema, creating test 2020-09-27 14:25:41 INFO:mfdb:Creating schema from scratch NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index &quot;case_study_pkey&quot; for table &quot;case_study&quot; NOTICE: CREATE TABLE / UNIQUE will create implicit index &quot;case_study_name_key&quot; for table &quot;case_study&quot; NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index &quot;institute_pkey&quot; for table &quot;institute&quot; NOTICE: CREATE TABLE / UNIQUE will create implicit index &quot;institute_name_key&quot; for table &quot;institute&quot; NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index &quot;gear_pkey&quot; for table &quot;gear&quot; NOTICE: CREATE TABLE / UNIQUE will create implicit index &quot;gear_name_key&quot; for table &quot;gear&quot; NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index &quot;vessel_type_pkey&quot; for table &quot;vessel_type&quot; NOTICE: CREATE TABLE / UNIQUE will create implicit index &quot;vessel_type_name_key&quot; for table &quot;vessel_type&quot; NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index &quot;market_category_pkey&quot; for table &quot;market_category&quot; NOTICE: CREATE TABLE / UNIQUE will create implicit index &quot;market_category_name_key&quot; for table &quot;market_category&quot; NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index &quot;sex_pkey&quot; for table &quot;sex&quot; ... where the database is simply notifying the user that it is populating the case study schema. If the user want to connect to a remote server you can specify the connection using the db_params argument: mdb &lt;- mfdb(&#39;Iceland&#39;, db_params = list(host=&#39;mfdb.example.com&#39;, user = &#39;johndoe&#39;, pass = &#39;1234&#39;)) where the connection parameters are specified appropriately. In addition, the schema can be destroyed (e.g. when you want to start again) using destroy_schema = TRUE when connecting to the database. 11.3.2 Defining taxonomies The MFDB system has a number of taxonomies, some of which are populated by default while other are defined by the user when importing and will be linked to the data when imported and used to filter it when exported. These taxonomies can be are listed by calling: mfdb:::mfdb_taxonomy_tables ## [1] &quot;case_study&quot; &quot;institute&quot; &quot;gear&quot; &quot;vessel_type&quot; ## [5] &quot;market_category&quot; &quot;sex&quot; &quot;maturity_stage&quot; &quot;species&quot; ## [9] &quot;stomach_state&quot; &quot;digestion_stage&quot; &quot;areacell&quot; &quot;sampling_type&quot; ## [13] &quot;data_source&quot; &quot;index_type&quot; &quot;tow&quot; &quot;vessel&quot; The following tables are populated by default but can be extended based on the different needs that may arise: gear maturity_stage sex species vessel_type The other taxonomies such as area divisions, tow locations and vessels will need to be defined by the user. 11.3.3 Define areas &amp; divisions MFDB models space in the following way: areacell The finest level of detail stored in the database. Every measurement (e.g. temperature, length sample) is assigned to an areacell. This will generally correspond to ICES gridcells, however there is no requirement to do so. You might augment gridcell information with depth, or include divisions when the measurement doesn’t correlate to a specific areacell. division Collections of areacells, e.g. ICES subdivisions, or whatever is appropriate. Finally, when querying, divisions are grouped together into named collections, for instance mfdb_group(north = 1:3, south = 4:6) will put anything in divisions 1–3 under an area named “north”, 4–5 under an area named “south”. Before you can upload any measurements, you have to define the areacells that they will use. You do this using the mfdb_import_area() function. This allows you to import tables of area/division information, such as: mfdb_import_area(mdb, data.frame(area = c(&#39;101&#39;, &#39;102&#39;, &#39;103&#39;, &#39;401&#39;,&#39;402&#39;, &#39;403&#39;), division = c(&#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;))) If you want areas to be part of multiple divisions, then you can use mfdb_import_division() to import extra revisions. In the case of the area around Iceland the grid cells are defined from coordinates \\((x,y)\\) using the following formula: \\[\\Gamma(x,y) = 10*\\left(100*(\\lfloor{2*y}\\rfloor/2 - 60) + \\lfloor{x}\\rfloor \\right) + \\begin{cases} 0 &amp; s(-(x - \\lfloor{2*x}\\rfloor/2) \\in \\{2,4,6\\} \\\\ 1 &amp; s(-(x - \\lfloor{2*x}\\rfloor/2) = 4\\\\ 2 &amp; s(-(x - \\lfloor{2*x}\\rfloor/2) = 1\\\\ 3 &amp; s(-(x - \\lfloor{2*x}\\rfloor/2) = 7\\\\ 4 &amp; s(-(x - \\lfloor{2*x}\\rfloor/2) = 3\\\\ \\end{cases} \\] and this is implemented in the d2sr function from the geo-package: # install from github #devtools::install_github(&#39;hafro/geo&#39;) ## note lon is assume from west to east not vice-versa geo::d2sr(lat = 66, lon = 20) The grid cells can then be split up into divisions based on a collection of grid cells as illustrated in the figure below: where the subdivision were selected based on a cluster analysis of survey data and depth contours (see the DST\\(^2\\) final report). The mapping of area cells to division can be read from the reitmapping.tsv file which is installed as a part of MFDB. It can be loaded it into memory with the following command: reitmapping &lt;- read.table( system.file(&quot;demo-data&quot;, &quot;reitmapping.tsv&quot;, package=&quot;mfdb&quot;), header=TRUE, as.is=TRUE) The areas and divisions of the Icelandic continental shelf area are defined by the following commands: ## import the area definitions into mfdb mfdb_import_area(mdb, reitmapping %&gt;% select(id, name=GRIDCELL, size) %&gt;% as.data.frame()) ## create area division (used for e.g. bootstrapping) mfdb_import_division(mdb, reitmapping %&gt;% split(.$SUBDIVISION) %&gt;% map(&#39;GRIDCELL&#39;)) 11.3.4 Define sampling types Any survey data can have a sampling type defined, which then can be used when querying data. If you want to use a sampling type, then define it using mfdb_import_sampling_type(). It is useful to give the different survey and commercial samples from various sampling projects separate to be able handle them differently when defining the likelihood function for the model. The function requires three columns to be defined: id name key to be used for the samples description of the sampling type An example of the definition of sampling types for Icelandic waters: mfdb_import_sampling_type(mdb, data.frame( id = 1:18, name = c(&#39;SEA&#39;, &#39;IGFS&#39;,&#39;AUT&#39;,&#39;SMN&#39;,&#39;LND&#39;,&#39;LOG&#39;,&#39;INS&#39;,&#39;ACU&#39;,&#39;FLND&#39;,&#39;OLND&#39;,&#39;CAA&#39;, &#39;CAP&#39;,&#39;GRE&#39;,&#39;FAER&#39;,&#39;RED&#39;,&#39;RAC&#39;,&#39;LOBS&#39;,&#39;ADH&#39;), description = c(&#39;Sea sampling&#39;, &#39;Icelandic ground fish survey&#39;, &#39;Icelandic autumn survey&#39;,&#39;Icelandic gillnet survey&#39;, &#39;Landings&#39;,&#39;Logbooks&#39;,&#39;Icelandic nephrop survey&#39;, &#39;Acoustic capelin survey&#39;,&#39;Foreign vessel landings&#39;,&#39;Old landings (pre 1981)&#39;, &#39;Old catch at age&#39;,&#39;Capelin data&#39;,&#39;Eastern Greenland autumn survey&#39;, &#39;Faeroese summer survey&#39;,&#39;Redfish survey&#39;,&#39;Redfish accoustic survey&#39;, &#39;Icelandic nephrops survey&#39;,&#39;Ad-hoc surveys&#39;))) 11.3.5 Define vessel taxonomy Data that is imported can be linked to vessel where basic information on the vessel can attached to the vessel name/ID. The following columns will need to be present in the imported vessel list: name ID of the vessel, used in the tow taxonomy length of the vessel tonnage the capacity of the vessel power the engine power full_name gives the full name of the vessel vessel_type linked to the vessel type taxonomy To import the vessel list the following command is used: mfdb_import_vessel_taxonomy(mdb, vessel_registry) 11.3.6 Define tow taxonomy The tow taxonomy registers exact location and depth of the sample, in order for multiple samples can be linked to the same tow. To define a tow the input data frame can contain the following columns: name the ID of the tow latitude initial position of the tow longitude end_latitude end position of the tow end_longitude depth the depth measured in the tow length length of the tow duration time duration Tows are imported in a similar fashion as vessel taxonomies: mfdb_import_tow_taxonomy(mdb, tows) 11.4 Importing data 11.4.1 Import temperature data At this point, you can start uploading actual measurements. The easiest of which is temperature. Upload a table of areacell/month/temperature data using mfdb_import_temperature(): ## here some work on temperature would be nice to have instead of fixing the temperature mfdb_import_temperature(mdb, expand.grid(year=1900:2100, month=1:12, areacell = reitmapping$GRIDCELL, temperature = 3)) Obviously it it would be more useful to have actual temperature data stored in these area cells but since this is rarely used in Gadget models it will not be considered further here. 11.4.2 Importing survey/commercial samples The function mfdb_import_survey() allows the user to import biological samples from various sources. Ideally data should be uploaded in separate chunks based on the data source. For example, if you have length and age-length data, don’t combine them in R, instead upload them separately and both will be used when querying for length data. This keeps the process simple, and allows you to swap out only the data that needs to be update as necessary. The function accepts data frames of the following format: institute Optional. An institute name, see mfdb::institute for possible values tow Optional. Tow defined previously with mfdb_import_tow_taxonomy(...) gear Optional. Gear name, see mfdb::gear for possible values vessel Optional. Vessel defined previously with mfdb_import_vessel_taxonomy(...) sampling_type Optional. A sampling_type, see mfdb::sampling_type for possible values year Required Year each sample was taken, e.g. c(2000,2001) month Required. Month (1–12) each sample was taken, e.g. c(1,12) areacell Required. Areacell sample was taken within species Optional, default c(NA). Species of sample, see mfdb::species for possible values age Optional, default c(NA). Age of sample, or mean age sex Optional, default c(NA). Sex of sample, see mfdb::sex for possible values maturity_stage length Optional, default c(NA). Length of sample / mean length of all samples length_var Optional, default c(NA). Sample variance, if data is already aggregated length_min Optional, default c(NA). Minimum theoretical length, if data is already aggregated weight Optional, default c(NA). Weight of sample / mean weight of all samples weight_var Optional, default c(NA). Sample variance, if data is already aggregated weight_total Optional, default c(NA). Total weight of all samples, can be used with count = NA to represent an unknown number of samples count Optional, default c(1). Number of samples this row represents (i.e. if the data is aggregated) mfdb_import_survey(mdb,samples,data_source = &#39;the_source&#39;) Note that the data_source argument gives a name for the uploaded data set and it allows you repeat the re-upload only this chunk of data if and when corrected data become available. 11.4.3 Import stomach survey Stomach surveys are imported in much the same way, however there are 2 data.frames, one representing predators, one preys. The column stomach_name links the two, which can contain any numeric / character value, as long as it is unique for predators and prey measurements are assigned to the correct stomach. See mfdb_import_survey for more information or the demo directory for concrete examples. 11.5 Querying data There are a selection of querying functions available, all of which work same way. You give a set of parameters, each of which can be a vector of data you wish returned, for instance year = 1998:2000 or species = c('COD'). If also grouping by this column (i.e. ‘year’, ‘timestep’, ‘area’ and any other columns given, e.g. ‘age’), then the parameter will control how this grouping works, e.g. maturity_stage = mfdb_group(imm = 1, mat = 2:5) will result in the maturity_stage column having either ‘imm’ or ‘mat’. These will also be used to generate Gadget aggregation files later. For example, the following queries the temperature table: defaults &lt;- list( area = mfdb_group(&quot;101&quot; = ), timestep = mfdb_timestep_quarterly, # Group months to create 2 timesteps for each year year = 1996:2005) agg_data &lt;- mfdb_temperature(mdb, defaults) All functions will result in a list of data.frame result tables (generally only one, unless you requested bootstrapping). Each are suitable for feeding into a gadget function to output into model files. See mfdb_sample_count for more information or the demo directory for concrete examples. 11.6 Uploading the DATRAS database to MFDB The following gives an illustrative example of how the DATRAS survey data are uploaded to MFDB. # devtools::install_github(&#39;ices-tools-prod/icesDatras&#39;) # devtools::install_github(&#39;ices-tools-prod/icesFO&#39;,dependencies = FALSE) # devtools::install_github(&#39;fishvice/tidyices&#39;) # devtools::install_github(&#39;hafro/geo&#39;) library(icesDatras) library(mfdb) library(tidyices) library(tidyverse) mdb &lt;- mfdb(&#39;datras&#39;) yrs &lt;- 2017 # years qs &lt;- c(1) # quarters hh &lt;- icesDatras::getDATRAS(record = &quot;HH&quot;, survey = &quot;NS-IBTS&quot;, years = yrs, quarters = qs) %&gt;% dtrs_tidy_hh() hl &lt;- icesDatras::getDATRAS(record = &quot;HL&quot;, survey = &quot;NS-IBTS&quot;, years = yrs, quarters = qs) %&gt;% dtrs_tidy_hl(hh) ca &lt;- icesDatras::getDATRAS(record = &quot;CA&quot;, survey = &quot;NS-IBTS&quot;, years = yrs, quarters = qs) %&gt;% dtrs_tidy_ca() ## Setup the spatial taxonomy hh &lt;- hh %&gt;% mutate(areacell = geo::d2sr(shootlat,shootlong)) hh %&gt;% select(areacell) %&gt;% distinct() %&gt;% mutate(id = 1:n(), lat = geo::sr2d(areacell)$lat, lon = geo::sr2d(areacell)$lon, area = geo::srA(areacell)) %&gt;% select(id, name=areacell,size = area) %&gt;% mfdb_import_area(mdb,.) ## Setup sampling types mfdb_import_sampling_type(mdb, data.frame( id = 1:3, name = c(&#39;NS-IBTS&#39;,&#39;SEA&#39;,&#39;LND&#39;), description = c(&#39;North Sea IBTS&#39;,&#39;Catch samples&#39;,&#39;Landings&#39;))) ## upload tow taxonomy (optional) # select(synis_id,ar,man,lat=kastad_n_breidd,lon=kastad_v_lengd,lat1=hift_n_breidd,lon1=hift_v_lengd, # gear,sampling_type,depth=dypi_kastad,vessel,reitur,smareitur) hh %&gt;% select(sampling_type = survey, name = id, year, month = quarter, latitude = shootlat, longitude = shootlong, towlength = hauldur, depth, vessel = ship) %&gt;% mfdb_import_tow_taxonomy(mdb,.) ## setup vessel taxonomy hh %&gt;% select(name = ship) %&gt;% distinct() %&gt;% mutate(length=NA,tonnage=NA,power=NA, full_name = name) %&gt;% mfdb_import_vessel_taxonomy(mdb,.) ## import length data hh %&gt;% left_join(hl) %&gt;% select(sampling_type = survey, areacell, tow = id, year, month = quarter, latitude = shootlat, longitude = shootlong, towlength = hauldur, depth, vessel = ship, latin, length, sex, count = n)%&gt;% mutate(latin = tolower(latin), gear = &#39;BMT&#39;) %&gt;% left_join(mfdb::species %&gt;% mutate(latin = gsub(&#39;.+\\\\((.+)\\\\)&#39;,&#39;\\\\1&#39;,description), latin = tolower(latin)) %&gt;% rename(species = name)) %&gt;% mutate(species = as.character(species)) %&gt;% select(-c(id,latin,description)) %&gt;% as.data.frame() %&gt;% mfdb_import_survey(mdb,.,data_source = &#39;DATRAS-lengths&#39;) ## import biological information hh %&gt;% left_join(ca) %&gt;% select(sampling_type = survey, areacell, tow = id, year, month = quarter, latitude = shootlat, longitude = shootlong, towlength = hauldur, depth, maturity, weight = wgt, vessel = ship, latin, length, sex, count = n) %&gt;% mutate(maturity_stage = pmin(as.numeric(maturity) - 60,5)) %&gt;% mutate(latin = tolower(latin), gear = &#39;BMT&#39;) %&gt;% left_join(mfdb::species %&gt;% mutate(latin = gsub(&#39;.+\\\\((.+)\\\\)&#39;,&#39;\\\\1&#39;,description), latin = tolower(latin)))%&gt;% select(-c(id,latin,description)) %&gt;% rename(species = name) %&gt;% mutate(species = as.character(species)) %&gt;% as.data.frame() %&gt;% mfdb_import_survey(mdb,.,data_source = &#39;DATRAS-ages&#39;) ## upload landings tibble(year = 2017,month = 1, areacell = -3548, species = &#39;WHG&#39;, weight_total = 1000, gear = &#39;BMT&#39;,sampling_type = &#39;LND&#39;) %&gt;% as.data.frame() %&gt;% mfdb_import_survey(mdb,.,data_source = &#39;test-landings&#39;) 11.7 Dumping / Restoring a DB You can also dump/import a dump from another host using the postgres pg_dump and pg_restore commands. You can dump/restore indvidual schemas (i.e. the case study you give to the mfdb() command), to list all the schemas installed run SELECT DISTINCT(table_schema) FROM information_schema.tables from psql. Note that if you use mfdb('Baltic'), the Postgres schema name will be lower-cased. Create a dump of your chosen schema with the following command: pg_dump --schema=baltic -F tar mf &gt; baltic.tar This will make a dump of the “baltic” case study into “baltic.tar”. It can then be restored onto another computer with the following: pg_restore --clean -d mf baltic.tar If you already have a baltic schema you wish to preserve, you can rename it first by issuing ALTER SCHEMA baltic RENAME TO baltic_o in psql. Once the restore is done you can rename the new schema and put the name of the old schema back. "],["installing-gadget-from-source.html", "A Installing Gadget from source A.1 Command line version A.2 Download, compile and install", " A Installing Gadget from source Gadget development repository is housed on the MFRI github site. For convenience Gadget has been wrapped up in a R-package available from CRAN using the following command: install.packages(&#39;gadget2&#39;) or if you need the bleeding edge version of Gadget you can also install it directly with: devtools::install_github(&#39;hafro/gadget2&#39;) Windows users note that you may want to install the icesTAF R package to be able to convert Windows line-endings to unix line-endings with the dos2unix function, which when not corrected could cause all kinds of grief. A.1 Command line version Alternatively you can install gadget from source as a command line tool. Basic installation instructions can be found on the github site but below they are given step-by-step. Notice that the extremely useful resource ‘Gadget User Guide’ is included as a pdf with the installation, but it is also available on-line. To compile Gadget one needs a working C++ compiler and a version of Make installed on the computer. A.1.1 Linux The compiler and Make should be installed automatically on most linux distributions but on ubuntu one needs to install build-essentials: sudo apt-get install build-essential A.1.2 Mac It should be sufficient to install XCode through the Appstore and through XCode’s preferences install commandline tools. A.1.3 Windows The easiest way is to install uses Rtools . During the install process allow the installer to append to the system path. Also you may want to install the icesTAF R package to be able to convert Windows line-endings to unix line-endings with the dos2unix function. A.2 Download, compile and install A.2.1 Standard procedure To install Gadget you can simply click the “download as a zip file” button. Unzip this file and within command prompt/terminal application make your way to the resulting folder, typically called gadget-master, and simply type: make Recommended: for convenience you may want to install the resulting gadget executable to a location in the system path, thus allowing the gadget executable to called in any directory. On *nix based system you can simply type: sudo make install Be aware of where your gadget executable is located (for example by searching for ‘gadget’ on your computer). Whenever Gadget is run via Rgadget, this executable will be called, so Gadget’s path should be listed within R as a search path. This should be take care of when installed using sudo make install. If it is not possible to install gadget for all users of the computer, due to lack of privileges (such as administrator rights) on the computer, one can move the gadget binary to a position on the search path. E.g. if you want to store the gadget binary a directory name bin on your home directory you can: ## if the bin directory does not exist create it mkdir ~/bin ## move the gadget binary to ~/bin mv gadget ~/bin ## update the path (if needed) echo PATH=$HOME/bin:$PATH &gt;&gt; ~/.bash_profile echo export PATH &gt;&gt; ~/.bash_profile and then Rgadget should be able to find gadget. A.2.2 Recommended: via Git We recommend installing via Git because it provides for easy updating and if you don’t already use git, then this is a good time to start: can be extremely useful later for version control and sharing of your Gadget models while under development. This subject will be touched upon on the last day of the course. To download and/or install Git, follow the instructions found here. Note that Git comes prepackaged with Linux systems so it only needs to be installed via the instructions on that website. Next, Gadget can be cloned (rather than downloaded) from the github website using Git. From terminal, use: git clone https://github.com/Hafro/gadget.git Navigate to the gadget directory, then install: cd &lt;gadget path&gt; cd gadget make sudo make install To check that gadget is installed, you can try opening the manual: man gadget To update, navigate to the gadget directory then use: git pull sudo make install "],["troubleshooting-gadget-models.html", "B Troubleshooting Gadget models B.1 List of known Gadget quirks B.2 Gadget is working properly, but results are strange", " B Troubleshooting Gadget models Uh oh. You ran callGadget and a bunch of red gibberish error message about something with a null status popped out. Now what? First step is to print a log from a Gadget run, but ONLY when Gadget is running a simulation. If run while optimising, you could end up with a crashed computer as well. Open the log and see what the last line tells you. Most often it tells you that a file or data can not be found. B.0.1 File / data / Gadget cannot be found Look for the file that is missing according to the log and make a note of its locatino. Then check all directories involved to see that it matches the search directories: * What is your current R working directory in relation to your file paths? * What is your Gadget working directory in relation to your model? Set the via Gadget using Sys.setenv(GADGET_WORKING_DIR=normalizePath(pathname)). * Where is your Gadget executable in relation to where callGadget thinks it is? The default can be found and changed under the gadget.exe argument within callGadget. B.0.2 Fleet / Data / Likelihood problems B.0.2.1 Fleet does not exist in an area You may get an error whenever there are data assigned to a fleet that came from an area where that fleet does not exist. When using Rgadget, fleet catch/landings data frames need to have an attribute assigned to them that specifies the areas in which the fleet exists. This information is used to assign fleets to areas in the model. Note that it does not matter whether data from all areas where the fleet exists are in the file or not. So for example, a fleet assigned to areas 1 &amp; 2 can have data only coming from area 1, but a fleet assigned only to area 1 cannot also have data coming from area 2. B.0.2.2 Certain likelihood scores or values are not being calculated If you find that a likelihood component is not returning realistic values, it is wise first to check that temporal and spatial the structure of your model and the structure of your data match. It is also important to check that different sources of data are consistent. For example, you will run into problems if you have a catchdistribution likelihood component with catchdistribution data that comes from a time and place that does not match any catch data being extracted. B.0.3 Starting value is outside the bounds of the parameter This problem is exactly as it states - check your parameter file. Sometimes this happens due to a programming error, but sometimes this also happens when, after running a Gadget optimisation run, Gadget leaves you with an optimised parameter value that is ever so slightly beyond the bounds that you specified within the optimisation run. Parameter bounds in the optimisation routine are not set as hard bounds, rather as a penalty, defined by the BoundLikelihood likelihood component, its value and weight. The penalty is calculated as the distance of the parameter value from its bound x the likelihood component value x its weight. Therefore, if the likelihood increases strongly as the bound is approached in the optimisation search, then there may be a small space beyond the bound where the optimisation algorithm could converge if the penalties or weights are not high enough. B.0.4 Update Gadget and Rgadget, restart the Rsession Package incompatibilities? Bug fixes? No good explanations here as to when this should be done, it just works sometimes and should be done regularly anyway (roughly monthly at a minimum). B.1 List of known Gadget quirks Once in a while, you get a far more interesting error in the log. These can be difficult to figure out, but here are a few known bugs that may be causing it. Survey indices with more than one are must have data for both areas within a given year, if that year is present in the data at all Where little age data are present, the simulated annealing optimisation routine can tend to get stuck in local optima where biomass is very high. For example, if recruitment is estimated each year as in the ling example, then at least one recruitment value will be optimised very close to the upper bound, but open further investigation, results with lower likelihood can be found away from these bounds. The reason for this is unknown and efforts are underway to analyze the reason for this problem, but in the meantime it can have serious consequences on model results. Therefore, it is best practice to always set the seed for the optimisation run and create a profile of the likelihood score while varying the value of any suspect parameters. In this case of recruitment estimates, the upper bound that applies to all recruitment estimates may need to be varied instead of the parameter value itself, because any change in a single year’s recruitment parameter will affect other year’s recruitment values as well as growth. B.2 Gadget is working properly, but results are strange B.2.1 Programming errors This is most likely to be a programming error in an Rgadget script that has caused strange input or settings, so the first step is to carefully check over the Gadget files. The most likely culprits are trying to include the same parameter in multiple places, but accidentally naming it incorrectly (thereby generating an additional poorly specified parameter) wrongly specified likelihood component names that end up not grouped within the call to gadget.reiterative B.2.2 Old files hanging around in the Gadget model directory If nothing is obvious, delete all Gadget files in the project, check all working directories, and rewrite the Gadget files. Perhaps some old model specifications were not rewritten by new ones, or old likelihood components that were written by a previous version are still hanging around in the folders. In general, when developing a set of Rgadget script of a single Gadget model, it is best practice to delete all generated Gadget files while testing and running it. This is because simple programming errors, for example in naming a likelihood component, can cause serious problems in your model structure (e.g., including the same data in two separate likelihood components). If the incorrectly generated files are not deleted, Gadget may read them and incorporate them as part of your model. B.2.3 Gadget iterative gives errors Step through your model files looking for bugs, especially in the likelihood files. Look at the weights that are being assigned in every instance, which could lead you to problematic data or likelihood structures. B.2.4 The Gadget working directory is incorporating files from another Gadget model When recreating Gadget files and calling Gadget, check all working directories carefully. This is especially problematic when working on two scripts of two different models simultaneously in the same R session. Because there is only one Gadget working directory per R session environment, which is set using Sys.setenv(GADGET_WORKING_DIR=normalizePath(pathname)), if you set the Gadget working directory containing project A’s data, and don’t switch it back to project B’s working directory when running project B, then you may start including project A data and likelihood components into a project B model run. More on file and path organization can be found in the Gadget User Guide section 1.3 ‘Running Gadget’. B.2.5 Your model is not good If these errors are ruled out, you will have to look at the model results themselves. Some starting places: * Did your model converge? If no, increase optimisation length or change optimisation parameters or methods. In complex models or those no age data, it has been observed that the simulated annealing algorithm needs to run for a long time to avoid landing in local optimum. * Is there understocking? Try restricting parameter bounds so that the model begins in a more realistic starting point. * Are parameter bound constricting? Loosen them if necessary. * Are parameter bounds realistic? Check to make sure parameter values are not on the wrong scale or have the wrong interpretation. * Are there more ‘NAs’ than data in your likelihood function? Because NAs are not actually included in Gadget, to consider this question you need to compare the model structure (e.g., # age-length bins) to the number of data points you include in the likelihood. For example, if you have 10 ages x 100 lengths = 1000 bins, but only 50 data points to compare with, then the optimisation routine can have a hard time fitting that data source. Try changing the aggregation levels of the data (grouping attributes of the data frame) to larger aggregations for the purpose of comparing the model to data. * Does the growth process look realistic? This is an important question to ask of all Gadget models, since Gadget models are more likely to be used in scenarios where there is little or poor ageing data. In this scenario, model results hinge heavily on how growth is modeled. Therefore, results for growth-related paramters should be scrutinized carefully (e.g., Linfinity and k in Von Bertalannfy growth, alpha &amp; beta in the translation of lengths to weights, maxlengthgroupgrowth should be reduced, especially when the beta paramater hits a bound). * Check the list of known Gadget quirks. "],["references.html", "C References", " C References "]]
