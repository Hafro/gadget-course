---
title: "Adding components to the model"
output: 
  html_document:
    fig_height: 4
    fig_width: 8
    highlight: haddock
    theme: united
    toc: yes
    toc_float: yes
bibliography: library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Rgadget)
schedule <- 
  expand.grid(year = 1:10, step = 1:4) %>% 
  arrange(year)
gd <- gadget.variant.dir('simple_model')
```

## Gadget variables 

It can be tedious to change all the input files whenever you want to try a different value for a certain input parameter. For example if you want to specify natural mortality as some thing else than 0 you can always do:
```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality',0.2)
```
And if you want to try many version of natural mortality you can obviously repeat this process for different values of M. There is however a more convenient approach to do this, namely Gadget switches or parameters. A Gadget parameter can be inserted instead of any number in the input file (apart from likelihood data), and are marked with the `#` character. So for the case of natural mortality we can now update the stock file to include a Gadget parameter by:

```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality',"#M")
```

And now we see that the value for natural mortality has been changed from 0 to `#M`. Now write this to file and rerun run Gadget.
```{r echo=FALSE}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality','#M') %>% 
  write.gadget.file(gd)

Sys.setenv(GADGET_WORKING_DIR=normalizePath(gd)) 
callGadget(s=1,main='main',ignore.stderr = FALSE,log = 'simple_log')
```

After running this, assuming we did everything correctly, we should see that the file in the directory called `params.out` is no longer empty:
```{r echo=FALSE}
read_lines('simple_model/params.out') %>% 
  paste(collapse = '\n') %>% 
  cat()
```

This file is generated by Gadget based on the switches it encounters when reading in the input files. It lists all parameters, their value as used in the simulation, upper and lower bounds and whether the parameter should optimised (more on that later). You then simply just change the value for M and re-run Gadget by supplying the parameter file as input. This can either be done by manually editing the parameter file or using the `init_guess` function:
```{r}
read.gadget.parameters('simple_model/params.out') %>% 
  init_guess('M',value = 0.2) %>% 
  write.gadget.parameters(file = 'simple_model/params.in')

callGadget(s=1,i='params.in')
```

Note that when supplying a parameter input you use the `i` argument in `callGadget`. 

Gadget parameters have a few more tricks up their sleeves. Notably you can apply functions or formulas to the parameter. For instance if you want multiply the value of `M` by 0.1 you can write that as:
```
(* 0.1 #M)
```
Note that functions and formulas are contained within round brackets, so that this
structure equates to `0.1*M`.

Similarly if you need to log transform your variable as `log(M)`, you can use:
```
(log #M)
```
 and these can be chained together:
```
(log (* 0.1 #M))
```
equates to `log(0.1*M)`. This allows you to apply fairly elaborate functions to the parameter. And as in the case of variables formulas can then be inserted instead of numbers. 


These formulas can be fairly complex and Rgadget provides mechanisms to manipulate Gadget formulae, both allowing you to evaluate the formula using `parse.gadget.formula` and transform a R statement with `to.gadget.formulae`:

```{r}
## R expression to Gadget formula
to.gadget.formulae(quote((1+exp(a*b))))

## Gadget formula to a R expression
parse.gadget.formulae('(* #a #b)')

## evaluate expression
parse.gadget.formulae('(* #a #b)') %>% 
  eval(list(a=7,b=6))
```

For instance if you want the mean length at age, in for instance the initial conditions, to be based on the Von Bertanlanfy growth function:
$$l_a = L_\infty(1 - e^{-k(a - a_0)}) $$
you can do that for age 3 as an example using the `to.gadget.formulae` in the following manner:

```{r}
to.gadget.formulae(quote(linf*(1-exp(-1*k(3-a0)))))
```



#### Exercise
* Change the initial conditions in such a way you can control both the initial number of fish and the natural mortality using the parameter file. What happens to your stock when you change these values?
* Play around with the Gadget formulae functions, e.g. parse and evaluate the following formula at $\alpha = 0.1$ and $l_{50} = 75$ :
```
 (/ 1 (+ 1 (exp (* (* -1 #alpha) (- 50 #l50)))))
```

# Predation

As Gadget is a length based simulation model, almost all processes are modelled in terms of length of an individual in a particular stock. The rationale for this is that natural processes are better explained in terms of size, e.g. prey must fit into the mouth of the predator. Thus predation and fleet selection are modelled in terms of size. These selection processes can very between predators (and fleets) and therefore Gadget allows the user to define this relationship in a number of ways. This relationship is essentially factored into two components: 

a) what the predator wants to consume and 
b) what size ranges the predator is able to produce. 

In Gadget there are a number of predator-prey relations that can be defined. They include the obvious case where one substock predates the other. Additionally a cannibalistic relationship can be defined if the substocks are modelled as an immature and a mature part of the same species. Fleets (survey and/or commercial) can be integrated into the model by being considered as one of the predators. A fleet can harvest one or both substocks in some or all areas. 

The predation in Gadget is implemented as follows. Each predator will conceptually be assigned **availability** of a certain prey in comparison with other food sources and a **feeding level**, i.e., fraction of available food the predator wants to consume. Combining these two terms the amount that the predator wants to consume is calculated.

The availability of a certain prey $p$ for a predator $P$ is determined by the prey biomass per length group ($N_{l}W_{l}$, where $W_l$ is the weight at length $l$) and a length based suitability function of the form:

Function name  | Formula 
------------- | -------------
`constant`  | $S_{Pp}(L,l) = \alpha$ 
`straightline`  | $S_{Pp}(L,l) = \alpha + \beta l$
`exponential` | $S_{Pp}(L,l) = \frac{\delta}{1+e^{(-\alpha-\beta l - \gamma L)}}$
`exponentiall50` | $S_{Pp}(L,l) = \frac{1}{1 + e^{-\alpha(l-l_{50})}}$
`richards` | $S_{Pp}(L,l) = \left(\frac{\delta}{1+e^{(-\alpha-\beta l - \gamma L)}}\right)^\eta$
`andersen` | $S_{Pp}(L,l) =  \begin{cases} \alpha + \gamma e^{-\frac{(ln(L/l)-\beta)^2}{\delta}}, & \text{if}\ a=ln(L/l) < \beta \\\alpha + \gamma e^{-\frac{(ln(L/l)-\beta)^2}{\eta}}, & \text{if}\ a=ln(L/l) > \beta \end{cases}$
`andersenfleet` | Same as above except $L$ is a parameter
`gamma` | $S_{Pp}(L,l) = \bigg(\frac{1}{(\alpha -1)\beta\gamma)}\bigg)^{(\alpha -1)}e^{(\alpha -1 -\frac{1}{\beta\gamma})}$

where $L$ and $l$ are the predator and prey length respectively. Note that when defining fleets their lengths are not *well* defined and in the case of the Andersen suitability function you should use the fleet variant of that function. Note that $S_{Pp}$ is always between 0 and 1. $S_{P,p}(L,l)$ should therefore be interpreted as the percentage of prey abundance at length $l$ available to predator $P$ at length $L$.  This functional form for the suitability function also ensures that the length interaction between prey and predator is taken into account. For instance if $\beta <0$ the prey is less likely to be consumed as it grows larger. Similarly the prey is more likely to be consumed by a larger predator, given that $\gamma > 0$.  

In Gadget fleets lengths, $L$, are assumed to be irrelevant. $\gamma$ is therefore assumed to be 0. 

The feeding level for a fleet is determined by the yearly fishing effort $F$ multiplied by the length of the time step, i.e., the level is $F\Delta t$ and therefore the total consumption (harvest) is
$$
C_{fslat} = F\Delta t S_l N_{slat}
$$

In the simple predator-prey relation between the substocks in Gadget the prey availability to a predator becomes
$$\frac{F_{Ll}}{\sum_{l'}F_{Ll'}+OA}$$
where $F_{Ll} = S_{Pp}(L,l) N_{pl}W_{pl}$ is the prey biomass of length $l$ that the predator could consume, $W_{pl}$ is the average weight for prey of length $l$, $O$ is the density, per unit area, of other unspecified food sources and $A$ is the size of the area.

The feeding level of the predator is
$$\Psi_L = M_L \frac{\sum_{l'}F_{Ll'}+OA}{\sum_{l'}F_{Ll'}+OA+HA}$$
where $M_L$ is the maximum consumption of a predator of length $L$ for a particular time step length $\Delta t$. It is determined by $M_L=m_0L^{m_4}\Delta t$ where $m_0$ and $m_4$ are user defined constants\footnote{The numbering scheme is set to correspond to parameters in \cite{begley2004overview}}. $H$ is the density (biomass per area unit) of available food at which the predator can consume half maximum consumption. Note that $H$ should reflect how able the predator is to pursue its prey, which should factor in variables such as temperature and the cost of search.  $H$ determines therefore how quickly the predators consumption reaches $M_L$. $H=0$ would indicate that the predator would easily consume $M_L$ of the available biomass. A larger value for $H$ would indicate that prey is harder to find and therefore prey needs to be more abundant for the predator to reach $M_L$.

Given the feeding level and the prey availability the desired consumption of all predators of length $L$ is
$$
\begin{split}\label{eq:feedlev}
C_{L,l}&=N_{L}\Psi_{L}\left[\frac{F_{Ll}}{\sum_{l'}F_{Ll'}+OA}\right]\\
&=N_{L}M_{L}\frac{F_{Ll}}{\sum_{l'}F_{Ll'}+OA+HA}\\
\end{split}
$$
For each prey an upper limit needs to be set on the total amount consumed by all predators, including the fleets, to prevent more consumption than the available biomass. This over consumption check is made because the consumption is calculated on discreet time intervals and therefore the consumption is not immediately reflected in the available biomass.  Consumption can be limited to $R_M$ of the available biomass. This is implemented by scaling target consumption of all predators. Let  
$$
R_{p}(l)=\frac{\sum_{P}\sum_{L}C_{P,p}(L,l)}{N_{p}(l)W_{p}(l)}.
$$
be the proposed ratio consumed of prey $p$ of length $l$ and $R_M$ be the maximum ratio that can be consumed at one time step. Now if $R_{p}(l)>R_M$ the consumption of all predators is adjusted by the following
$$
C_{P,p}(L,l)=R_MN_{p}(l)W_{p}(l)\frac{C_{P,p}(L,l)}{\sum_{P}C_{P,p}(L,l)}
$$
The total consumption by every predator on prey is then subtracted from the substock abundance numbers.


This second part is determined by *suitability* functions. These functions are:


As we have seen before Rgadget has a number of helper functions to help the user to 

## Fleet operations

Human interactions in Gadget are often modelled as removals of a particular stock. These removals definde via a simplified stock object called `Fleet`, which inherits a more complex predator behaviour that a gadget stock can define (more on that later). The fleet operations are defined as a separate model component/file detailing the main attributes of the fleets. The defintion of a fleet is as follows:

* **Fleet type** which can be one of 5 types, `TotalFleet`,`NumberFleet`,`LinearFleet`,`EffortFleet` and `QuotaFleet`. 
* **Fleet name** name of the fleet
* **Suitability** how the fleet selection is defined
* **Catch data** a table of catch/effort by time step

Although the there are five different fleet types they can essentially be group into two classes of how the user can define the removals. These are the **Total fleets** where the total biomass or total number of removals are specified by the user and the **Effort fleets** that specify the removals in terms of harvest rate on available biomass/abundance.  The user defines when these removals occur by specifying the year and times step catch/effort take place (see https://hafro.github.io/gadget/docs/userguide#fleet_files for further details).  



```{r}
effort <- 
  structure(data.frame(year=schedule$year,step=2,area=1,number=1),
            area_group = list(`1` = 1)) 


gadgetstock('simple_stock',gd) %>% 
  gadget_update("iseaten",1) %>% 
  write.gadget.file(gd)

gadgetfleet('Modelfiles/fleet',gd,missingOkay = TRUE) %>% 
    gadget_update('linearfleet',
                  name = 'simple_fleet',
                  suitability = 
                    list(simple_stock=list(type='function',suit_func = 'constant',value=0.2)),
                  data = effort) %>% 
  write.gadget.file(gd)
```

# Recruitment


### Example
Simple stock recruitment model

# Aging process

# Growth


