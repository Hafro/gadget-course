---
title: "Adding components to the model"
output: 
  html_document:
    fig_height: 4
    fig_width: 8
    highlight: haddock
    theme: united
    toc: yes
    toc_float: yes
bibliography: library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Rgadget)
schedule <- 
  expand.grid(year = 1:10, step = 1:4) %>% 
  arrange(year)
gd <- gadget.variant.dir('simple_model')
```

# Gadget variables 

It can be tedious to change all the input files whenever you want to try a different value for a certain input parameter. For example if you want to specify natural mortality as some thing else than 0 you can always do:
```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality',0.2)
```
And if you want to try many version of natural mortality you can obviously repeat this process for different values of M. There is however a more convenient approach to do this, namely Gadget switches or parameters. A Gadget parameter can be inserted instead of any number in the input file (apart from likelihood data), and are marked with the `#` character. So for the case of natural mortality we can now update the stock file to include a Gadget parameter by:

```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality',"#M")
```

And now we see that the value for natural mortality has been changed from 0 to `#M`. Now write this to file and rerun run Gadget.
```{r echo=FALSE}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality','#M') %>% 
  write.gadget.file(gd)

Sys.setenv(GADGET_WORKING_DIR=normalizePath(gd)) 
callGadget(s=1,main='main',ignore.stderr = FALSE,log = 'simple_log')
```

After running this, assuming we did everything correctly, we should see that the file in the directory called `params.out` is no longer empty:
```{r echo=FALSE}
read_lines('simple_model/params.out') %>% 
  paste(collapse = '\n') %>% 
  cat()
```

This file is generated by Gadget based on the switches it encounters when reading in the input files. It lists all parameters, their value as used in the simulation, upper and lower bounds and whether the parameter should optimised (more on that later). You then simply just change the value for M and re-run Gadget by supplying the parameter file as input. This can either be done by manually editing the parameter file or using the `init_guess` function:
```{r}
read.gadget.parameters('simple_model/params.out') %>% 
  init_guess('M',value = 0.2) %>% 
  write.gadget.parameters(file = 'simple_model/params.in')

callGadget(s=1,i='params.in')
```

Note that when supplying a parameter input you use the `i` argument in `callGadget`. 

Gadget parameters have a few more tricks up their sleeves. Notably you can apply functions or formulas to the parameter. For instance if you want multiply the value of `M` by 0.1 you can write that as:
```
(* 0.1 #M)
```
Note that functions and formulas are contained within round brackets, so that this
structure equates to `0.1*M`.

Similarly if you need to log transform your variable as `log(M)`, you can use:
```
(log #M)
```
 and these can be chained together:
```
(log (* 0.1 #M))
```
equates to `log(0.1*M)`. This allows you to apply fairly elaborate functions to the parameter. And as in the case of variables formulas can then be inserted instead of numbers. 


These formulas can be fairly complex and Rgadget provides mechanisms to manipulate Gadget formulae, both allowing you to evaluate the formula using `parse.gadget.formula` and transform a R statement with `to.gadget.formulae`:

```{r}
## R expression to Gadget formula
to.gadget.formulae(quote((1+exp(a*b))))

## Gadget formula to a R expression
parse.gadget.formulae('(* #a #b)')

## evaluate expression
parse.gadget.formulae('(* #a #b)') %>% 
  eval(list(a=7,b=6))
```

For instance if you want the mean length at age, in for instance the initial conditions, to be based on the Von Bertanlanfy growth function:
$$l_a = L_\infty(1 - e^{-k(a - a_0)}) $$
you can do that for age 3 as an example using the `to.gadget.formulae` in the following manner:

```{r}
to.gadget.formulae(quote(linf*(1-exp(-1*k(3-a0)))))
```



#### Exercise
* Change the initial conditions in such a way you can control both the initial number of fish and the natural mortality using the parameter file. What happens to your stock when you change these values?
* Play around with the Gadget formulae functions, e.g. parse and evaluate the following formula at $\alpha = 0.1$ and $l_{50} = 75$ :
```
 (/ 1 (+ 1 (exp (* (* -1 #alpha) (- 50 #l50)))))
```

# Predation

As Gadget is a length based simulation model, almost all processes are modelled in terms of length of an individual in a particular stock. The rationale for this is that natural processes are better explained in terms of size, e.g. prey must fit into the mouth of the predator. Thus predation and fleet selection are modelled in terms of size. These selection processes can very between predators (and fleets) and therefore Gadget allows the user to define this relationship in a number of ways. 
In Gadget there are a number of predator-prey relations that can be defined. They include the obvious case where one substock predates the other. Additionally a cannibalistic relationship can be defined if the substocks are modelled as an immature and a mature part of the same species. Fleets (survey and/or commercial) can be integrated into the model by being considered as one of the predators. A fleet can harvest one or both substocks in some or all areas. These relationship are essentially factored into three components: 

A) The amount which the predator wants to consume 
B) The size range the predator is able to consume
C) The size range of the prey which is available for consumption

The availability of a certain prey $p$ and the ability for predator $P$ to consume $p$ is linked by a length based suitability function $S_{P,p}(L,l)$ of one of the following forms:

Function name  | Formula 
------------- | -------------
`constant`  | $S_{Pp}(L,l) = \alpha$ 
`straightline`  | $S_{Pp}(L,l) = \alpha + \beta l$
`exponential` | $S_{Pp}(L,l) = \frac{\delta}{1+e^{(-\alpha-\beta l - \gamma L)}}$
`exponentiall50` | $S_{Pp}(L,l) = \frac{1}{1 + e^{-\alpha(l-l_{50})}}$
`richards` | $S_{Pp}(L,l) = \left(\frac{\delta}{1+e^{(-\alpha-\beta l - \gamma L)}}\right)^\eta$
`andersen` | $S_{Pp}(L,l) =  \begin{cases} \alpha + \gamma e^{-\frac{(ln(L/l)-\beta)^2}{\delta}}, & \text{if}\ a=ln(L/l) < \beta \\\alpha + \gamma e^{-\frac{(ln(L/l)-\beta)^2}{\eta}}, & \text{if}\ a=ln(L/l) > \beta \end{cases}$
`andersenfleet` | Same as above except $L$ is a parameter
`gamma` | $S_{Pp}(L,l) = \bigg(\frac{1}{(\alpha -1)\beta\gamma)}\bigg)^{(\alpha -1)}e^{(\alpha -1 -\frac{1}{\beta\gamma})}$

where $L$ and $l$ are the predator and prey length respectively. Note that when defining fleets their lengths are not *well* defined and in the case of the Andersen suitability function you should use the fleet variant of that function. Note that $S_{Pp}$ is in most cases between 0 and 1. $S_{P,p}(L,l)$ should therefore be interpreted as the percentage of prey abundance at length $l$ available to predator $P$ at length $L$.  

To help you to choose the appropriate Rgadget has a helper function, `suitability`, to help the user to investigate how a particular suitability function behaves, which allows the user to input the function name, parameters and the length of the predators and prey. Below is an example of how to calculate and visualise the exponential suitability function for different sizes of the 

```{r}
prey.length <- 1:50
pred.length <- seq(40,100,by=10) 

param <- c(alpha = -20, beta = 0.5,gamma = 0.1, delta = 1)

suit <- suitability(params = param, 
                    l = prey.length,
                    L = pred.length,
                    type = 'exponential',
                    to.data.frame = TRUE)

ggplot(suit,aes(l,suit,col=as.factor(L))) + geom_line()
```

In Gadget you can define whether a stock is available for consumption, i.e indicate that the stock is a prey, or is a predator (or both) by setting the `doeseat` and `iseaten` options in the stock file. You can make the stock available for consumption using the following `gadget_update` call:

```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update("iseaten",1) %>% 
  write.gadget.file(gd)
```

It is a little more complicated to define the predation parameters so it will be covered at a later stage. 

## Fleet operations

Human interactions in Gadget are often modelled as removals of a particular stock. These removals definde via a simplified stock object called `Fleet`, which inherits a more complex predator behaviour that a gadget stock can define (more on that later). The fleet operations are defined as a separate model component/file detailing the main attributes of the fleets. The defintion of a fleet is as follows:

* **Fleet type** which can be one of 5 types, `TotalFleet`,`NumberFleet`,`LinearFleet`,`EffortFleet` and `QuotaFleet`. 
* **Fleet name** name of the fleet
* **Suitability** how the fleet selection is defined
* **Catch data** a table of catch/effort by time step

Although the there are five different fleet types they can essentially be group into two classes of how the user can define the removals. These are the **Total fleets** where the total biomass or total number of removals are specified by the user and the **Effort fleets** that specify the removals in terms of harvest rate on available biomass/abundance. Note that in the Gadget manual harvest rate and effort is be used interchangeably here (although they are generally not same).  The user defines when these removals occur by specifying the year and times step catch/effort take place (see https://hafro.github.io/gadget/docs/userguide#fleet_files for further details).  

We will begin by looking at the effort type fleets. Their catch, $C_{plyt}$, of prey $p$ at length $l$, year $y$ and timestep $t$ is determined by the following equation:

$$
C_{plyt} = E_{yt}\Delta t S_{pl}N_{plyt}W_{plyt}
$$
where the $E$ denotes the harvest rate of the fleet, $S$ the suitability, $N$ the abundance and $W$ the mean weight for prey $p$ at length $l$. $\Delta t$ is then the length of the timestep, e.g. 0.25 for a quarter. When defining the harvest rate the user needs to create a table of rates per timestep in a particular format. So for example if the user want set this effort to 1 for all years at step 2 the following code can be used: 


```{r}
harvest.rate <- 
  structure(data.frame(year=schedule$year,step=2,area=1,number=1),
            area_group = list(`1` = 1)) 
```

Note that the `harvest.rate` object is simply a data frame with an associated area attribute (`area_group`) translating the areas in the data frame to a model area. Adding these attributes using `structure` may seem a bit of a overkill for this particular data set, but as we will see later on this becomes more useful when handling more diverse data structures. 

The fleet is then defined is a similar manner as for stocks, you can read/define a fleet with the `gadgetfleet` command. There is however a minor difference, multiple fleets can be defined in a single file. The fleet files can the be edited using the `gadget_update` function. So as in the case of creating a stock we will begin by creating an empty stock:
```{r,eval=FALSE}
gadgetfleet('Modelfiles/fleet',gd,missingOkay = TRUE)
```
where the `missingOkay` switch means that the function should create a new file if missing. The `gadget_update` is then supplied with one of the fleet type listed above, which in this case will be the `LinearFleet` fleet type: 

```{r}
gadgetfleet('Modelfiles/fleet',gd,missingOkay = TRUE) %>% 
    gadget_update('linearfleet',
                  name = 'simple_fleet',
                  suitability = 
                    list(simple_stock=list(type='function',suit_func = 'constant',value=0.2)),
                  data = harvest.rate) %>% 
  write.gadget.file(gd)
```

The suitabilty of the preys for the fleet is defined as list of all stocks caught by the fleet with a suitability function to each of them, allowing for wholly different prey selection between the various stocks. In this case the `constant` selection function is used, where 20 $\%$ of the whole stock at all sizes is available to the fleet. 

To see the effects of the fleet operations on our stock we can use the `gadget.fit` function:
```{r message=FALSE}
fit <- gadget.fit(wgts = NULL, gd = gd, params.file = 'params.in')
plot(fit,data = 'res.by.year',type='num.total') + 
  expand_limits(y=0)
```

This formulation of the fleet assumes that a fixed harvest rate is applied for all years. This is probably not representative of reality, so Gadget allows the user do define varying rates by year. To do that 

```{r}

```


# Recruitment



### Example
Simple stock recruitment model

# Aging process

# Growth


