---
title: "Adding components to the model"
output: 
  html_document:
    fig_height: 4
    fig_width: 8
    highlight: haddock
    theme: united
    toc: yes
    toc_float: yes
bibliography: library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Rgadget)
schedule <- 
  expand.grid(year = 1:10, step = 1:4) %>% 
  arrange(year)
gd <- gadget.variant.dir('simple_model')
```

# Gadget variables 

It can be tedious to change all the input files whenever you want to try a different
value for a certain input parameter. For example if you want to specify natural 
mortality as some thing else than 0 you can always do:
```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality',0.2)
```
And if you want to try many version of natural mortality you can obviously repeat 
this process for different values of M. There is however a more convenient approach 
to do this, namely Gadget switches or parameters. A Gadget parameter can be inserted
instead of any number in the input file (apart from likelihood data), and are marked
with the `#` character. So for the case of natural mortality we can now update the 
stock file to include a Gadget parameter by:

```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality',"#M")
```

And now we see that the value for natural mortality has been changed from 0 to `#M`.
Now write this to file and rerun run Gadget.
```{r echo=FALSE}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('naturalmortality','#M') %>% 
  write.gadget.file(gd)

Sys.setenv(GADGET_WORKING_DIR=normalizePath(gd)) 
callGadget(s=1,main='main',ignore.stderr = FALSE,log = 'simple_log')
```

After running this, assuming we did everything correctly, we should see that the 
file in the directory called `params.out` is no longer empty:
```{r echo=FALSE}
read_lines('simple_model/params.out') %>% 
  paste(collapse = '\n') %>% 
  cat()
```

This file is generated by Gadget based on the switches it encounters when reading in
the input files. It lists all parameters, their value as used in the simulation, upper
and lower bounds and whether the parameter should optimised (more on that later). You
then simply just change the value for M and rerun Gadget by supplying the parameter 
file as input. This can either be done by manually editing the parameter file or 
using the `init_guess` function:
```{r}
read.gadget.parameters('simple_model/params.out') %>% 
  init_guess('M',value = 0.2) %>% 
  write.gadget.parameters(file = 'simple_model/params.in')

callGadget(s=1,i='params.in')
```

Note that when supplying a parameter input you use the `i` argument in `callGadget`. 

Gadget parameters have a few more tricks up their sleeves. Notably you can apply 
functions or formulas to the parameter. For instance if you want multiply the value 
of `M` by 0.1 you can write that as:
```
(* 0.1 #M)
```
Note that functions and formulas are contained within round brackets, so that this
structure equates to `0.1*M`.

Similarly if you need to log transform your variable as `log(M)`, you can use:
```
(log #M)
```
 and these can be chained together:
```
(log (* 0.1 #M))
```
equates to `log(0.1*M)`. This allows you to apply fairly elaborate functions to the
parameter. And as in the case of variables formulas can then be inserted instead of
numbers. 


These formulas can be fairly complex and Rgadget provides mechanisms to manipulate 
Gadget formulae, both allowing you to evaluate the formula using `parse.gadget.formula`
and transform a R statement with `to.gadget.formulae`:

```{r}
## R expression to Gadget formula
to.gadget.formulae(quote((1+exp(a*b))))

## Gadget formula to a R expression
parse.gadget.formulae('(* #a #b)')

## evaluate expression
parse.gadget.formulae('(* #a #b)') %>% 
  eval(list(a=7,b=6))
```

For instance if you want the mean length at age, in for instance the initial 
conditions, to be based on the Von Bertanlanfy growth function:
$$l_a = L_\infty(1 - e^{-k(a - a_0)}) $$
you can do that for age 3 as an example using the `to.gadget.formulae` in the following manner:

```{r}
to.gadget.formulae(quote(linf*(1-exp(-1*k(3-a0)))))
```



#### Exercise
* Change the initial conditions in such a way you can control both the initial number 
of fish and the natural mortality using the parameter file. What happens to your stock
when you change these values?
* Play around with the Gadget formulae functions, e.g. parse and evaluate the 
following formula at $\alpha = 0.1$ and $l_{50} = 75$ :
```
 (/ 1 (+ 1 (exp (* (* -1 #alpha) (- 50 #l50)))))
```

# Predation

As Gadget is a length-based simulation model, almost all processes are modelled in
terms of length of an individual in a particular stock. The rationale for this is 
that natural processes are better explained in terms of size, e.g. prey must fit 
into the mouth of the predator. Thus predation and fleet selection are modelled 
in terms of size. These selection processes can very between predators (and fleets) 
and therefore Gadget allows the user to define this relationship in a number of ways. 
In Gadget there are a number of predator-prey relations that can be defined. They 
include the obvious case where one stock consumes another other. Additionally a
cannibalistic relationship can be defined if substocks are modelled as, for example,
an immature and a mature substock of the same species. Fleets (survey and/or commercial)
are integrated into the model by being considered one of the predators. A fleet can
harvest one or both substocks in some or all areas. These relationship are essentially
factored into three components: 

A) The amount which the predator wants to consume 
B) The size range the predator is able to consume
C) The size range of the prey which is available for consumption

The availability of a certain prey $p$ and the ability for predator $P$ to consume $p$ is linked by a length-based suitability function $S_{P,p}(L,l)$ of one of the following forms:

Function name  | Formula 
------------- | -------------
`constant`  | $S_{Pp}(L,l) = \alpha$ 
`straightline`  | $S_{Pp}(L,l) = \alpha + \beta l$
`exponential` | $S_{Pp}(L,l) = \frac{\delta}{1+e^{(-\alpha-\beta l - \gamma L)}}$
`exponentiall50` | $S_{Pp}(L,l) = \frac{1}{1 + e^{-\alpha(l-l_{50})}}$
`richards` | $S_{Pp}(L,l) = \left(\frac{\delta}{1+e^{(-\alpha-\beta l - \gamma L)}}\right)^\eta$
`andersen` | $S_{Pp}(L,l) =  \begin{cases} \alpha + \gamma e^{-\frac{(ln(L/l)-\beta)^2}{\delta}}, & \text{if}\ a=ln(L/l) < \beta \\\alpha + \gamma e^{-\frac{(ln(L/l)-\beta)^2}{\eta}}, & \text{if}\ a=ln(L/l) > \beta \end{cases}$
`andersenfleet` | Same as above except $L$ is a parameter
`gamma` | $S_{Pp}(L,l) = \bigg(\frac{1}{(\alpha -1)\beta\gamma)}\bigg)^{(\alpha -1)}e^{(\alpha -1 -\frac{1}{\beta\gamma})}$

where $L$ and $l$ are the predator and prey lengths respectively. Note that when 
defining fleets, their lengths are not *well* defined and in the case of the 
Andersen suitability function you should use the fleet variant of that function. 
Note that $S_{Pp}$ is in most cases between 0 and 1. $S_{P,p}(L,l)$ should therefore
be interpreted as the percentage of prey abundance at length $l$ available to 
predator $P$ at length $L$.  

To help you to choose the appropriate suitability function within Gadget, Rgadget 
has a helper function, `suitability`, to help the user to investigate how a 
particular suitability function behaves, which allows the user to input the 
function name, parameters and the length of the predators and prey. Below is an 
example of how to calculate and visualise the exponential suitability function for
different sizes of the predator and prey.

```{r}
prey.length <- 1:50
pred.length <- seq(40,100,by=10) 

param <- c(alpha = -20, beta = 0.5,gamma = 0.1, delta = 1)

suit <- suitability(params = param, 
                    l = prey.length,
                    L = pred.length,
                    type = 'exponential',
                    to.data.frame = TRUE)

ggplot(suit,aes(l,suit,col=as.factor(L))) + geom_line()
```

In Gadget you can define whether a stock is available for consumption, i.e indicate that
the stock is a prey, or is a predator (or both) by setting the `doeseat` and `iseaten`
options in the stock file. You can make the stock available for consumption using the
following `gadget_update` call:

```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update("iseaten",1) %>% 
  write.gadget.file(gd)
```

It is a little more complicated to define the predation parameters so it will be 
covered at a later stage, when predator-prey interactions are discussed. 

## Fleet operations

Human interactions in Gadget are often modelled as removals of a particular stock.
These removals are defined via a simplified stock object called `Fleet`, which 
inherits a less complex predator behaviour than can be defined in a gadget stock 
(more on that later). The fleet operations are defined as a separate model 
component/file detailing the main attributes of the fleets. The defintion of a 
fleet is as follows:

* **Fleet type** which can be one of 5 types, `TotalFleet`,`NumberFleet`,`LinearFleet`,`EffortFleet` and `QuotaFleet`. 
* **Fleet name** name of the fleet
* **Suitability** how the fleet selection is defined
* **Catch data** a table of catch/effort by time step

Although the there are five different fleet types they can essentially be grouped
into two classes of how the user can define the removals. These are the 
**Total fleets** where the total biomass or total number of removals are specified
by the user and the **Effort fleets** that specify the removals in terms of 
harvest rate on available biomass/abundance. Note that in the Gadget manual and here, 
harvest rate and effort are used interchangeably, although they are generally not 
same.  The user defines when these removals occur by specifying the year and time 
steps catch/effort take place (see the [fleet files section](https://hafro.github.io/gadget/docs/userguide#fleet_files) of the Gadget User Guide
for further details).  

We will begin by looking at the effort type fleets. Their catch, $C_{plyt}$, of 
prey $p$ at length $l$, year $y$ and timestep $t$ is determined by the following 
equation:

$$
C_{plyt} = E_{yt}\Delta t S_{pl}N_{plyt}W_{plyt}
$$
where the $E$ denotes the harvest rate of the fleet, $S$ the suitability, $N$ the
abundance and $W$ the mean weight for prey $p$ at length $l$. $\Delta t$ is then 
the length of the timestep, e.g. 0.25 for a quarter. When defining the harvest rate 
the user needs to create a table of rates per timestep in a particular format. So 
for example if the user want set this effort to 1 for all years at step 2 the 
following code can be used: 


```{r}
harvest.rate <- 
  structure(data.frame(year=unique(schedule$year),step=2,area=1,number=1),
            area_group = list(`1` = 1)) 
```

Note that the `harvest.rate` object is simply a data frame with an associated area
attribute (`area_group`) translating the areas in the data frame to a model area. 
Adding these attributes using `structure` may seem a bit of a overkill for this 
particular data set, but as we will see later on this becomes more useful when 
handling more diverse data structures. Warning: using the dplyr `mutate` function
removes these attributes. 

The fleet is then defined is a similar manner as for stocks, you can read/define
a fleet with the `gadgetfleet` command. There is however a minor difference: 
multiple fleets can be defined in a single file. The fleet files can then be 
edited using the `gadget_update` function. So as in the case of creating a stock 
we will begin by creating an empty stock:
```{r,eval=FALSE}
gadgetfleet('Modelfiles/fleet',gd,missingOkay = TRUE)
```
where the `missingOkay` switch means that the function should create a new file if
missing. The `gadget_update` is then supplied with one of the fleet type listed 
above, which in this case will be the `LinearFleet` fleet type: 

```{r}
gadgetfleet('Modelfiles/fleet',gd,missingOkay = TRUE) %>% 
    gadget_update('linearfleet',
                  name = 'simple_fleet',
                  suitability = 
                    list(simple_stock=list(type='function',suit_func = 'constant',value=0.2)),
                  data = harvest.rate) %>% 
  write.gadget.file(gd)
```

The suitabilty of each prey for removal by the fleet is defined as a list of all 
stocks caught by the fleet with a suitability function assigned to each of them, 
allowing for wholly different prey selection between the various stocks. In this 
case the `constant` selection function is used, where 20$\%$ of the whole stock
at all sizes is available to the fleet. 

To see the effects of the fleet operations on our stock we can use the `gadget.fit` function:
```{r message=FALSE, out.width = "50%", fig.show = "hold"}
fit <- gadget.fit(wgts = NULL, gd = gd, params.file = 'params.in')
plot(fit,data = 'res.by.year',type='num.total') + 
  expand_limits(y=0)  

plot(fit,data = 'res.by.year',type='num.catch') + 
  expand_limits(y=0) 
  
```

This formulation of the fleet assumes that a fixed harvest rate is applied for 
all years. This is probably not representative of reality, so Gadget allows the 
user do define varying rates by year. To do that you simply edit the harvest rate 
data frame above and update the fleet file accordingly:

```{r, message=FALSE, out.width = "50%", fig.show = "hold"}
harvest.rate <- 
  structure(data.frame(year=unique(schedule$year),step=2,area=1,
                       ## HR are now random variations around 1
                       number= exp(rnorm(length(unique(schedule$year))))),
            area_group = list(`1` = 1)) 

## update the fleet file
gadgetfleet('Modelfiles/fleet',gd,missingOkay = TRUE) %>% 
    gadget_update('linearfleet',
                  name = 'simple_fleet',
                  suitability = 
                    list(simple_stock=list(type='function',suit_func = 'constant',value=0.2)),
                  data = harvest.rate) %>% 
  write.gadget.file(gd)

## And re-run

fit <- gadget.fit(wgts = NULL, gd = gd, params.file = 'params.in')
plot(fit,data = 'res.by.year',type='num.total') + 
  expand_limits(y=0)  

plot(fit,data = 'res.by.year',type='num.catch') + 
  expand_limits(y=0) 

```

### Excercise

* `TotalFleet` and `NumberFleet` are defined exactly the same way as the 
`LinearFleet`, apart from the interpretation of the data file which now tells 
Gadget how many fish or how many kilograms are consumed by the fleet. Redo the
example above with either of the fleet types, but make sure you do not overconsume
(i.e., don't take more that is available).

* Where do you think it is possible to define model variables in the definition 
of the fleet file? Change as much as you can so the model can be controlled by 
  the parameter file.  


# Recruitment

There are two types of recruitment processes in Gadget, those that are the result of
spawning and what is called **renewal**. The difference between the two processes is 
that the spawning process depends on the size of the spawning stock while the renewal
process is independent from other processes in the model. Setting up the spawning 
process is fairly involved and will be covered in later sections. Today we will focus 
on the renewal process and how it is defined.  

Renewals in Gadget allow the user to freely define the number of individuals that are
recruited into the stock at any time, area and age. This is done by setting up a 
schema not unlike the one used for the initial conditions with the addition of the 
timing of the recuitment. For our simple model we will start by defining a data frame
with the recruits:


```{r}
recruits <- 
  tibble(year = 1:10, ## Year of recruitment,
         step = 1, ## timing of recruitment (q1)
         area = 1, ## where does the rec. take place
         age = 1, ## age of recruits
         number = 1, ## num. of recruits (x10 000)
         mean = 1, ## mean length
         stddev = .1, ## std in length
         alpha = 1, ## a in w = aL^b
         beta = 1)
```

This table will add 10 000 individuals at age 1 to our simulation every year. To add this to our model we need to update the stock file:

```{r}
gadgetstock('simple_stock',gd) %>% 
  gadget_update('doesrenew',
                normalparam = recruits) %>% 
  write.gadget.file(gd)
```

and we can now re-run the model to see the effects of the recruitment to the abundance in the stock:

```{r out.width = "50%", fig.show = "hold"}
fit <- gadget.fit(wgts = NULL, params.file = 'params.in',gd=gd)

plot(fit,data = 'res.by.year',type='num.total') + 
  expand_limits(y=0)  

plot(fit,data = 'res.by.year',type='num.catch') + 
  expand_limits(y=0) 

```


# Exercise

For the remainder of the session we are going to play with the simple model we have
created. Below are a couple of ideas to play with the model:

* Try to insert model variables where ever you can. 
* Investigate how you can introduce randomness into the model, e.g variability in recruitment and fishing effort.
* Change the time horizon, i.e run the model for 50 years, and investigate the 
effects of different harvest rates on the biomass levels. 
  + For those feeling adventurous think about how to set up a stochastic simulation to estimate the maximum sustainable yield.




