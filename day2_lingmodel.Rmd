---
title: "Ling model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Building more complex Gadget models

As touched on in the [Introduction](link), Gadget is particularly useful in a stock
assessment setting when age data are absent or sparse. In these cases,
parameterising age-based stock assessement models may require a lot of
pre-processing based on sparse age data to calculate the model input (e.g., catch 
at age), which maythen be error-prone. Using length- and age-based models instead 
are appealing because comparisons sparse data can be directly incorporated into the
model likelihood, rather than pre-processed.

In this example we present the stock assessment model used for ling *Molva molva*
in Icelandic fisheries as an example of a length- and age-based model with all the 
standard components implemented, including natural mortality, fishing, growth,
maturation, and recruitment.

## Model initiation

First we load Rgadget, set up directories, and some default model dimensions and names to use throughout


```{r ling}
library(Rgadget)

base_dir <- 'ling_model'
vers <- c('01-base')
gd <- gadget.variant.dir(sprintf(paste0("%s/",vers),base_dir))

schedule <- 
  expand.grid(year = 1982:2018, step = 1:4) %>% 
  arrange(year)

gadgetfile('Modelfiles/time',
           file_type = 'time',
           components = list(list(firstyear = min(schedule$year),
                                  firststep=min(schedule$step),
                                  lastyear=max(schedule$year),
                                  laststep=max(schedule$step),
                                  notimesteps=c(4,3,3,3,3)))) %>% 
  write.gadget.file(gd)

## Write out areafile and update mainfile with areafile location
gadgetfile('Modelfiles/area',
           file_type = 'area',
           components = list(list(areas = 1,
                                  size = 1,
                                  temperature= schedule %>% mutate(area = 1, temperature = 5)))) %>% 
  write.gadget.file(gd)

```

## Define stocks

Now that we have attributes of the time and place, we can insert a population into
it. Remember that population subcomponents are called 'stocks' in Gadget. To do this, we use the
function `gadgetstock`. However, using gadgetstock also has some default settings built in for
convenience. The first one is that it automatically sets up the Gadget model with growth
implemented. If we first generate a default stock (with name 'test'), we find that much of 
the structural information we supplied above was not supplied, and most of the other settings are turned off (value = 0, more on those settings later).

```{r}
gadgetstock('test',gd,missingOkay = TRUE) 
```


However, growth is the exception: `doesgrow` is turned on (value set to 1) with the growth
function `lengthvbsimple` implemented and parameters supplied to that function as 
'test.Linf', 'test.k' (multiplied by 0.001 to keep it help the optimisation routine by 
placing it on a similar scale to other parameters), 'test.walpha', 'test.wbeta', 
'test.bbin' (also multiplied by a scaler), and a constant value for `maxlengthgroupgrowth`.

### Growth

Growth is implemented using three processes in Gadget. The first process is described by a 
growth function that shows how mean body size at age changes over time. The second process
generates variability around that mean length at age relationship using a beta binomial 
distribution (currently, no other distributions are implemented). The third process translates
between lengths and weights.

The first and third processes are implemented together via the chosen growth function. In the 
default Rgadget `lengthvbsimple` function implementation, the length at infinity and growth rate
paramaters supplied to this function are automatically named 'test.Linf' and 'test.k' to 
signify these parameters only refer to growth within the test stock.  Similarly, an 
exponential relationship is used to represent growth, using the automatically named 
'test.walpha' and 'test.wbeta' parameters. Because they are by default supplied here and 
supplied as switches with '#' preceding them, they will be automatically 
generated in the parameter file when an initial Gadget simulation is run, and their values can 
then be controlled from this file (as demonstrated in Day 1 material). Beyond `lengthvbsimple`,
there are a variety of other growth functions that can be implemented, 
including those that implement starvation, time- and area- dependent growth, or reading weights 
from a length-weight key. These are described in the Gadget User Guide.

The second process is implemented in the default by providing a single switch 'test.bbin' 
parameter to the beta-binomial distribution, along with a constant value for 
maxlengthgroupgrowth. The beta-binomial distribution is implemented in Gadget because high
flexibility in the distribution of growth deviations is provided by changing only a single
estimable parameter. The constant value for maxlengthgroupgrowth describes the maximum number of
length bins a fish is allowed to grow in a single timestep, so it should be set high enough to 
be realistic.

As growth is on of the major determinants of population dynamics, some words of caution should
be mentioned in any discussion of the implementation of growth in
Gadget. The first is that the implementation of the Von Bertalanffy growth curves used in Gadget
are based on predicting changes in length over a time step, based on the length at the end of 
the previous time step and the length of the time step. Therefore, length is not directly 
associated with age. This is a useful property when Gadget is being used for estimation, because
it implies that age data are not a prerequisite to estimating growth (although it does help a 
lot). However, it also implies that the parameter values obtained when estimating the length at
infinity and growth rate parameters using length and age data in non-linear models estimation
(standard methods) are not directly comparable to those implemented in Gadget. In particular, 
length at infinity using standard estimation methods with age data would represent the mean 
length attainable at infinity, but in Gadget it represents the maximal length that could be 
expected at infinity, and therefore most fish tracked should actually be below this value. If 
individuals happen to surpass length at infinity in one time step due to the variability in 
growth implemented via the beta binomial distribution, those individuals will exhibit negative 
growth in the next time step, a process that is not represented by standard methods of 
estimation using age data. Therefore, care should be taken that any final values used for length
at infinity within Gadget should be roughly above that expected of most fish observed, in order
to avoid accidentally implementing unexpected and unrealistic negative growth.

The second is that although the beta-binomial distribution has proven to be a very useful
distribution for capturing realistic patterns in the variability of the growth process, it is
not a very well-known or intuitive distribution. High values of beta produce a narrow
distribution, while lower values produce a more dispersed distribution with a larger right-hand
tail. Very low values should be avoided because it changes the expected shape of the
distribution. In addition, the default value of maximum 15 length bin steps by which a fish
could grow is set to be generous to allow the beta-binomial enough space to estimate the shape
of the distribution without being confined by an upper limit. However, in practice, where 
growth is difficult to estimate or has a very narrow distribution, setting this parameter to a
much lower value (2 - 4) can sometimes better capture observed patterns in growth variability.

Finally, it should be kept in mind that growth, like all other time-dependent processes, is
implemented within Gadget according to the time steps provided, not corresponding to an annual
basis. For example, a model with quarterly time steps would yield annual growth based on delta
t = 4, whereas the same in monthly time steps would yield delta t = 12. Likewise, setting
`maxlengthgroupgrowth` to 2 would be far more constricting for a model with quarterly time 
steps than a model with monthly time steps. An exception to this implementation is values for
mortality: they are expected to be suppled as annual mortality rates, and are therefore
subsequently divided among the time steps before implementation (e.g., so that M = 0.2 is the 
same in quarterly and monthly models).

### Maturation as multi-'stock' models

#### Generating stocks

In Gadget, maturation is modeled as a distributional shift between 'stocks', or more
subcomponents of a true biological stock. In the case of the most often analyzed fish stocks,
this simply means that immature individuals are tracked as within the immature 'stock' until
they 'transition' to mature stock component.  This structure is convenient because the
generalized multi-'stock' implementation of
life stages can be applied to more biologically complex scenarios that have more than two life
stages or biologically distinct components that need to be tracked separately (e.g., by sex), 
but still contribute to the entire population.

For ling, we set up an immature and a mature stock files using the `gadgetstock` function,
then update the 'stock' component of the file using `gadget_update`. Each 'stock' requires
a separate stock file with all biological processes defined; therefore each stock can have
different processes described for each stock. For
example, note that the stocks are also structured a little bit differently: since we know
young mature and old immature ling don't exist, we don't bother tracking them in the model.

```{r}
mat_stock <- 'lingmat'
imm_stock <- 'lingimm'

## setup the immature stock first
ling.imm <- 
  gadgetstock(imm_stock,gd,missingOkay = TRUE) %>%
  gadget_update('stock',
                minage = 3,
                maxage = 10,
                minlength = 20,
                maxlength = 160,
                dl = 4,
                livesonareas = 1)  

ling.mat <-
  gadgetstock(mat_stock,gd,missingOkay = TRUE) %>%
  gadget_update('stock',
                minage = 5,
                maxage = 15,
                minlength = 20,
                maxlength = 160,
                dl = 4,
                livesonareas = 1) 
```

As described above in the **Growth** section, default settings are provided by the
`gadgetstock` function. However, those settings give parameters that named to be
stock-specific. To simplify the model a bit, we change the parameters to have the same 
value in both stocks, so that both stocks are governed by the same growth equation:

```{r}
 ling.imm <-
   ling.imm %>%
  gadget_update('doesgrow', 
                growthparameters=c(linf='#ling.Linf', 
                                   k=to.gadget.formulae(quote(0.001*ling.k)),
                                   alpha = '#ling.walpha',
                                   beta = '#ling.wbeta'),
                beta = to.gadget.formulae(quote(10*ling.bbin))) 

  ling.mat <-
   ling.mat %>%
  gadget_update('doesgrow', 
                growthparameters=c(linf='#ling.Linf', 
                                   k=to.gadget.formulae(quote(0.001*ling.k)),
                                   alpha = '#ling.walpha',
                                   beta = '#ling.wbeta'),
                beta = to.gadget.formulae(quote(10*ling.bbin))) 

```

Also notice that although it is necessary to define the structural arguments listed above
(minage, maxage, minlength, maxlength, dl, and livesonareas), updating the 'stock' component
with gadget_update also sets up a few more convenient default settings in the gadget stock
file.

```{r}

print('Immature')
ling.imm
print('Mature')
ling.mat

```

In particular, `growthandeatlengths` has been supplied with a file path name	'Aggfiles/lingmat.stock.len.agg', which corresponds with a file that will be automatically generated once the stock file is written. This new aggregation file (or 'Aggfile') is required by Gadget, and contains information on how to aggregate true lengths into length bins as individuals are tracked through the model. In the default case, these bins are simply defined by minlength, maxlength, and dl, but in theory they could also be set at a higher resolution to conserve memory. IS THIS RIGHT? It also becomes important for the purposes of comparing simulations to data, so this file will be revisited later on Day 3 when model-fitting procedures are introduced. 

In addition, natural mortality parameters have been supplied as automatically named switches ('lingimm.M' or 'lingmat.M') for every age. In the default case, mortality is not age-dependent so the same stock-specific name is given for every age.

#### Maturation

To implement maturation, we only want the immature stock to be able to mature and 
transition to the mature stock. Therefore, `doesmove` and `doesmature` components are both
switched on (values set to 1) by supplying additional information to them, whereas neither of
these are switched on for the mature stock. 

```{r}
mat_stock <- 'lingmat'
imm_stock <- 'lingimm'

## setup the immature stock first
ling.imm <- 
  ling.imm  %>% 
  gadget_update('doesmature', 
                maturityfunction = 'continuous',
                maturestocksandratios = 'lingmat 1',
                coefficients = '( * 0.001 #ling.mat1) #ling.mat2 0 0') %>% 
  gadget_update('doesmove',
                transitionstocksandratios = 'lingmat 1',
                transitionstep = 4)

```

Maturation is split into two-step process in Gadget. At what length they transition is defined
by a maturation function in the `doesmature` component, but the seasonal timing of the
maturation process is described by the `doesmove` component. Both components additionally
allow for maturation / transition into multiple stocks, therefore requiring the stock names
and corresponding ratios that describe what proportion of the immature should mature or
transition into each stock (for example, into a female versus male stock). Our example shows
the all (ratio = 1) immature ling to be maturing into the mature stock ('lingmat') under the
argument `maturestocksandratios`, as well as transitioning to the same stock (under argument
`transitionstocksandratios`) into the fourth time step of every year. 

Note that transition in Gadget is only currently implemented as a process that occurs for 
only the oldest age-length bins of a stock. When a stock transitions, the ratio supplied by
transition `transitionstocksandratios` determines what proportion from the oldest age-length
bins is removed; these then are placed into the same age-length bins of the destination 
stock. If that bin does not exist in the destination stock, or transitioning is not defined 
to occur, then the fish remain in the oldest age-length bins of the source stock, which act 
as plus-groups.

The maturity function used in our example ('continuous') reflects a logistic maturation curve
that can be length, age, or length- and age-dependent. The first two parameters listed under
the `coefficients` correspond with length-dependency (alpha and L50, respectively), whereas
the last two correspond with age-dependency (beta and a50, respectively). Therefore, for ling,
we have only implmented length-dependency. The Gadget User Guide describes other possible
maturity functions, which implement for example a dependency on body condition, instantaneous 
maturation (rather than seasonal transition), and step-wise maturation of whole stocks.

### Initial conditions

The model structures defined in the previous sections shows that numbers within each stock
will be tracked in simulations for both stocks at a certain age, within one of 35 length bins,
and on area 1. 

```{r}
print('Immature')
ling.imm
print('Mature')
ling.mat
```


As Gadget is set up as a forward simulation, initial conditions need to be supplied to each
bin defined by a stock's structure. For example, the immature stock needs 11 age x 35 length x
1 area bins to contain initial numbers of individuals. Gadget is set up by default to put
10,000 fish in each age group per area; however, at any point in time, including the initial
time step of the model, the numbers at age of a real population are not expected to be equal.
In any population with mortality, for example, there should be fewer older individuals than
younger individuals. Similarly, differences between areas can shift all numbers at age to be
higher or lower than those found in another area. In addition, each set of 10,000 fish, which
correspond to an age and area, need to be assigned length bins according to a mean length, and
some level of variability around that mean. 

These two attributes, numbers for each age x area group and distribution of those numbers
across length bins, are controlled by using `gadget_update` to modify the `'initialconditions'`
component of the stock file. In our ling example, this is done by supplying a data frame to an
argument called `normparam`. Calling the `normparam` argument specifies the distribution of
lengths to be according to a normal parameteric distribution, and that weights are calculated
from these are according to an exponential equation of the same form as supplied in under the
section **Growth**. Alternatively, it is possible to implement weights according to condition
factor and length-weight key, or supply the numbers that make up the stock distribution rather
than a theoretical distribution, but implementation methods for these should be referred to in
the Gadget User Guide.

The data frame supplied to `normparam` needs one row per age x area combination; therefore the 
first two columns specify ages found in the stock, all with an area set to 1. [That is, using
the `.` placeholder passes the ling.imm object to that location, where minage and maxage 
information is extracted]. The next two columns implement differences among ages and 
differences among areas respectively, by supplying age- and area-specific factors against 
which the 10,000 initial fish will be multiplied. These columns are called 'age.factor' and 
'area.factor', respectively, and must correspond with the area and age columns such that the 
same ages in two different areas will have the same age.factor and two different ages within 
the same area have the same area.factor. IS THIS RIGHT?. The next two columns reflect the mean 
length and standard deviation that will be used to distribute lengths for that age x area 
combination. Note that although different lengths at age could in theory be supplied for 
different areas, only one growth function is supplied for all areas, so justifying the utility 
of different lengths at age among different areas for only the initial time step may be 
difficult. Standard deviations are supplied by age age x area groups. Along with the 
parameters used to describe the exponential length-weight relationship (alpha and beta, last
columns of the data frame, these are all empirically derived constants. However, in the code
below, we supply standard deviations as numerical values but alpha and beta as switches, as 
the latter are also used in other components of the stock file (growth).

The data_frame described above can be filled with constants, but as we saw on Day 1, we can
also replace these constants with parameter switches whose values can be controlled within the
parameter file, or even formulas containing constants, switches, or both. Today we will use
this capability to set the initial conditions of the ling model to have two properties that aid
in realism and internal consistency. First, we would like numbers at age to be distributed
according to a total mortality experienced by the population at the beginning of the time
series. Second, we would like to set mean lengths of the age groups to be those expected by the
same Von Bertalanffy relationship implemented under the **Growth** section. 

To implement the first pattern via the age.factor column, a different equation per age is supplied. Each equation is based on an age-specific intial number parameter (e.g.,
'lingimm.init.3' for age 3), which is then multiplied times the exponent of negative total
mortality rate times the number of annual time steps since recruitment (i.e., the age). To
calculate total mortality, the presupplied natural mortality parameter 'lingimm.M' is added to
an addition user-defined parameter 'ling.init.F', that represents an initial level of fishing
mortality experienced before the first time step of the model. Under this transformation, all
initial parameters ('lingimm.init.3', 'lingimm.init.4', etc.) have the same interpretation:
they are the back-calculated recruitment values for the year classes to which the observed 
ages correspond. Implementing the intial parameters with a consistent interpretation yields 
the benefits of expecting their values to be on roughly the same scale and fosters easier
communication (e.g., fixing all age-specific parameters to the same value would denote fixed
recruitment during the years prior to the time series).

To implement the second pattern, in mean lengths-at-age provided, we can borrow an Rgadget
convenience function 'von_b_formula' that writes out the `lengthvbsimple` equations as Gadget.
To be internally consistent, the parameters supplied to this convenience function, as well as
the alpha and beta columns defined in the `normalparam` data frame, are set to be the same as
those used when implementing growth in the `doesgrow` component above. Notice one more
parameter called 'ling.recl' is also supplied for internal consistency with recruitment
settings, which are explained in the next section.

```{r}

init_sigmas <- rep(1, length(ling.imm[[1]]$minage:ling.imm[[1]]$maxage))

 ling.imm <-
   ling.imm %>%
  gadget_update('initialconditions',
                normalparam = data_frame(age = .[[1]]$minage:.[[1]]$maxage,
                                         area = 1,
                                         age.factor = parse(text=sprintf('exp(-1*(lingimm.M+ling.init.F)*%1$s)*lingimm.init.%1$s',age)) %>% 
                                           map(to.gadget.formulae) %>% 
                                           unlist(),   
                                         area.factor = '#lingimm.init.scalar',
                                         mean = von_b_formula(age,linf='ling.Linf',k='ling.k',recl='ling.recl'),
                                         stddev = init_sigmas,
                                         alpha = '#ling.walpha',
                                         beta = '#ling.wbeta')) 

ling.mat <-
  ling.mat %>% 
  gadget_update('initialconditions',
                normalparam = data_frame(age = .[[1]]$minage:.[[1]]$maxage,
                                         area = 1,
                                         age.factor = parse(text=sprintf('exp(-1*(lingmat.M+ling.init.F)*%1$s)*lingmat.init.%1$s',age)) %>% 
                                           map(to.gadget.formulae) %>% 
                                           unlist(),
                                         area.factor = '#lingmat.init.scalar',
                                         mean = von_b_formula(age,linf='ling.Linf',k='ling.k',recl='ling.recl'),
                                         stddev = init.sigma$ms[age],
                                         alpha = '#lingmat.walpha',
                                         beta = '#lingmat.wbeta'))  
```


### Recruitment

### Reference Weight

Finally, some implementations of the initial conditions and growth functions translate between
lengths and weights via a constant length-weight key. Although the functions provided in our
example here do not depend on it, we provide an example in the following code for how
gadget_update can be used to update the `'refweight'` component to provide the key as a data
frame, which is the same for both stocks.

### Potential as a fishable resource / prey

```{r}

lw_pars <- c(0.0001, 3) #parameters defining the length-weight exponential relationship

 ling.imm <-
   ling.imm %>%
  gadget_update('iseaten',1) %>% 
  gadget_update('doesrenew',
                normalparam = data_frame(year = year_range,
                                         step = 1,
                                         area = 1,
                                         age = .[[1]]$minage,
                                         number = parse(text=sprintf('ling.rec.scalar*ling.rec.%s',year)) %>% 
                                           map(to.gadget.formulae) %>% 
                                           unlist(),
                                         mean = von_b_formula(age,linf='ling.Linf',k='ling.k',recl='ling.recl'),
                                         stddev = '#ling.rec.sd',
                                         alpha = '#lingimm.walpha',
                                         beta = '#lingimm.wbeta')) %>% 
  gadget_update('refweight',
                data=data_frame(length=seq(.[[1]]$minlength,.[[1]]$maxlength,.[[1]]$dl),
                                mean=lw_pars[1]*length^lw_pars[2]))




ling.mat <-
  ling.mat %>% 
  gadget_update('iseaten',1) %>% 
  gadget_update('refweight',
                data=data_frame(length=seq(.[[1]]$minlength,.[[1]]$maxlength,.[[1]]$dl),
                                mean=lw_pars[1]*length^lw_pars[2]))


## write to file
ling.imm %>% 
  write.gadget.file(gd$dir)

ling.mat %>% 
  write.gadget.file(gd$dir)


```


