---
  title: "Tidyverse"
author: "Pamela J. Woods"
date: "13/08/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Idealogy behind R for Data Science

Tidyverse is a collection of R packages that enables tools for data science, and is 
especially useful for data wrangling, manipulation, visualization, and communication
of large data sets. Extensions of tidyverse 
also enable direct connections and manipulation with SQL databases (e.g, dbplyr). Here
we briefly introduce some main concepts when this programming, all derived directly from
the open access book R for Data Science by Garrett Grolemund and Hadley Wickham (which 
can be found [here](https://r4ds.had.co.nz/)). 

As you can read [here](https://r4ds.had.co.nz/introduction.html), the main idea behind
using tidyverse is that exploratory data analysis in R is composed of a few main steps:
first is importing and tidying data, then iteratively transforming, visualising, and
modeling data to understand patterns held by them, and finally communicating results
effectively. Tidyverse was designed as a programming method and collection of functions
that are focused on easing these tasks into a simple uniform routine that can be applied
to any dataset. Standardizing the approach taken toward any data science project then 
aids reproducability of any project as well as the ability to collaborate on a project.

# The foundation: tibbles, tidy data, and piping

## Tibbles

First we need to indstall and load Tidyverse. After that we can have a look at what at 
the main form of data storage, called a tibble:
```{r tidyverse}
install.packages('tidyverse')
install.packages('nycflights13') # this is an example data package
```

```{r tibble}
library(tidyverse)
library(nycflights13)
flights
```

Note that a tibble is essentially the same as a data frame (for example made with data.frame) but with some useful information printed (e.g., dimensions and data types), as well as some restrictions placed on how it an be manipulated. These help prevent common errors. For example, recycling is possible as it is in data frames but less flexible:

```{r tibbleerror}

flights$year <- c(2013, 2014)
flights$year <- rep(2014, 7)

```

## Tidy data
In addition, the above data may look like a standard data set obtained from anywhere,
but it is not. It has already been formatted as 'tidy data'. Although data can be 
represented a variety of ways in tables for visualization, but for data manipulation
and analysis, there is only one format that is much easier to use than others. 
Therefore, all data should be transformed into this format before analyzing. This 
format is called the 'tidy' dataset in tidyverse, and following three rules make a 
dataset 'tidy':
1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.

If, for example, the flights dataset were organized such that each carrier, origin, or 
dest had their own sets of columns, the data would no longer be tidy.

## Piping

In base R programming, functions wrap around the objects that they are applied to, which
are often indexed, and this manipulated object is saved as a new one. What is written is
arranged like an onion: in the following example, the first step of the command is in
the center of code (calling the object flights), followed by indexing the 15th and 16th
columns. As we move away from the center, a function is applied, and finally the output
of that function is assigned to a new object. 

```{r base}
sub <- apply(flights[,c(15:16)], 2, mean, na.rm = T)
```

Piping, or using '%>%' to pass objects from one function to the next, introduces a
programming method that makes the process more intuitive by alligning the code with the
order of operation:

```{r pipe}
flights %>% 
  select(15, 16) %>%  # or use select(air_time, distance)
  apply(., 2, mean, na.rm = T) -> sub
```
In the above code, the flight tibble was piped into the 'select' function, which indexed
its 15th and 16th rows only. 'Select' does not require an argument where flights is
referenced because it comes from within tidyverse, so comes already compatible with 
piping. Note that selecting by column name (no quotations needed) is also possible and
more useful in most cases. After being piped to 'select', the result was then piped to 
the function 'apply'. 'Apply' is an old function that is not pipe-friendly; therefore, 
it requires the placeholder '.', which represents 'that which is piped', to be placed 
where the input data frame is expected. Finally, this modified data frame 
is assigned to 'sub' at the end, but alternatively it could have been assigned at the 
beginning as in the non-piped version.

#The power of tidyverse: all you need in a handful of functions

As in the 'select' function, there are a variety of functions that come with the
tidyverse package, but only a small set are needed to do almost any kind of data 
wrangling that you ever wanted to do. These are the only functions we touch on in this
brief introduction. However, beyond tidyverse, there are also a variety of 
packages that implement more advanced piping-compatible functions that speed the 
manipulation of large data sets in particular (e.g., dbplyr, purrrlyr). 

The most commonly used tidyverse commands, with a brief description, include:
* select() - select columns
* filter() - retain rows according to boolean criteria
* arrange() - sorts data
* rename() - renames existing columns
* mutate() - writes new columns
* group_by() / ungroup() - groups data according to column values (such as factors)
* summarise() - reduces dataset to an aggregated leve. Used after grouping (which 
defines the aggregation level) and along with functions that define how to aggregate
(e.g., count(), n(), sum(), mean()).
* gather() / spread() - converts data between the tidy format and 'long' formats
* full_join(), left_join(), etc. - joins data contained in two data frames according to
certain criteria that define how rows are compatible (i.e., joining in relational 
databases)

Below is an example of how the function 'apply' in the previous example can be replaced
using tidverse commands, as well as functions such as 'aggregate' using 'group_by' and 'summarise'

```{r replace}
  flights %>%
  select(air_time, distance) %>% 
  summarise(mn_airtime = mean(air_time, na.rm = T),
            mn_distance = mean(distance))

 # or if the operation should occur within groups:
  flights %>%
  select(dest, air_time, distance) %>%
  group_by(dest) %>% 
  summarise(mn_airtime = mean(air_time, na.rm = T),
            mn_distance = mean(distance))
```

Here is a smattering of demonstrations on how to use the other important functions and their equivalents in base R:
```{r smattering}

#filter()
flights[flights$month==3 & flights$dest=="DEN",]

flights %>% 
  filter(month == 3, dest == "DEN")

#arrange()
o <- order(flights$weight_gutted)
flights[o,]

flights %>% 
  arrange(desc(weight_gutted))

#rename()
flights2 <- data.frame(flights, year2 = flights$year)
flights2 <- as.tibble(flights2[c(dim(flights2)[2],2:(dim(flights2)[2]-1))])

flights2 <- 
  flights %>% 
  rename(year2 = year)

#mutate()
flights2 <- data.frame(flights, air_time_hr = flights$air_time/60, distance_1000m = flights$distance/1000)

flights2 <-
  flights %>% 
  mutate(air_time_hr = air_time/60, distance_1000m = distance/1000)

#count() with group_by()
flights2a <- t(table(flights[,c('origin', 'dest')]))

flights2 <- 
  flights %>% 
  group_by(origin, dest) %>% 
  count()

#using spread() / gather() to get into the same tidy format generated by count():
flights2 <-
  flights2a %>% 
  as.tibble() %>% 
  gather(key = origin, value = n, -c(dest))
  

is.na(c(NA,'2','3'))
dat5 <- data.frame(x = c(NA,'2','3'), y = 1:3)
dat5 %>% 
  #filter(x == NA) # doesn't work!
  filter(is.na(x))
dat5[-3,]
dat5[!is.na(dat5$x),]

summary(dat)

gear_table<-
  data.frame(
    gear=as.factor(c(1,2,73)), 
    gear_name=c('gill', 'line', 'trawl')
  )

flights %>% 
  left_join(gear_table) %>% 
  View()

flights %>% 
  left_join(
    flights %>% 
      group_by(rect) %>% 
      summarise(length_mn = mean(length))
  ) %>% 
  View()


#general population processes?
par(mfrow = c(1,1))
plot(liver_weight ~ weight_ungutted, data = dat)

plot(log(liver_weight) ~ log(weight_gutted), data = dat, cex = 0.2)

log(c(1,2,3,4,5))
exp(c(9,10))

plot(log(weight_gutted) ~ log(liver_weight), dat = dat, cex = 0.2)
points(log(weight_ungutted) ~ log(liver_weight), dat = dat, cex = 0.2, col='red')

plot(log(weight_gutted) ~log(weight_ungutted), dat = dat, cex = 0.2, col = 'blue')

#spatial variation?

plot(log(weight_gutted) ~ log(weight_ungutted), data = dat, cex = 0.2, type = 'n')

for(i in unique(flights$rect)){
  
  points(log(weight_gutted) ~ log(weight_ungutted), 
         dat = flights[flights$rect==i,],
         cex = 0.2, col = i)

}

#simulate spatial variation...
spat <- ifelse(flights$rect %in% 
                 as.character(c(321, 322, 363, 364, 370, 371, 372, 374)), 
               1000, 0)

dat <- data.frame(dat, spat)

#spatial variation?

plot(log(weight_gutted) ~ log(weight_ungutted), dat = dat, cex = 0.2, type = 'n')
for(i in unique(flights$rect)){
  points(log(weight_gutted + spat) ~ log(weight_ungutted), 
         data = flights[flights$rect==i,], cex = 0.2, col = i)
}

boxplot(log(weight_gutted)~rect, data = dat)

#biological 

plot(weight_gutted ~ length, dat = dat, cex = 0.2, type = 'n')
points(weight_gutted ~ length, data = dat, cex = 0.2, col=2)

plot(log(weight_gutted) ~ log(length), dat = dat, cex = 0.2, type = 'n')
points(log(weight_gutted) ~ log(length), data = dat, cex = 0.2, col=2)


plot(log(weight_gutted) ~ log(length), dat = dat, cex = 0.2, type = 'n')
for(i in unique(flights$rect)){
  points(log(weight_gutted) ~ log(length), 
         data = flights[flights$rect==i,], cex = 0.2, col = i)
}

boxplot(log(length)~rect, data = dat)

plot(length ~ age, dat = dat, cex = 0.2, type = 'n')
for(i in unique(flights$rect)){
  points(length ~ age, 
         data = flights[flights$rect==i,], cex = 0.2, col = i)
}

#Does liver weight, given body weight vary spatially?
par(mfrow=c(1,1))
plot(liver_weight ~ weight_gutted, dat = dat, cex = 0.2)
plot(liver_weight ~ log(weight_gutted), dat = dat, cex = 0.2)
plot(log(liver_weight) ~ log(weight_gutted), dat = dat, cex = 0.2)

hist(flights$liver_weight/flights$weight_gutted)
hist(log(flights$liver_weight)/log(flights$weight_gutted))

liv1.lm<- lm(log(liver_weight) ~ log(weight_gutted), dat = dat)
summary(liv1.lm)

liv1.lm<- lm(log(liver_weight) ~ log(weight_gutted) + rect, dat = dat)
summary(liv1.lm)

liv1.lm<- lm(log(liver_weight) ~ log(weight_gutted)*gender, dat = dat)
summary(liv1.lm)




#Exporting plots

pdf(paste(exportto, 'PrettyPlot.pdf', sep = ''), width = 8, height = 4)

df <- layout(
  matrix(3:1, nrow = 1, ncol = 3)
  )
#layout.show(df)

par(mar = c(0,0,0,0), oma = c(3,3,1,1))

#div <- as.factor(floor(flights$rect/100)
#blank plot
plot(c(liver_weight^(1/3)) ~ c(weight_gutted^(1/3)), data = dat, 
     cex = 0.2, xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', bty = 'L')

#add data
for(i in levels(flights$rect)){
  points(c( liver_weight^(1/3) ) ~ c( weight_gutted^(1/3) ), 
         data = flights[flights$rect==i,],
         cex = 0.2, col = i)
}

#add features
axis(1, labels = c(5,10,15,20)^3, at = c(5,10,15,20))
axis(2, labels = seq(2,12,2)^3, at = seq(2,12,2))
mtext('Gutted weight (g)', 1, 2)
mtext('Liver weight', 2, 2)

plot(1:3, 1:3)

plot(5:2, 2:5)


dev.off()

###Check out ggplot2
plot1 <-
  flights %>% 
  mutate(rect2 = as.factor(floor(as.numeric(rect)/10))) %>% 
  ggplot(aes(length, weight_gutted, color = gender)) + 
  geom_point() +
  facet_wrap(~rect2)

plot2 <-
  plot1 + 
  geom_hline(aes(yintercept = mn_wt_gutted),
             data = 
               flights %>% 
               mutate(rect2 = as.factor(floor(as.numeric(rect)/10))) %>% 
               group_by(rect2) %>% 
               summarise(mn_wt_gutted = mean(weight_gutted),
                         mn_length = mean(length)))

pdf(paste(exportto, 'PrettyPlot2.pdf', sep = ''), width = 4, height = 4)
    
  print(plot2)
    
dev.off()

summary(liv1.lm)

qqnorm(liv1.lm$res); qqline(liv1.lm$residuals)

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
